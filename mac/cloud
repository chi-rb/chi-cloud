#!/bin/sh

hosts_path=/etc/hosts
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist

tmp_path=/tmp
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com
s3_initrd_url=$s3_url/initrd
s3_vmlinuz_url=$s3_url/vmlinuz
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/cloud
repo_tmp_path=/tmp/chi-cloud
repo_app_path=$repo_path/app
repo_vm_path=$repo_path/vm
repo_initrd_path=$repo_vm_path/initrd
repo_vmlinuz_path=$repo_vm_path/vmlinuz
repo_disk_path=$repo_vm_path/disk.img.xz
repo_mac_path=$repo_path/mac
repo_xhyve_path=$repo_mac_path/xhyve
repo_cloud_path=$repo_mac_path/cloud

user_cloud_path=$HOME/.cloud
user_conf_path=$user_cloud_path/conf
user_disk_path=$user_cloud_path/disk.img
user_agent_path=$HOME/Library/LaunchAgents/$agent_name

app_path=$PWD
app_cloud_path=$app_path/cloud
app_tmp_path=$app_cloud_path/tmp
app_conf_path=$app_cloud_path/conf
app_envs_path=$app_cloud_path/envs
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy

vm_user=hacker
vm_name=cloud
vm_mem=2G
vm_cpus=2

conf_names=(
	vm_mem
	vm_cpus
)
conf_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

ok() {
	if [ "$beginned" = true ]; then
		echo Ok
	fi
}

complete() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo Complete
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]')
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		rm -f $user_conf_path
		touch $user_conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $user_conf_path
		done
		configure
	fi
}

vm_exists() {
	test ! -z $vm_ip
}

host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path > /dev/null 2>&1
}

vm_ssh() {
	ssh -q -o 'UserKnownHostsFile=/dev/null' -o 'StrictHostKeyChecking=no' $vm_user@$vm_name $@
}

vm_exec() {
	if [ $# != 0 ]; then
		cmd=$@
	else
		cmd=$(</dev/stdin)
	fi
	echo "$cmd" | vm_ssh sudo sh
}

kubectl() {
	vm_exec microk8s.kubectl $@
}

app_kubectl() {
	kubectl --namespace $app_id $@
}

find_pod() {
	echo $(app_kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	app_kubectl exec -it $(find_pod $name) -- $@
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	app_env_name=${1:-development}
	ensure_app_env $app_env_name
	. $app_conf_path
	. $app_env_path
	if [ $app_env_name = development ]; then
		registry_url=$vm_ip:32000
	fi
	app_env=$app_env_name
}

ensure_app() {
	if ! app_exists; then
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	ensure_app
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

process_ymls() {
	yml_paths=$(find cloud/$1 -type f -name '*.yml')
	mkdir -p $app_tmp_path
	rm -rf $app_tmp_path/*
	for yml_path in $yml_paths; do
		yml_tmp_path=$app_tmp_path/${yml_path#$app_cloud_path}
		mkdir -p $(dirname $yml_tmp_path)
		content=$(cat $yml_path)
		var_names=$(grep -o '{{ [a-z_]* }}' $yml_path | sed 's/[{} ]//g' | uniq)
		for var_name in $var_names; do
			if [ -z ${!var_name} ]; then
				echo {{ $var_name }} undefined, processing $yml_path in $app_env_name
				exit 1
			fi
			var_value=$(echo ${!var_name} | sed 's/\//\\\//g')
			content=$(echo "$content" | sed "s/{{ $var_name }}/$var_value/g")
		done
		echo "$content" >> $yml_tmp_path
	done
	echo $app_tmp_path
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)

	begin Choosing Configuration
	mkdir $user_cloud_path
	configure

	if [ ! -d $repo_path ]; then
		begin Cloning Repository
		git clone git@github.com:chi-rb/chi-cloud.git $repo_tmp_path
		sudo mv $repo_tmp_path $repo_path
		sudo ln -s $repo_cloud_path $cloud_path

		begin Dowloading Images
		mkdir $repo_vm_path
		curl -o $repo_initrd_path $s3_initrd_url
		curl -o $repo_vmlinuz_path $s3_vmlinuz_url
		curl -o $repo_disk_path $s3_disk_url
	fi

	if ! vm_exists; then
		begin Creating Virtual Machine
		tar xJvf $repo_disk_path -C $user_cloud_path
		vm_id=$(gen_id)
		cat <<-XML | sudo tee $user_agent_path >/dev/null
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
			<plist version="1.0">
				<dict>
					<key>Label</key>
					<string>com.cloud</string>
					<key>ProgramArguments</key>
					<array>
						<string>$repo_xhyve_path</string>
						<string>-A</string>
						<string>-U</string>
						<string>$vm_id</string>
						<string>-c</string>
						<string>$vm_cpus</string>
						<string>-m</string>
						<string>$vm_mem</string>
						<string>-s</string>
						<string>0,hostbridge</string>
						<string>-s</string>
						<string>2,virtio-net</string>
						<string>-s</string>
						<string>4,virtio-blk,$user_disk_path</string>
						<string>-f</string>
						<string>kexec,$repo_vmlinuz_path,$repo_initrd_path,root=/dev/vda1 ro</string>
					</array>
					<key>RunAtLoad</key>
					<true/>
				</dict>
			</plist>
		XML
		cloud vm start
		nc -l 1234 > $tmp_conf_path
		. $tmp_conf_path
		cat $tmp_conf_path >> $user_conf_path
		rm $tmp_conf_path
	fi

	if ! host_exists; then
		begin Adding Hostname
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if ! export_exists; then
		begin Sharing Home Folder
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		sudo nfsd update
		vm_exec <<-SSH
			echo "$mac_ip:$exports_home_path\t$HOME\tnfs defaults\t0 0" >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	fi

	complete

;;
uninstall)

	if [ -f $user_agent_path ]; then
		begin Removing Virtual Machine
		sudo launchctl unload -w $user_agent_path
		sudo rm $user_agent_path
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Unsharing Home Folder
		escaped_exports_home_path=$(echo $exports_home_path | sed 's/\//\\\//g')
		sudo sed -i '' "/$escaped_exports_home_path/d" $exports_path
		sudo nfsd update
	fi

	if [ -d $user_cloud_path ]; then
		begin Removing Configuration
		rm -rf $user_cloud_path
	fi

	if [ -d $repo_path ]; then
		begin Removing Repository
		sudo rm -rf $repo_path $cloud_path
	fi

	complete

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
update)

	begin Updating Repository
	git -C $repo_path pull
	git checkout $2
	
	complete

;;
vm)

	case $2 in
	start)

		sudo launchctl load -w $user_agent_path

	;;
	stop)

		sudo launchctl unload -w $user_agent_path

	;;
	restart)

		cloud vm stop
		cloud vm start

	;;
	shell)

		vm_ssh

	;;
	help)

		cat <<-DOC
			Usage: cloud vm <commands> [options]
			Manages virtual machine.

			Available commands:
			  start         Boots virtual machine
			  stop          Halts virtual machine
			  restart       Stops and starts
			  shell         Attachs bash session
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
app)

	case $2 in
	init)

		if ! app_exists; then
			begin Generating Cloud Folder
			cp -r $repo_app_path $app_cloud_path
			app_id=$(gen_id)
			echo app_id=$app_id >> $app_conf_path
			load_app

			begin Assigning Namespace
			kubectl create namespace $app_id

			complete
		else
			echo Already exists
		fi

	;;
	open)

		load_app
		open "http://$vm_name:$rails_port"

	;;
	remove)

		load_app

		begin Removing Namespace
		kubectl delete namespace $app_id

		begin Removing Cloud Folder
		rm -rf $app_cloud_path

		complete

	;;
	envs)

		case $3 in
		''|list)

			ensure_app
			list=$(ls -1 $app_envs_path)
			if [ -z "$list" ]; then
				echo No environments found
			else
				echo "$list"
			fi

		;;
		add)

			ensure_app
			if app_env_exists $4; then
				echo Environment $4 already exists
			else
				mkdir -p $app_envs_path
				touch $app_env_path
				cloud app envs edit $4
			fi

		;;
		edit)

			ensure_app_env $4
			edit $app_env_path

		;;
		remove)

			ensure_app_env $4
			rm -f $app_env_path

		;;
		help)

			cat <<-DOC
				Usage: cloud app envs <commands> [options]
				Manages app envs.

				Available commands:
				  list          Lists envs
				  add           Adds env
				  edit          Edits env
				  remove        Removes env
				  help          Prints documentation
			DOC

		;;
		*)

			unknown

		;;
		esac

	;;
	build)

		load_app
		app_kubectl apply -Rf $(process_ymls build)
		ok

		echo "\nUse \`cloud app log <pod-name>\` to see logs"

	;;
	deploy)

		load_app
		app_kubectl apply -Rf "$(process_ymls deploy)"

	;;
	undeploy)

		load_app
		app_kubectl delete --all deployments

	;;
	console)

		load_app
		pod_exec rails bin/rails c

	;;
	shell)

		load_app
		pod_exec ${3:-rails} /bin/bash

	;;
	status)

		load_app
		case $3 in
		'')
			app_kubectl get pods
		;;
		*)
			app_kubectl describe pod $3
		;;
		esac

	;;
	log)

		load_app
		app_kubectl logs -f $(find_pod ${3:-rails})

	;;
	help)

		cat <<-DOC
			Usage: cloud app <commands> [options]
			Manages app.

			Available commands:
			  envs          Manages environments
			  build         Builds docker images
			  deploy        Applies one or all deploy ymls
			  undeploy      Unapplies one or all deploy ymls
			  console       Attachs rails console
			  shell         Attachs bash session in pod (rails pod by default)
			  status        Lists or describes pods (lists pods by default)
			  log           Tails pod logs (rails pod by default)
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  vm            Manages virtual machine
		  app           Manages app
		  help          Prints documentation
	DOC

;;
*)

	unknown

;;
esac
