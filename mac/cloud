#!/bin/sh

hosts_path=/etc/hosts
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist
rails_pod=rails

tmp_path=/tmp
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com
s3_initrd_url=$s3_url/initrd
s3_vmlinuz_url=$s3_url/vmlinuz
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/cloud
repo_tmp_path=/tmp/chi-cloud
repo_app_path=$repo_path/app
repo_vm_path=$repo_path/vm
repo_initrd_path=$repo_vm_path/initrd
repo_vmlinuz_path=$repo_vm_path/vmlinuz
repo_disk_path=$repo_vm_path/disk.img.xz
repo_mac_path=$repo_path/mac
repo_xhyve_path=$repo_mac_path/xhyve
repo_cloud_path=$repo_mac_path/cloud

user_cloud_path=$HOME/.cloud
user_conf_path=$user_cloud_path/conf
user_auth_path=$user_cloud_path/auth.json
user_disk_path=$user_cloud_path/disk.img
user_agent_path=$HOME/Library/LaunchAgents/$agent_name

app_path=$PWD
app_cloud_path=$app_path/cloud
app_tmp_path=$app_path/tmp/cloud
app_apply_path=$app_tmp_path/apply
app_secret_path=$app_apply_path/secret.yml
app_namespace_path=$app_apply_path/namespace.yml
app_kustomization_path=$app_apply_path/kustomization.yml
app_envs_path=$app_cloud_path/envs
app_base_path=$app_envs_path/base
app_dev_path=$app_envs_path/development
app_prod_path=$app_envs_path/production
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy
app_snippets_path=$app_deploy_path/snippets

vm_user=hacker
vm_name=cloud
vm_mem=2G
vm_cpus=2

k3s_latest_url=https://github.com/rancher/k3s/releases/latest
k3s_path=/usr/local/bin/k3s

conf_names=(
	vm_mem
	vm_cpus
)
conf_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

ok() {
	if [ "$beginned" = true ]; then
		echo Ok
	fi
}

complete() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo Complete
}

error() {
	echo $@ >&2
	exit 1
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]')
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		rm -f $user_conf_path
		touch $user_conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $user_conf_path
		done
		configure
	fi
}

authorize() {
	echo "Enter username: \c"
	read auth_user
	echo "Enter password: \c"
	read -s auth_pass
}

vm_exists() {
	test ! -z $vm_ip
}

host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path > /dev/null 2>&1
}

vm_ssh() {
	ssh -tq \
	-o 'ControlMaster=auto' \
	-o 'ControlPersist=600' \
	-o 'ControlPath=/tmp/%r@%h' \
	-o 'UserKnownHostsFile=/dev/null' \
	-o 'StrictHostKeyChecking=no' \
	$vm_user@$vm_name $@
}

vm_kubectl() {
	vm_ssh sudo kubectl $@
}

app_kubectl() {
	cmd=$@
	if [ ! -z $app_id ]; then
		cmd="-n $app_id $cmd"
	fi
	vm_kubectl $cmd
}

find_pod() {
	echo $(app_kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	app_kubectl exec -it $(find_pod $name) -- $@
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	app_env_name=${1:-development}
	app_env=$app_env_name
	ensure_app_env $app_env_name
	. $app_base_path
	. $app_env_path
	app_id=$app_name-$app_env_name
}

ensure_app() {
	if ! app_exists; then
		error No cloud folder found
	fi
}

unknown() {
	echo Unknown command \`$1\`
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		error No environment specified
	fi
}

ensure_app_env() {
	ensure_app
	if ! app_env_exists $1; then
		error Environment $1 not exists
	fi
}

compile_tpl() {
	tpl_output=$(cat $1)
	name=$3
	tpl_subs=$(grep -o '{{ [a-z_. ]* }}' $1 | uniq)
	while read tpl_sub; do
		tpl_sub_args=( $(echo $tpl_sub | sed 's/{{ //' | sed 's/ }}//') )
		case $tpl_sub in
		{{\ render\ *)
			render_path=${tpl_sub_args[1]}
			render_vars=("${tpl_sub_args[@]:2}")
			for render_var in $render_vars; do
				declare $render_var
			done
			render_snippet_path=$app_snippets_path/$render_path.yml
			tpl_sub_value=$(compile_tpl $render_snippet_path $2 $3 | sed 's/\//\\\//g' | tr '\n' '\r')
			tpl_output=$(echo "$tpl_output" | sed "s/$tpl_sub/$tpl_sub_value/g" | tr '\r' '\n')
		;;
		*)
			tpl_sub_name=${tpl_sub_args[0]}
			tpl_prefixed_sub_name=${2}_${tpl_sub_name}
			if [ ! -z ${!tpl_prefixed_sub_name} ]; then
				tpl_normalized_sub_name=$tpl_prefixed_sub_name
			elif [ ! -z ${!tpl_sub_name} ]; then
				tpl_normalized_sub_name=$tpl_sub_name
			else
				error $tpl_sub undefined, compiling $1 in $app_env_name
			fi
			tpl_sub_value=$(echo ${!tpl_normalized_sub_name} | sed 's/\//\\\//g')
			tpl_output=$(echo "$tpl_output" | sed "s/$tpl_sub/$tpl_sub_value/g")
		;;
		esac
	done <<-EOF
		$(echo "$tpl_subs")
	EOF
	echo "$tpl_output"
}

compile_tpls() {
	rm -rf $app_tmp_path/*
	tpl_root_paths=$app_cloud_path/$1
	if [ "$1" = deploy ]; then
		tpl_root_paths="$tpl_root_paths/base $tpl_root_paths/$app_env_name"
	fi
	for tpl_root_path in $tpl_root_paths; do
		tpl_paths=( $(find $tpl_root_path -type f -name '*.yml') )
		tpl_names=()
		tpl_pod_names=()
		for tpl_path in ${tpl_paths[@]}; do
			tpl_name=$(basename $tpl_path)
			tpl_relative_path=${tpl_path#$tpl_root_path/}
			if [ $tpl_relative_path = $tpl_name ]; then
				tpl_name=$(echo $tpl_name | sed 's/.yml//')
			else
				tpl_name=$(echo "$tpl_relative_path" | cut -d '/' -f1)
			fi
			tpl_name=$(echo $tpl_name | tr - _)
			tpl_names=(${tpl_names[@]} $tpl_name)
			if [ "$1" = build ]; then
				tpl_suffixed_name=${tpl_name}_build
			else
				tpl_suffixed_name=$tpl_name
			fi
			tpl_pod_name=$(echo $tpl_suffixed_name | tr _ -)
			tpl_pod_names=(${tpl_pod_names[@]} $tpl_pod_name)
			declare "${tpl_name}_host=$tpl_pod_name"
		done
		for i in ${!tpl_paths[@]}; do
			tpl_path=${tpl_paths[$i]}
			tpl_name=${tpl_names[$i]}
			tpl_pod_name=${tpl_pod_names[$i]}
			tpl_tmp_path=$app_apply_path/${tpl_path#$app_cloud_path}
			mkdir -p $(dirname $tpl_tmp_path)
			echo "$(compile_tpl $tpl_path $tpl_name $tpl_pod_name)" >> $tpl_tmp_path
		done
	done
}

compile_statics() {
	cat <<-YML > $app_secret_path
		apiVersion: v1
		kind: Secret
		metadata:
		  name: docker
		  labels:
		    name: docker
		type: kubernetes.io/dockerconfigjson
		data:
		  .dockerconfigjson: $(cat $user_auth_path | base64)
	YML
	cat <<-YML > $app_namespace_path
		apiVersion: v1
		kind: Namespace
		metadata:
		  name: $app_id
		  labels:
		    name: $app_id
	YML
	escaped_app_apply_path=$(echo $app_apply_path/ | sed 's/\//\\\//g')
	resources=$(find $app_apply_path -name '*.yml' | sed "s/$escaped_app_apply_path//g" | sed 's/^/  - /g')
  cat <<-YML > $app_kustomization_path
		namespace: $app_id
		resources:
		$resources
	YML
}

compile_all() {
	compile_tpls $1
	compile_statics
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)

	begin Choosing Configuration
	mkdir $user_cloud_path
	configure

	if [ ! -d $repo_path ]; then
		begin Cloning Repository
		git clone git@github.com:chi-rb/chi-cloud.git $repo_tmp_path
		sudo mv $repo_tmp_path $repo_path
		sudo ln -s $repo_cloud_path $cloud_path

		begin Dowloading Images
		mkdir $repo_vm_path
		curl -o $repo_initrd_path $s3_initrd_url
		curl -o $repo_vmlinuz_path $s3_vmlinuz_url
		curl -o $repo_disk_path $s3_disk_url
	fi

	if ! vm_exists; then
		begin Creating Virtual Machine
		tar xJvf $repo_disk_path -C $user_cloud_path
		vm_id=$(gen_id)
		cat <<-XML | sudo tee $user_agent_path >/dev/null
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
			<plist version="1.0">
				<dict>
					<key>Label</key>
					<string>com.cloud</string>
					<key>ProgramArguments</key>
					<array>
						<string>$repo_xhyve_path</string>
						<string>-A</string>
						<string>-U</string>
						<string>$vm_id</string>
						<string>-c</string>
						<string>$vm_cpus</string>
						<string>-m</string>
						<string>$vm_mem</string>
						<string>-s</string>
						<string>0,hostbridge</string>
						<string>-s</string>
						<string>2,virtio-net</string>
						<string>-s</string>
						<string>4,virtio-blk,$user_disk_path</string>
						<string>-f</string>
						<string>kexec,$repo_vmlinuz_path,$repo_initrd_path,root=/dev/vda1 ro</string>
					</array>
					<key>RunAtLoad</key>
					<true/>
				</dict>
			</plist>
		XML
		cloud vm start
		nc -l 1234 > $tmp_conf_path
		. $tmp_conf_path
		cat $tmp_conf_path >> $user_conf_path
		rm $tmp_conf_path
	fi

	if ! host_exists; then
		begin Adding Hostname
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if ! export_exists; then
		begin Sharing Home Folder
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		sudo nfsd update
		vm_ssh sudo sh <<-SSH
			echo "$mac_ip:$exports_home_path\t$HOME\tnfs local_lock=all\t0 0" >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	fi

	begin Authorizing hub.docker.com
	authorize
	cat <<-JSON > $user_auth_path
		{
		  "auths": {
		    "https://index.docker.io/v1/": {
		      "auth": "$(echo "$auth_user:$auth_pass\c" | base64)"
		    }
		  }
		}
	JSON

	complete

;;
uninstall)

	if [ -f $user_agent_path ]; then
		begin Removing Agent
		sudo launchctl unload -w $user_agent_path
		sudo rm $user_agent_path
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Unsharing Home Folder
		escaped_exports_home_path=$(echo $exports_home_path | sed 's/\//\\\//g')
		sudo sed -i '' "/$escaped_exports_home_path/d" $exports_path
		sudo nfsd update
	fi

	if [ -d $user_cloud_path ]; then
		begin Removing Settings
		rm -rf $user_cloud_path
	fi

	if [ -d $repo_path ]; then
		begin Removing Cloud
		sudo rm -rf $repo_path $cloud_path
	fi

	complete

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
update)

	begin Updating Repository
	current_path=$(pwd)
	cd $repo_path
	git pull
	repo_current_branch=$(git branch | cut -d ' ' -f2)
	repo_new_branch=${2:-master}
	if [ $repo_current_branch != $repo_new_branch ]; then
		git checkout $repo_new_branch
	fi
	cd $current_path

	complete

;;
vm)

	case $2 in
	start)

		sudo launchctl load -w $user_agent_path

	;;
	stop)

		sudo launchctl unload -w $user_agent_path

	;;
	restart)

		cloud vm stop
		cloud vm start

	;;
	shell)

		vm_ssh

	;;
	exec)

		shift 2
		if [ $# -gt 1 ] && [ "$1" = -- ]; then
			shift
		else
			error Wrong format
		fi
		vm_ssh $@

	;;
	update)

		begin Updating Packages
		vm_ssh sudo sh <<-SSH
			apt update
			DEBIAN_FRONTEND=noninteractive apt upgrade -y
		SSH

		begin Updating K3S
		k3s_version_regex='v[0-9]\.[0-9]\.[0-9]'
		k3s_current_version=$(vm_ssh k3s -v | grep -o $k3s_version_regex)
		k3s_latest_version=$(curl -sD - $k3s_latest_url | grep -o $k3s_version_regex | head -n1)
		if [ $k3s_current_version != $k3s_latest_version ]; then
			k3s_url="https://github.com/rancher/k3s/releases/download/$k3s_latest_version/k3s"
			vm_ssh sudo sh <<-SSH
				systemctl stop k3s
				curl -Lo $k3s_path $k3s_url
				chmod +x $k3s_path
				systemctl start k3s
			SSH
		else
			echo Already up to date
		fi

		complete

	;;
	help)

		cat <<-DOC
			Usage: cloud vm <commands> [options]

			Available commands:
			  start         Boots virtual machine
			  stop          Halts virtual machine
			  restart       Stops and starts
			  shell         Attachs bash session
			  exec          Executes command
			  update        Updates virtual machine
			  help          Prints documentation
		DOC

	;;
	*)

		unknown $2
		echo
		cloud vm help

	;;
	esac

;;
app)

	case $2 in
	init)

		if ! app_exists; then
			begin Generating Cloud Folder
			cp -r $repo_app_path $app_cloud_path

			begin Setting Application Name
			echo "Enter name: \c"
			read	app_name
			echo "app_name=$app_name\n" >> $app_base_path

			begin Setting Rails Docker Repository
			echo "Enter repo: \c"
			read rails_repo
			echo "rails_repo=$rails_repo:\$app_env\n" >> $app_base_path

			complete
		else
			echo Already exists
		fi

	;;
	open)

		load_app
		open "http://$vm_name:$rails_cluster_port"

	;;
	destroy)

		load_app

		begin Removing Namespace
		vm_kubectl delete namespace $app_id

		begin Removing Cloud Folder
		rm -rf $app_cloud_path

		complete

	;;
	envs)

		case $3 in
		''|list)

			ensure_app
			list=$(ls -1 $app_envs_path)
			if [ -z "$list" ]; then
				error No environments found
			else
				echo "$list"
			fi

		;;
		add)

			ensure_app
			if app_env_exists $4; then
				error Environment $4 already exists
			else
				mkdir -p $app_envs_path
				touch $app_env_path
				cloud app envs edit $4
			fi

		;;
		edit)

			ensure_app_env $4
			edit $app_env_path

		;;
		remove)

			ensure_app_env $4
			rm -f $app_env_path

		;;
		help)

			cat <<-DOC
				Usage: cloud app envs <commands> [options]

				Available commands:
				  list          Lists envs
				  add           Adds env
				  edit          Edits env
				  remove        Removes env
				  help          Prints documentation
			DOC

		;;
		*)

			unknown $3
			echo
			cloud app envs help

		;;
		esac

	;;
	build)

		load_app
		build_names=$(app_kubectl get pods --no-headers=true | awk '/-build/{ORS=" "; print $1}')
		if [ ! -z $build_names ]; then
			app_kubectl delete pods $build_names
		fi
		compile_tpls build
		compile_statics
		vm_kubectl apply -k $app_apply_path
		ok

		echo "\nUse \`cloud app log <pod-name>\` to see logs"

	;;
	deploy)

		load_app
		compile_all deploy
		vm_kubectl apply -k $app_apply_path

	;;
	undeploy)

		load_app
		app_kubectl delete --all deployments

	;;
	restart)

		load_app
		app_kubectl delete pod $(find_pod ${3:-$rails_pod})

	;;
	console)

		load_app
		pod_exec $rails_pod bin/rails c

	;;
	shell)

		load_app
		pod_exec ${3:-$rails_pod} /bin/bash

	;;
	attach)

		load_app
		app_kubectl attach -it $(find_pod ${3:-$rails_pod})

	;;
	tunnel)

		load_app
		port=$(app_kubectl get service $3 --no-headers=true | awk '{ print $5 }' | sed 's/\/.*//')
		app_kubectl port-forward $(find_pod $3) $port:$port

	;;
	exec)

		load_app
		shift 2
		if [ $# -gt 1 ] && [ "$1" = -- ]; then
			name=$rails_pod
			shift
		elif [ $# -gt 2 ] && [ "$2" = -- ]; then
			name=$1
			shift 2
		else
			error Wrong format
		fi
		pod_exec $name $@

	;;
	status)

		load_app
		case $3 in
		'')
			app_kubectl get pods
		;;
		*)
			app_kubectl describe pod $(find_pod ${3:-$rails_pod})
		;;
		esac

	;;
	log)

		load_app
		app_kubectl logs -f $(find_pod ${3:-$rails_pod})

	;;
	help)

		cat <<-DOC
			Usage: cloud app <commands> [options]

			Available commands:
			  init          Initializes app
			  destroy       Destroys app
			  envs          Manages environments
			  build         Builds docker images
			  deploy        Applies one or all deploy ymls
			  undeploy      Unapplies one or all deploy ymls
			  console       Attachs rails console
			  shell         Attachs bash session in pod (rails pod by default)
			  exec          Executes command in pod
			  status        Lists or describes pods (lists pods by default)
			  log           Tails pod logs (rails pod by default)
			  help          Prints documentation
		DOC

	;;
	*)

		unknown $2
		echo
		cloud app help

	;;
	esac

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  vm            Manages virtual machine
		  app           Manages app
		  update        Updates script
		  help          Prints documentation
	DOC

;;
*)

	unknown $1
	echo
	cloud help

;;
esac
