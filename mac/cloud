#!/bin/sh

tmp_path=/tmp
hosts_path=/etc/hosts
exports_path=/etc/exports
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist

repo_path=/usr/local/cloud
repo_tmp_path=/tmp/chi-cloud
repo_app_path=$repo_path/app
repo_vm_path=$repo_path/vm
repo_init_path=$repo_vm_path/cloud-init.yml
repo_mac_path=$repo_path/mac
repo_cloud_path=$repo_mac_path/cloud
repo_agent_path=$repo_mac_path/$agent_name

user_cloud_path=~/.cloud
user_conf_path=$user_cloud_path/conf
user_agent_path=~/Library/LaunchAgents/$agent_name

app_cloud_path=cloud
app_tmp_path=$app_cloud_path/tmp
app_conf_path=$app_cloud_path/conf
app_envs_path=$app_cloud_path/envs
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy

mp_path=$bin_path/multipass
mp_ver=0.8.0
mp_pkg_url=https://github.com/CanonicalLtd/multipass/releases/download/v$mp_ver/multipass-$mp_ver%2Bmac-Darwin.pkg
mp_pkg_path=$tmp_path/multipass.pkg
mp_uninstall_path=/Library/Application\ Support/com.canonical.multipass/uninstall.sh

vm_name=cloud
vm_mem=2G
vm_cpus=2
vm_disk=10G

conf_names=(
		mp_ver
		vm_name
		vm_mem
		vm_cpus
		vm_disk
		)
conf_descs=(
		'Multipass version'
	'Virtual machine name'
	'Virtual machine memory'
	'Virtual machine cpus'
	'Virtual machine disk'
)

ok() {
	if [ "$beginned" = true ]; then
		echo Ok
	fi
}

complete() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	if [ ! -z $1 ]; then
		echo $1 Complete
	fi
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		mkdir -p $user_cloud_path
		rm -f $user_conf_path
		touch $user_conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $user_conf_path
		done
		configure
	fi
}

mp_current_ver() {
	echo $(multipass version | head -n1 | awk '{ print $2 }' | sed 's/+.*//')
}

vm_exists() {
	multipass info $vm_name > /dev/null 2>&1
}

host_exists() {
	sudo grep $vm_name $hosts_path > /dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep '# Cloud' $exports_path > /dev/null 2>&1
}

mp_exec() {
	if [ $# != 0 ]; then
		cmd=$@
	else
		cmd=$(</dev/stdin)
	fi
	echo "$cmd" | ssh -q -o 'UserKnownHostsFile=/dev/null' -o 'StrictHostKeyChecking=no' multipass@$vm_name sudo sh
}

kubectl() {
	mp_exec microk8s.kubectl $@
}

app_kubectl() {
	kubectl --namespace $app_id $@
}

find_pod() {
	echo $(app_kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	app_kubectl exec -it $(find_pod $name) -- $@
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]' | sed 's/-//g')
}

vm_ip() {
	echo $(multipass info $vm_name | grep IP | awk '{ print $2 }')
}

mac_ip() {
	echo $(vm_ip) | sed 's/[0-9]*$/1/'
}

k8s_exists() {
	multipass exec $vm_name -- test -f /snap/bin/microk8s.kubectl
	return $?
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	app_env_name=${1:-development}
	ensure_app_env $app_env_name
	. $app_conf_path
	. $app_env_path
	app_mount_path=/mnt/$app_id
	app_share_path=$(pwd)
	if [ $app_env_name = development ]; then
		registry_url=$(vm_ip):32000
	fi
	app_path=$app_mount_path
	app_env=$app_env_name
}

ensure_app() {
	if ! app_exists; then
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	ensure_app
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

process_ymls() {
	yml_paths=$(find cloud/$1 -type f -name '*.yml')
	mkdir -p $app_tmp_path
	rm -rf $app_tmp_path/*
	for yml_path in $yml_paths; do
		yml_tmp_path=$app_tmp_path/${yml_path#$app_cloud_path}
		mkdir -p $(dirname $yml_tmp_path)
		content=$(cat $yml_path)
		var_names=$(grep -o '{{ [a-z_]* }}' $yml_path | sed 's/[{} ]//g' | uniq)
		for var_name in $var_names; do
			if [ -z ${!var_name} ]; then
				echo {{ $var_name }} undefined, processing $yml_path in $app_env_name
				exit 1
			fi
			var_value=$(echo ${!var_name} | sed 's/\//\\\//g')
			content=$(echo "$content" | sed "s/{{ $var_name }}/$var_value/g")
		done
		echo "$content" >> $yml_tmp_path
	done
	echo /mnt/$app_id/$app_tmp_path
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)

	begin Choosing Configuration
	configure

	if [ ! -d $repo_path ]; then
		begin Cloning Repository
		git clone git@github.com:chi-rb/chi-cloud.git $repo_tmp_path
		sudo mv $repo_tmp_path $repo_path
		sudo ln -s $repo_cloud_path $cloud_path
	fi

	if [ ! -f $mp_path ] || [ $mp_ver != $(mp_current_ver) ]; then
		begin Installing Multipass $mp_ver
		if [ -f $mp_path ] && [ ! -z "$(sudo pgrep multipass)" ]; then
			echo Multipass is running, close it and run the script again
			exit 1
		fi
		curl -Lo $mp_pkg_path $mp_pkg_url
		sudo installer -pkg $mp_pkg_path -target /
		rm $mp_pkg_path
	fi

	if ! vm_exists; then
		begin Creating Virtual Machine
		multipass launch -c $vm_cpus -m $vm_mem -d $vm_disk -n $vm_name --cloud-init $repo_init_path
	fi

	if ! host_exists; then
		begin Adding Hostname
		echo $(vm_ip) $vm_name | sudo tee -a $hosts_path
	fi

	if ! k8s_exists; then
		begin Installing Kubernetes
		mp_exec <<-SSH
			apt-get install -y nfs-common
			snap install microk8s --classic
			cat <<-CONF >> /var/snap/microk8s/current/args/kube-apiserver

			# Enable insecure connections
			--insecure-bind-address=0.0.0.0
			--insecure-port=8080
			CONF
			microk8s.status --wait-ready
			microk8s.enable dns registry
		SSH
	fi

	if [ ! -f $user_agent_path ]; then
		begin Installing Agent
		ln -s $repo_agent_path $user_agent_path
		launchctl load -w $user_agent_path
	fi

	complete Installation

;;
uninstall)

	if [ -f $user_agent_path ]; then
		begin Uninstalling Agent
		launchctl unload -w $user_agent_path
		rm $user_agent_path
	fi

	if [ -f $mp_path ]; then
		begin Uninstalling Multipass
		yes | sudo sh "$mp_uninstall_path"
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Removing Shared Folder
		sudo sed -i '' '/# Cloud/,$ d' /etc/exports
		sudo nfsd update
	fi

	if [ -d $user_cloud_path ]; then
		begin Removing Configuration
		rm -rf $user_cloud_path
	fi

	if [ -d $repo_path ]; then
		begin Removing Repository
		sudo rm -rf $repo_path $cloud_path
	fi

	complete Uninstallation

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
update)

	begin Updating Repository
	git -C $repo_path pull
	git checkout $2
	
	complete Update

;;
vm)

	case $2 in
	start)

		multipass start $vm_name

	;;
	stop)
		multipass stop $vm_name

	;;
	restart)

		cloud vm stop
		echo
		cloud vm start

	;;
	shell)

		multipass shell $vm_name

	;;
	help)

		cat <<-DOC
			Usage: cloud vm <commands> [options]
			Manages virtual machine.

			Available commands:
			  start         Boots virtual machine
			  stop          Halts virtual machine
			  restart       Stops and starts
			  shell         Attachs bash session
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
app)

	case $2 in
	init)

		if ! app_exists; then
			begin Generating Cloud Folder
			cp -r $repo_app_path $app_cloud_path
			app_id=$(gen_id)
			echo app_id=$app_id >> $app_conf_path
			load_app

			begin Sharing Application
			if ! export_exists; then
				echo '# Cloud' | sudo tee -a $exports_path
			fi
			echo $app_share_path -mapall=$(id -u) | sudo tee -a $exports_path
			sudo nfsd update
			mp_exec <<-SSH
				echo "$(mac_ip):$app_share_path\t$app_mount_path\tnfs defaults\t0 0" >> /etc/fstab
				mkdir -p $app_mount_path
				mount $app_mount_path
			SSH

			begin Assigning Namespace
			kubectl create namespace $app_id

			complete Initialization
		else
			echo Already exists
		fi

	;;
	open)

		load_app
		open "http://$vm_name:$rails_port"

	;;
	remove)

		load_app

		begin Removing Namespace
		kubectl delete namespace $app_id

		begin Unsharing Application
		mp_exec <<-SSH
			umount $app_mount_path
			sed -i "/$app_id/d" /etc/fstab
			rmdir $app_mount_path
		SSH
		escaped_app_share_path=$(echo $app_share_path | sed 's/\//\\\//g')
		sudo sed -i '' "/$escaped_app_share_path/d" $exports_path
		sudo nfsd update

		begin Removing Cloud Folder
		rm -rf $app_cloud_path

		complete Removal

	;;
	envs)

		case $3 in
		''|list)

			ensure_app
			list=$(ls -1 $app_envs_path)
			if [ -z "$list" ]; then
				echo No environments found
			else
				echo "$list"
			fi

		;;
		add)

			ensure_app
			if app_env_exists $4; then
				echo Environment $4 already exists
			else
				mkdir -p $app_envs_path
				touch $app_env_path
				cloud app envs edit $4
			fi

		;;
		edit)

			ensure_app_env $4
			edit $app_env_path

		;;
		remove)

			ensure_app_env $4
			rm -f $app_env_path

		;;
		help)

			cat <<-DOC
				Usage: cloud app envs <commands> [options]
				Manages app envs.

				Available commands:
				  list          Lists envs
				  add           Adds env
				  edit          Edits env
				  remove        Removes env
				  help          Prints documentation
			DOC

		;;
		*)

			unknown

		;;
		esac

	;;
	build)

		load_app
		app_kubectl apply -Rf $(process_ymls build)
		ok

		echo "\nHINT: Use \`cloud app log <pod-name>\` to see logs"

	;;
	deploy)

		load_app
		app_kubectl apply -Rf "$(process_ymls deploy)"

	;;
	undeploy)

		load_app
		app_kubectl delete --all deployments

	;;
	console)

		load_app
		pod_exec rails bin/rails c

	;;
	shell)

		load_app
		pod_exec ${3:-rails} /bin/bash

	;;
	status)

		load_app
		case $3 in
		'')
			app_kubectl get pods
		;;
		*)
			app_kubectl describe pod $3
		;;
		esac

	;;
	log)

		load_app
		app_kubectl logs -f $(find_pod ${3:-rails})

	;;
	help)

		cat <<-DOC
			Usage: cloud app <commands> [options]
			Manages app.

			Available commands:
			  envs          Manages environments
			  build         Builds docker images
			  deploy        Applies one or all deploy ymls
			  undeploy      Unapplies one or all deploy ymls
			  console       Attachs rails console
			  shell         Attachs bash session in pod (rails pod by default)
			  status        Lists or describes pods (lists pods by default)
			  log           Tails pod logs (rails pod by default)
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  vm            Manages virtual machine
		  app           Manages app
		  help          Prints documentation
	DOC

;;
*)

	unknown

;;
esac
