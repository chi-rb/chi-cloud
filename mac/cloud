#!/bin/sh

hosts_path=/etc/hosts
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist
rails_pod=rails

tmp_path=/tmp
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com
s3_initrd_url=$s3_url/initrd
s3_vmlinuz_url=$s3_url/vmlinuz
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/cloud
repo_tmp_path=/tmp/chi-cloud
repo_app_path=$repo_path/app
repo_vm_path=$repo_path/vm
repo_initrd_path=$repo_vm_path/initrd
repo_vmlinuz_path=$repo_vm_path/vmlinuz
repo_disk_path=$repo_vm_path/disk.img.xz
repo_mac_path=$repo_path/mac
repo_xhyve_path=$repo_mac_path/xhyve
repo_cloud_path=$repo_mac_path/cloud

user_cloud_path=$HOME/.cloud
user_conf_path=$user_cloud_path/conf
user_auth_path=$user_cloud_path/auth.json
user_secret_path=$user_cloud_path/secret.yml
user_disk_path=$user_cloud_path/disk.img
user_agent_path=$HOME/Library/LaunchAgents/$agent_name

app_path=$PWD
app_cloud_path=$app_path/cloud
app_tmp_path=$app_path/tmp/cloud
app_apply_path=$app_tmp_path/apply
app_envs_path=$app_cloud_path/envs
app_base_path=$app_envs_path/base
app_dev_path=$app_envs_path/development
app_prod_path=$app_envs_path/production
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy
app_snippets_path=$app_deploy_path/snippets

vm_user=hacker
vm_name=cloud
vm_mem=2G
vm_cpus=2

conf_names=(
	vm_mem
	vm_cpus
)
conf_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

ok() {
	if [ "$beginned" = true ]; then
		echo Ok
	fi
}

complete() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo Complete
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]')
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		rm -f $user_conf_path
		touch $user_conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $user_conf_path
		done
		configure
	fi
}

authorize() {
	echo "Enter username: \c"
	read auth_user
	echo "Enter password: \c"
	read auth_pass
}

vm_exists() {
	test ! -z $vm_ip
}

host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path > /dev/null 2>&1
}

vm_ssh() {
	ssh -tq \
	-o 'ControlMaster=auto' \
	-o 'ControlPersist=600' \
	-o 'ControlPath=/tmp/%r@%h' \
	-o 'UserKnownHostsFile=/dev/null' \
	-o 'StrictHostKeyChecking=no' \
	$vm_user@$vm_name $@
}

vm_exec() {
	if [ $# != 0 ]; then
		vm_ssh sudo $@
	else
		vm_ssh sudo sh </dev/stdin
	fi
}

kubectl() {
	vm_exec kubectl $@
}

expand_pod_name() {
	echo $app_name-$1-$app_env
}

find_pod() {
	echo $(kubectl get pod -l "name=$(expand_pod_name $1)" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	kubectl exec -it $(find_pod $name) -- $@
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	app_env_name=${1:-development}
	app_env=$app_env_name
	ensure_app_env $app_env_name
	. $app_base_path
	. $app_env_path
}

ensure_app() {
	if ! app_exists; then
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	ensure_app
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

compile_tpl() {
	tpl_content=$(cat $1)
	name=$(expand_pod_name $2)
	tokens=$(grep -o '{{ [a-z_. ]* }}' $1 | uniq)
	while read token; do
		token_args=( $(echo $token | sed 's/{{ //' | sed 's/ }}//') )
		case $token in
		{{\ render\ *)
			render_path=${token_args[1]}
			render_vars=("${token_args[@]:2}")
			for render_var in $render_vars; do
				declare $render_var
			done
			render_fullpath=$app_snippets_path/${render_path}.yml
			token_value=$(compile_tpl $render_fullpath $2)
			token_value=$(echo "$token_value" | sed 's/\//\\\//g' | tr '\n' '\r')
			tpl_content=$(echo "$tpl_content" | sed "s/$token/$token_value/g" | tr '\r' '\n')
		;;
		*)
			token_name=${token_args[0]}
			prefixed_token_name=${2}_${token_name}
			if [ ! -z ${!prefixed_token_name} ]; then
				normalized_token_name=$prefixed_token_name
			elif [ ! -z ${!token_name} ]; then
				normalized_token_name=$token_name
			else
				echo $token undefined, compiling $1 in $app_env_name
				exit 1
			fi
			token_value=$(echo ${!normalized_token_name} | sed 's/\//\\\//g')
			tpl_content=$(echo "$tpl_content" | sed "s/$token/$token_value/g")
		;;
		esac
	done <<-EOF
		$(echo "$tokens")
	EOF
	echo "$tpl_content"
}

compile_tpls() {
	rm -rf $app_tmp_path/*
	tpl_paths=( $(find $app_deploy_path/{base,$1} -type f -name '*.yml') )
	tpl_names=()
	for tpl_path in ${tpl_paths[@]}; do
		tpl_name=$(basename $tpl_path | sed 's/.yml//')
		tpl_names=(${tpl_names[@]} $tpl_name)
		tpl_pod_port_name=${tpl_name}_port
		if [ ! -z ${!tpl_pod_port_name} ]; then
			tpl_pod_port=:${!tpl_port_name}
		fi
		declare "${tpl_name}_host=$tpl_name$tpl_pod_port"
	done
	for i in ${!tpl_paths[@]}; do
		tpl_path=${tpl_paths[$i]}
		tpl_name=${tpl_names[$i]}
		tpl_tmp_path=$app_apply_path/${tpl_path#$app_cloud_path}
		mkdir -p $(dirname $tpl_tmp_path)
		echo "$(compile_tpl $tpl_path $tpl_name)" >> $tpl_tmp_path
	done
}

compile_statics() {
	cp $user_secret_path $app_apply_path
}

compile_all() {
	compile_tpls $1
	compile_statics $1
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)

	begin Choosing Configuration
	mkdir $user_cloud_path
	configure

	if [ ! -d $repo_path ]; then
		begin Cloning Repository
		git clone git@github.com:chi-rb/chi-cloud.git $repo_tmp_path
		sudo mv $repo_tmp_path $repo_path
		sudo ln -s $repo_cloud_path $cloud_path

		begin Dowloading Images
		mkdir $repo_vm_path
		curl -o $repo_initrd_path $s3_initrd_url
		curl -o $repo_vmlinuz_path $s3_vmlinuz_url
		curl -o $repo_disk_path $s3_disk_url
	fi

	if ! vm_exists; then
		begin Creating Virtual Machine
		tar xJvf $repo_disk_path -C $user_cloud_path
		vm_id=$(gen_id)
		cat <<-XML | sudo tee $user_agent_path >/dev/null
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
			<plist version="1.0">
				<dict>
					<key>Label</key>
					<string>com.cloud</string>
					<key>ProgramArguments</key>
					<array>
						<string>$repo_xhyve_path</string>
						<string>-A</string>
						<string>-U</string>
						<string>$vm_id</string>
						<string>-c</string>
						<string>$vm_cpus</string>
						<string>-m</string>
						<string>$vm_mem</string>
						<string>-s</string>
						<string>0,hostbridge</string>
						<string>-s</string>
						<string>2,virtio-net</string>
						<string>-s</string>
						<string>4,virtio-blk,$user_disk_path</string>
						<string>-f</string>
						<string>kexec,$repo_vmlinuz_path,$repo_initrd_path,root=/dev/vda1 ro</string>
					</array>
					<key>RunAtLoad</key>
					<true/>
				</dict>
			</plist>
		XML
		cloud vm start
		nc -l 1234 > $tmp_conf_path
		. $tmp_conf_path
		cat $tmp_conf_path >> $user_conf_path
		rm $tmp_conf_path
	fi

	if ! host_exists; then
		begin Adding Hostname
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if ! export_exists; then
		begin Sharing Home Folder
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		sudo nfsd update
		vm_exec <<-SSH
			echo "$mac_ip:$exports_home_path\t$HOME\tnfs defaults\t0 0" >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	fi

	begin Authorizing hub.docker.com
	authorize
	cat <<-JSON > $user_auth_path
		{
		  "auths": {
		    "https://index.docker.io/v1/": {
		      "auth": "$(echo "$auth_user:$auth_pass\c" | base64)"
		    }
		  }
		}
	JSON
	cat <<-YML > $user_secret_path
		apiVersion: v1
		kind: Secret
		metadata:
		  name: docker
		  labels:
		    name: docker
		type: kubernetes.io/dockerconfigjson
		data:
		  .dockerconfigjson: $(cat $user_auth_path | base64)
	YML

	complete

;;
uninstall)

	if [ -f $user_agent_path ]; then
		begin Removing Agent
		sudo launchctl unload -w $user_agent_path
		sudo rm $user_agent_path
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Unsharing Home Folder
		escaped_exports_home_path=$(echo $exports_home_path | sed 's/\//\\\//g')
		sudo sed -i '' "/$escaped_exports_home_path/d" $exports_path
		sudo nfsd update
	fi

	if [ -d $user_cloud_path ]; then
		begin Removing Settings
		rm -rf $user_cloud_path
	fi

	if [ -d $repo_path ]; then
		begin Removing Cloud
		sudo rm -rf $repo_path $cloud_path
	fi

	complete

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
update)

	begin Updating Repository
	git -C $repo_path pull
	git checkout $2
	
	complete

;;
vm)

	case $2 in
	start)

		sudo launchctl load -w $user_agent_path

	;;
	stop)

		sudo launchctl unload -w $user_agent_path

	;;
	restart)

		cloud vm stop
		cloud vm start

	;;
	shell)

		vm_ssh

	;;
	exec)

		shift 2
		vm_ssh $@

	;;
	help)

		cat <<-DOC
			Usage: cloud vm <commands> [options]
			Manages virtual machine.

			Available commands:
			  start         Boots virtual machine
			  stop          Halts virtual machine
			  restart       Stops and starts
			  shell         Attachs bash session
			  exec          Executes command
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
app)

	case $2 in
	init)

		if ! app_exists; then
			begin Generating Cloud Folder
			cp -r $repo_app_path $app_cloud_path
			load_app

			begin Setting Application Name
			echo "Enter name: \c"
			read	app_name
			echo "app_name=$app_name\n" >> $app_base_path

			begin Setting Rails Docker Repository
			echo "Enter repo: \c"
			read rails_repo
			echo "rails_repo=$rails_repo:\$app_env\n" >> $app_base_path

			complete
		else
			echo Already exists
		fi

	;;
	open)

		load_app
		open "http://$vm_name:$rails_cluster_port"

	;;
	remove)

		load_app

		begin Removing Cloud Folder
		rm -rf $app_cloud_path

		complete

	;;
	envs)

		case $3 in
		''|list)

			ensure_app
			list=$(ls -1 $app_envs_path)
			if [ -z "$list" ]; then
				echo No environments found
			else
				echo "$list"
			fi

		;;
		add)

			ensure_app
			if app_env_exists $4; then
				echo Environment $4 already exists
			else
				mkdir -p $app_envs_path
				touch $app_env_path
				cloud app envs edit $4
			fi

		;;
		edit)

			ensure_app_env $4
			edit $app_env_path

		;;
		remove)

			ensure_app_env $4
			rm -f $app_env_path

		;;
		help)

			cat <<-DOC
				Usage: cloud app envs <commands> [options]
				Manages app envs.

				Available commands:
				  list          Lists envs
				  add           Adds env
				  edit          Edits env
				  remove        Removes env
				  help          Prints documentation
			DOC

		;;
		*)

			unknown

		;;
		esac

	;;
	build)

		load_app
		compile_tpls build
		kubectl delete --ignore-not-found=true -Rf $app_apply_path
		compile_all build
		kubectl apply -Rf $app_apply_path
		ok

		echo "\nUse \`cloud app log <pod-name>\` to see logs"

	;;
	deploy)

		load_app
		compile_all deploy
		kubectl apply -Rf $app_apply_path

	;;
	undeploy)

		load_app
		kubectl delete --all deployments

	;;
	console)

		load_app
		pod_exec $rails_pod bin/rails c

	;;
	shell)

		load_app
		pod_exec ${3:-$rails_pod} /bin/bash

	;;
	exec)

		load_app
		shift 2
		if [ "$2" = -- ]; then
			name=$1
			shift 2
		else
			if [ "$1" = -- ]; then
				shift
			fi
			name=$rails_pod
		fi
		pod_exec $name $@

	;;
	status)

		load_app
		case $3 in
		'')
			kubectl get pods
		;;
		*)
			kubectl describe pod $(find_pod ${3:-$rails_pod})
		;;
		esac

	;;
	log)

		load_app
		kubectl logs -f $(find_pod ${3:-$rails_pod})

	;;
	help)

		cat <<-DOC
			Usage: cloud app <commands> [options]
			Manages app.

			Available commands:
			  envs          Manages environments
			  build         Builds docker images
			  deploy        Applies one or all deploy ymls
			  undeploy      Unapplies one or all deploy ymls
			  console       Attachs rails console
			  shell         Attachs bash session in pod (rails pod by default)
			  exec          Executes command in pod
			  status        Lists or describes pods (lists pods by default)
			  log           Tails pod logs (rails pod by default)
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  vm            Manages virtual machine
		  app           Manages app
		  help          Prints documentation
	DOC

;;
*)

	unknown

;;
esac
