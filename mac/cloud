#!/bin/sh

tmp_path=/tmp
hosts_path=/etc/hosts
exports_path=/etc/exports
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist

repo_path=/usr/local/cloud
repo_tmp_path=/tmp/chi-cloud
repo_app_path=$repo_path/app
repo_mac_path=$repo_path/mac
repo_cloud_path=$repo_mac_path/cloud
repo_agent_path=$repo_mac_path/$agent_name

user_cloud_path=~/.cloud
user_conf_path=$use_cloud_path/conf
user_agent_path=~/Library/LaunchAgents/$agent_name

app_cloud_path=cloud
app_tmp_path=$app_cloud_path/tmp
app_conf_path=$app_cloud_path/conf
app_envs_path=$app_cloud_path/envs
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy

mp_path=$bin_path/multipass
mp_ver=0.8.0
mp_pkg_url=https://github.com/CanonicalLtd/multipass/releases/download/v$mp_ver/multipass-$mp_ver%2Bmac-Darwin.pkg
mp_pkg_path=$tmp_path/multipass.pkg
mp_uninstall_path=/Library/Application\ Support/com.canonical.multipass/uninstall.sh

cluster_name=cluster
cluster_mem=2G
cluster_cpus=2
cluster_disk=10G

conf_names=(
	mp_ver
	cluster_name
	cluster_mem
	cluster_cpus
	cluster_disk
)
conf_descs=(
	'Multipass version'
	'Cluster name'
	'Cluster machine memory'
	'Cluster machine cpus'
	'Cluster machine disk'
)

ok() {
	if [ "$beginned" = true ]; then
		echo "Ok"
	fi
}

complete() {
	ok
	if [ ! -z $1 ]; then
		echo $1 complete
	fi
	if [ "$beginned" != true ]; then
		echo Nothing to do
	fi
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		mkdir -p $user_cloud_path
		rm -f $user_conf_path
		touch $user_conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $user_conf_path
		done
		configure
	fi
}

mp_current_ver() {
	echo $(multipass version | head -n1 | awk '{ print $2 }' | sed 's/+.*//')
}

cluster_exists() {
	multipass info $cluster_name > /dev/null 2>&1
}

host_exists() {
	sudo grep $cluster_name $hosts_path > /dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep '# Cloud' $exports_path > /dev/null 2>&1
}

mp_exec() {
	multipass exec $cluster_name -- sudo $@
}

kubectl() {
	mp_exec microk8s.kubectl --namespace $app_id $@
}

appctl() {
	mp_exec appctl $@
}

find_pod() {
	echo $(kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	kubectl exec -it $(find_pod $name) -- $@
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]' | sed 's/-//g')
}

cluster_ip() {
	echo $(multipass info $cluster_name | grep IP | awk '{ print $2 }')
}

mac_ip() {
	echo $(cluster_ip) | sed 's/[0-9]*$/1/'
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	app_env_name=${1:-development}
	ensure_app_env $app_env_name
	. $app_conf_path
	. $app_env_path
	app_mount_path=/mnt/$app_id
	app_share_path=$(pwd)
	if [ $app_env_name = development ]; then
		registry_url=$(cluster_ip):32000
	fi
	app_path=$app_mount_path
	app_env=$app_env_name
}

ensure_app() {
	if ! app_exists; then
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	ensure_app
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

process_ymls() {
	yml_paths=$(find cloud/$1 -type f -name '*.yml')
	mkdir -p $app_tmp_path
	rm -rf $app_tmp_path/*
	for yml_path in $yml_paths; do
		yml_tmp_path=$app_tmp_path/${yml_path#$app_cloud_path}
		mkdir -p $(dirname $yml_tmp_path)
		content=$(cat $yml_path)
		var_names=$(grep -o '{{ [a-z_]* }}' $yml_path | sed 's/[{} ]//g' | uniq)
		for var_name in $var_names; do
			if [ -z ${!var_name} ]; then
				echo {{ $var_name }} undefined, processing $yml_path in $app_env_name
				exit 1
			fi
			var_value=$(echo ${!var_name} | sed 's/\//\\\//g')
			content=$(echo "$content" | sed "s/{{ $var_name }}/$var_value/g")
		done
		echo "$content" >> $yml_tmp_path
	done
	echo /mnt/$app_id/$app_tmp_path
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)

	begin Choosing Configuration
	configure

	if [ ! -d $repo_path ]; then
		begin Cloning Repository
		git clone git@github.com:chi-rb/chi-cloud.git $repo_tmp_path
		sudo mv $repo_tmp_path $repo_path
		sudo ln -s $repo_cloud_path $cloud_path
	fi

	if [ ! -f $mp_path ] || [ $mp_ver != $(mp_current_ver) ]; then
		begin Installing Multipass $mp_ver
		if [ -f $mp_path ] && [ ! -z "$(sudo pgrep multipass)" ]; then
			echo Multipass is running, close it and run the script again
			exit 1
		fi
		curl -Lo $mp_pkg_path $mp_pkg_url
		sudo installer -pkg $mp_pkg_path -target /
		rm $mp_pkg_path
	fi

	if ! cluster_exists; then
		begin Creating Cluster
		multipass launch -c $cluster_cpus -m $cluster_mem -d $cluster_disk -n $cluster_name
		mp_exec <<-SSH
			apt-get install -y nfs-common
			snap install microk8s --classic
			cat <<-CONF >> /var/snap/microk8s/current/args/kube-apiserver

			# Enable insecure connections
			--insecure-bind-address=0.0.0.0
			--insecure-port=8080
			CONF
			microk8s.status --wait-ready
			microk8s.enable dns registry
		SSH
	fi

	if ! host_exists; then
		begin Adding Hostname
		echo $(cluster_ip) $cluster_name | sudo tee -a $hosts_path
	fi

	if [ ! -f $user_agent_path ]; then
		begin Installing Agent
		ln -s $repo_agent_path $user_agent_path
		launchctl load -w $user_agent_path
	fi

	complete Installation

;;
uninstall)

	if [ -f $user_agent_path ]; then
		begin Uninstalling Agent
		launchctl unload -w $user_agent_path
		rm $user_agent_path
	fi

	if [ -f $mp_path ]; then
		begin Uninstalling Multipass
		yes | sudo sh "$mp_uninstall_path"
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$cluster_name/d" $hosts_path
	fi

	if export_exists; then
		begin Removing Shared Folder
		sudo sed -i '' '/# Cloud/,$ d' /etc/exports
	fi

	if [ -d $user_cloud_path ]; then
		begin Removing Configuration
		rm -rf $user_cloud_path
	fi

	begin Removing Repository
	sudo rm -rf $repo_path $cloud_path

	complete Uninstallation

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
update)

	begin Updating Repository
	git -C $repo_path pull

;;
cluster)

	case $2 in
	start)

		multipass start $cluster_name

	;;
	stop)
		multipass stop $cluster_name

	;;
	restart)

		cloud stop
		echo
		cloud start

	;;
	clear)

		load_app
		kubectl delete --all pods

	;;
	shell)

		multipass shell $cluster_name

	;;
	status)

		mp_exec top

	;;
	help)

		cat <<-DOC
			Usage: cloud cluster <commands> [options]
			Manages cluster.

			Available commands:
			  start         Boots cluster
			  stop          Halts cluster
			  restart       Stops and starts
			  clear         Deletes all pods
			  shell         Attachs bash session
			  status        Attachs top session
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
app)

	case $2 in
	init)

		if ! app_exists; then
			begin Generating Cloud Folder
			cp -r $repo_app_path $app_cloud_path
			app_id=$(gen_id)
			echo app_id=$app_id >> $app_conf_path
			load_app

			begin Sharing Application
			if ! export_exists; then
				echo '# Cloud' | sudo tee -a $exports_path
			fi
			echo $app_share_path -mapall=$(id -u) | sudo tee -a $exports_path
			sudo nfsd restart
			mp_exec <<-SSH
				echo "$(mac_ip):$app_share_path\t$app_mount_path\tnfs defaults\t0 0" >> /etc/fstab
				mkdir -p $app_mount_path
				mount $app_mount_path
			SSH

			begin Assigning Namespace
			kubectl create namespace $app_id

			complete
		else
			echo Already exists
		fi

	;;
	remove)

		load_app

		begin Removing Namespace
		kubectl delete namespace $app_id

		begin Unsharing Application
		mp_exec <<-SSH
			umount $app_mount_path
			sed -i '/$app_id/d' /etc/fstab
			rmdir $app_mount_path
		SSH
		sudo sed -i '' "/$app_id/d" $exports_path
		sudo nfsd restart

		begin Removing Cloud Folder
		rm -rf $app_cloud_path

		complete

	;;
	envs)

		case $3 in
		''|list)

			ensure_app
			list=$(ls -1 $app_envs_path)
			if [ -z "$list" ]; then
				echo No environments found
			else
				echo "$list"
			fi

		;;
		add)

			ensure_app
			if app_env_exists $4; then
				echo Environment $4 already exists
			else
				mkdir -p $app_envs_path
				touch $app_env_path
				cloud envs edit $4
			fi

		;;
		edit)

			ensure_app_env $4
			edit $app_env_path

		;;
		remove)

			ensure_app_env $4
			rm -f $app_env_path

		;;
		help)

			cat <<-DOC
				Usage: cloud app envs <commands> [options]
				Manages app envs.

				Available commands:
				  list          Lists envs
				  add           Adds env
				  edit          Edits env
				  remove        Removes env
				  help          Prints documentation
			DOC

		;;
		*)

			unknown

		;;
		esac

	;;
	build)

		load_app
		kubectl apply -Rf $(process_ymls build)

	;;
	deploy)

		load_app
		kubectl apply -Rf "$(process_ymls deploy)"

	;;
	undeploy)

		load_app
		echo "$(process_ymls deploy)"

	;;
	console)

		load_app
		pod_exec rails bin/rails c

	;;
	shell)

		load_app
		pod_exec ${3:-rails} /bin/bash

	;;
	status)

		load_app
		case $3 in
		'')
			kubectl get pods
		;;
		*)
			kubectl describe pod $3
		;;
		esac

	;;
	log)

		load_app
		kubectl logs -f $(find_pod ${3:-rails})

	;;
	help)

		cat <<-DOC
			Usage: cloud app <commands> [options]
			Manages app.

			Available commands:
			  envs          Manages environments
			  build         Builds docker images
			  deploy        Applies one or all deploy ymls
			  undeploy      Unapplies one or all deploy ymls
			  console       Attachs rails console
			  shell         Attachs bash session in pod (rails pod by default)
			  status        Lists or describes pods (lists pods by default)
			  log           Tails pod logs (rails pod by default)
			  help          Prints documentation
		DOC

	;;
	*)

		unknown

	;;
	esac

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  cluster       Manages cluster
		  app           Manages app
		  help          Prints documentation
	DOC

;;
*)

	unknown

;;
esac
