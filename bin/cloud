#!/bin/sh

tmp_path=/tmp
hosts_path=/etc/hosts
exports_path=/etc/exports
bin_path=/usr/local/bin
cloud_path=$bin_path/cloud
agent_name=com.cloud.plist

repo_path=/usr/local/cloud
repo_cloud_path=$repo_path/bin/cloud
repo_skel_path=$repo_path/skel
repo_install_path=$repo_path/install
repo_init_path=$repo_install_path/cloud-init.yml
repo_agent_path=$repo_agent_path/$agent_name

user_path=~/.cloud
user_conf_path=$user_path/conf
user_agent_path=~/Library/LaunchAgents/$agent_name

app_path=./cloud
app_conf_path=$app_path/conf
app_envs_path=$app_path/envs
app_build_path=$app_path/build
app_deploy_path=$app_path/deploy

mp_path=$bin_path/multipass
mp_ver=0.8.0
mp_pkg_url=https://github.com/CanonicalLtd/multipass/releases/download/v$mp_ver/multipass-$mp_ver%2Bmac-Darwin.pkg
mp_pkg_path=$tmp_path/multipass.pkg
mp_uninstall_path=/Library/Application\ Support/com.canonical.multipass/uninstall.sh

vm_name=cluster
vm_mem=2G
vm_cpus=2
vm_disk=10G

conf_names=(
	mp_ver
	vm_mem
	vm_cpus
	vm_disk
)
conf_descs=(
	'Multipass version'
	'Virtual machine memory'
	'Virtual machine cpus'
	'Virtual machine disk'
)

ok() {
	if [ "$beginned" = true ]; then
		echo "Ok\n"
	fi
}

complete() {
	ok
	echo $1 complete
	if [ "$beginned" != true ]; then
		echo Nothing to do
	fi
}

begin() {
	ok
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		mkdir -p $user_path
		rm -f $conf_path
		touch $conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $conf_path
		done
		configure
	fi
}

mp_current_ver() {
	echo $(multipass version | head -n1 | awk '{ print $2 }' | sed 's/+.*//')
}

vm_exists() {
	multipass info $vm_name > /dev/null 2>&1
}

host_exists() {
	sudo grep $vm_name $hosts_path > /dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep '# Cloud' $exports_path > /dev/null 2>&1
}

mp_exec() {
	multipass exec $vm_name -- sudo $@
}

kubectl() {
	mp_exec microk8s.kubectl $@
}

appctl() {
	mp_exec appctl $@
}

find_pod() {
	echo $(kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	kubectl exec -it $(find_pod $name) -- $@
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]' | sed 's/-//g')
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	ensure_app
	. $app_conf_path
	app_env_name=${1:-development}
	ensure_app_env $app_env_name
	. $app_env_path
	if [ $app_env_name = development ]; then
		app_mount_path=/mnt/$app_id
		registry_url=localhost:32000
	fi
	app_env=$app_env_name
}

ensure_app() {
	if ! app_exists; then
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

process_ymls() {
	yml_paths=$(find cloud/$1 -type f -name '*.yml')
	for yml_path in $yml_paths; do
		processed_yml=$(cat $yml_path)
		var_names=$(grep -o '{{ [a-z_]* }}' $yml_path | sed 's/[{} ]//g' | uniq)
		for var_name in $var_names; do
			if [ -z ${!var_name} ]; then
				echo {{ $var_name }} undefined, processing $yml_path in $app_env_name
				exit 1
			fi
			var_value=$(echo ${!var_name} | sed 's/\//\\\//g')
			processed_yml=$(echo "$processed_yml" | sed "s/{{ $var_name }}/$var_value/g")
		done
		if [ -z "$output" ]; then
			output=$processed_yml
		else
			output="$output\n---\n$processed_yml"
		fi
	done
	echo "$output"
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
add)

	if ! app_exists; then
		begin Generating Cloud Folder
		cp -r $repo_skel_path $app_path
		app_id=$(gen_id)
		echo app_id=$app_id >> $app_conf_path

		begin Sharing Application
		if ! export_exists; then
			echo '# Cloud' | sudo tee -a $exports_path
		fi
		app_share_path=$(pwd)
		echo $app_share_path -mapall=$(id -u) | sudo tee -a $exports_path
		sudo nfsd restart
	else
		echo Already exists
	fi

;;
remove)

	load_app

	begin Unsharing Application
	sudo sed -i '' "/$app_id/d" $exports_path
	sudo nfsd restart

	begin Removing Cloud Folder
	rm -rf $app_cloud_path

;;
install)

	if [ ! -d $repo_path ]; then
		git clone git@github.com:chi-rb/chi-cloud.git $install_path
		sudo ln -s $repo_cloud_path $cloud_path
	fi

	begin Choosing Configuration
	configure

	if [ ! -f $mp_path ] || [ $mp_ver != $(mp_current_ver) ]; then
		begin Installing Multipass $mp_ver
		if [ -f $mp_path ] && [ ! -z "$(sudo pgrep multipass)" ]; then
			echo Multipass is running, close it and run the script again
			exit 1
		fi
		curl -Lo $mp_pkg_path $mp_pkg_url
		sudo installer -pkg $mp_pkg_path -target /
		rm $mp_pkg_path
	fi

	if ! vm_exists; then
		begin Creating Cluster
		multipass launch -c $vm_cpus -m $vm_mem -d $vm_disk -n $vm_name
		map_ip=$(ifconfig bridge100 inet | grep inet | awk '{ print $2 }')
		mp_exec <<-EXEC
			apt-get install -y nfs-common
			snap install microk8s --classic
			cat <<-EOF >> /var/snap/microk8s/current/args/kube-apiserver

			# Enable insecure connections
			--insecure-bind-address=0.0.0.0
			--insecure-port=8080
			EOF
			microk8s.status --wait-ready
			microk8s.enable dns registry
			cat <<-HOST >> /etc/hosts

				# Host alias
				$mac_ip mac
			HOST
		EXEC
	fi

	if ! host_exists; then
		begin Adding Hostname
		vm_ip=$(multipass info $vm_name | grep IP | awk '{ print $2 }')
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if [ ! -f $vm_agent_path ]; then
		begin Installing Agent
		ln -s $repo_agent_path $user_agent_path
		launchctl load -w $user_agent_path
	fi

	complete Installation

;;
uninstall)

	if [ -f $vm_agent_path ]; then
		begin Uninstalling Agent
		launchctl unload -w $vm_agent_path
		rm $vm_agent_path
	fi

	if [ -f $mp_path ]; then
		begin Uninstalling Multipass
		yes | sudo sh "$mp_uninstall_path"
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Removing Shared Folder
		sudo sed -i '' '/# Cloud/,$ d' /etc/exports
	fi

	if [ -f $user_path ]; then
		begin Removing Configuration
		rm -rf $user_path
	fi

	complete Uninstallation

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
envs)

	ensure_app
	case $2 in
	'')
		list=$(ls -1 $app_envs_path)
		if [ -z "$list" ]; then
			echo No environments found
		else
			echo "$list"
		fi
	;;
	add)
		if app_env_exists $3; then
			echo Environment $3 already exists
		else
			mkdir -p $app_envs_path
			touch $app_env_path
			cloud envs edit $3
		fi
	;;
	edit)
		ensure_app_env $3
		edit $app_env_path
	;;
	remove)
		ensure_app_env $3
		rm -f $app_env_path
	;;
	*)
		unknown
	;;
	esac

;;
start)

	multipass start $vm_name

;;
stop)

	multipass stop $vm_name

;;
restart)

	cloud stop
	echo
	cloud start

;;
build)

	load_app
	echo "$(process_ymls build)"

;;
deploy)

	load_app
	echo "$(process_ymls deploy)"

;;
undeploy)

	load_app
	echo "$(process_ymls deploy)"

;;
clear)

	load_app
	kubectl delete --all pods

;;
status)

	case $2 in
	cluster)
		mp_exec top
	;;
	'')
		kubectl get pods
	;;
	*)
		kubectl describe pod $2
	;;
	esac

;;
shell)

	if [ "$2" = cluster ]; then
		multipass shell $vm_name
	else
		pod_exec ${2:-rails} /bin/bash
	fi

;;
console)

	if [ -z $2 ] || [ "$2" = rails ]; then
		pod_exec rails bin/rails c
	fi

;;
logs)

	kubectl logs -f $(find_pod ${2:-rails})

;;
help)

	cat <<-DOC
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  help          Prints documentation
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  envs          Manages environments
		  start         Boots cluster
		  stop          Halts cluster
		  restart       Stops and starts
		  build         Builds docker images
		  deploy        Applies one or all deploy yamls
		  undeploy      Unapplies one or all deploy yamls
		  clear         Deletes all pods
		  shell         Attachs bash session in pod or cluster (rails pod by default)
		  console       Attachs rails console
		  status        Lists pods, describes pod or runs top in cluster (lists pods by default)
		  logs          Tails pod logs (rails pod by default)
	DOC

;;
*)

	unknown

;;
esac
