#!/bin/sh

# SETTINGS

name=cloud
pid=$$
mac_ver=$(sw_vers -productVersion | cut -d . -f 1)
branch=master
bin_path=/usr/local/bin
xhyve_path=$bin_path/xhyve
wait_count=15
freebsd_url="ftp://ftp.tw.freebsd.org/pub/FreeBSD/releases/amd64/\$(uname -r | cut -d - -f 1-2)/"
github_url=git@github.com:chi-rb/chi-cloud.git
hosts_path=/etc/hosts
nfsd_path=/sbin/nfsd
tcc_path=/Library/Application\ Support/com.apple.TCC/TCC.db
ps1="export PS1=\"\h \w > \""

terminal_path=/System/Applications/Utilities/Terminal.app
terminal_client=com.apple.Terminal

exports_path=/etc/exports
exports_data_path=/System/Volumes/Data
exports_home_path=$HOME
exports_cloud_path=/usr/local/cloud
exports_paths="$exports_home_path $exports_cloud_path"

s3_url=https://chi-rb.s3.amazonaws.com
if [ $branch = dev ]; then
	s3_url+=/dev
fi
s3_ingress_url=$s3_url/system-ingress.tar.gz
s3_userboot_url=$s3_url/userboot.so
s3_disk_url=$s3_url/disk.img.xz

local_path=/usr/local/$name
local_bin_path=$local_path/bin
local_xhyve_path=$local_bin_path/xhyve
local_tmp_path=$local_path/tmp
local_transfers_path=$local_tmp_path/transfers
local_disk_xz_path=$local_tmp_path/disk.img.xz
local_ingress_tar_path=$local_tmp_path/system-ingress.tar.gz
local_ingress_zfs_path=$local_tmp_path/system-ingress
local_ips_path=$local_tmp_path/ips
local_run_path=$local_path/run
local_log_path=$local_run_path/log
local_userboot_path=$local_run_path/userboot.so
local_pid_path=$local_run_path/pid
local_disk_path=$local_run_path/disk.img
local_conf_path=$local_run_path/conf
local_cert_path=$local_run_path/cert.pem
local_lib_path=$local_path/lib
local_ingress_path=$local_lib_path/ingress

fs_jail_path=zroot/jail
fs_data_path=$fs_jail_path/data
fs_base_path=$fs_jail_path/base
fs_skel_path=$fs_jail_path/skel
fs_fstab_path=$fs_jail_path/fstab
fs_repo_path=$fs_jail_path/repo
fs_shared_path=$fs_jail_path/shared

jail_path=/jail
jail_data_path=$jail_path/data
jail_base_path=$jail_path/base
jail_skel_path=$jail_path/skel
jail_fstab_path=$jail_path/fstab
jail_repo_path=$jail_path/repo
jail_shared_path=$jail_path/shared
jail_hosts_path=$jail_base_path/etc/hosts
jail_conf_path=/etc/jail.conf

ingress_shared_path=$jail_shared_path/system
ingress_nginx_path=$ingress_shared_path/nginx
ingress_ssl_path=$ingress_shared_path/ssl
ingress_cert_path=$ingress_ssl_path/fullchain.pem
ingress_hosts_path=$ingress_nginx_path/hosts
ingress_vols='ssl:/ssl nginx:/usr/local/etc/nginx'

server_local_user=root
server_local_ip_range=10
server_local_ext_if=vtnet0
server_local_domain=$name.local
server_local_mem=4G
server_local_cpus=4
server_local_id=8299FDAA-4CC0-4FF2-AE5B-A1E1DEC574D7

net_setting_names=(
	mac_ip
	server_local_ip
)
user_setting_names=(
	server_local_mem
	server_local_cpus
)
user_setting_descs=(
	'Server memory'
	'Server cpus'
)

# HELPERS

complete() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo DONE!
}

error() {
	echo $@ >&2
	kill -10 $pid
	exit 1
}

begin() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "---> $@\n"
	beginned=true
}

correct() {
	local yn
	printf 'Correct (Y/n)? '
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

unknown() {
	if [ ! -z $1 ]; then
		echo "Unknown command \`$1\` \n"
	fi
}

downcase() {
	tr '[:upper:]' '[:lower:]'
}

upcase() {
	tr '[:lower:]' '[:upper:]'
}

underscore() {
	tr '-' '_'
}

dashify() {
	tr '_' '-'
}

fast_ssh_opts() {
	local opts path
	opts=$(cat <<-SH
	-o ConnectTimeout=10
	-o ControlMaster=auto
	-o ControlPersist=600
	-o ControlPath=/tmp/%r@%h
	-o UserKnownHostsFile=/dev/null
	-o StrictHostKeyChecking=no
	SH
	)
	if [ $cloud_context != local ] && [ ! -z "$cloud_ssh_key" ]; then
		echo $opts -i "$cloud_ssh_key"
	else
		echo $opts
	fi
}

fast_ssh() {
	local user host
	user=$1
	host=$2
	shift 2
	ssh -tq \
	$(fast_ssh_opts) \
	$user@$host $@
}

fast_scp() {
	scp \
	$(fast_ssh_opts) \
	-C \
	$@
}

gen_id() {
	echo $(uuidgen | downcase)
}

gen_pass() {
	echo $(uuidgen | sed 's/-//g' | downcase)
}

gen_timestamp() {
	echo $(date +'%Y%m%d%H%M%S')
}

fs_list() {
	server_ssh <<-SSH
		zfs list -Hro name $fs_data_path
	SSH
}

fs_exists() {
	local path
	path=$fs_data_path/$1
	fs_list | grep -q $path
}

fs_read_size() {
	server_ssh <<-SSH
		du -sh $1 | awk '{print \$1}'
	SSH
}

# MAC

mac_ensure_ver() {
	if [ $mac_ver -lt 10 ] || [ $mac_ver -gt 11 ]; then
		error Only macOS supported versions are Catalina and Big Sur
	fi
}

mac_delete_conf() {
	local OPTIND option precmd target_group target_name i name value group
	while getopts ':s' option; do
		case "$option" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		target_group=[$(echo $2 | cut -d '_' -f 1)]
		target_name=$(echo $2 | cut -d '_' -f 2-)
		i=1
		while IFS=' = ' read name value; do
			case $name in
			\[*\])
				group=$name
			;;
			*)
				if [ ! -z $value ] && [ "$group" = $target_group ] && [ "$name" = $target_name ]; then
					$precmd sed -i '' "$i,1d" "$1"
					break
				fi
			esac
			i=$(($i+1))
		done < "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_add_conf() {
	local OPTIND option precmd group name conf
	while getopts ':s:' option; do
		case "$option" in
		s)
			$precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		group=$(echo $2 | cut -d '_' -f 1)
		name=$(echo $2 | cut -d '_' -f 2-)
		if [ -z $3 ]; then
			conf="$name = ${!2}"
		else
			conf="$name = $3"
		fi
		if ! cat "$1" | grep -q "\[$group\]"; then
			echo "\n[$group]" | $precmd tee -a "$1" >/dev/null
		fi
		$precmd sed -i '' $"/\[$group\]/a\\
$conf\\
" "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_ensure_file() {
	mkdir -p "$(dirname "$1")"
	touch "$1"
}

mac_edit_file() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR "$1"
	fi
}

mac_add_line() {
	local OPTIND option precmd
	while getopts ':s' option; do
		case "$option" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		echo "$2" | $precmd tee -a "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_delete_line() {
	local OPTIND option precmd
	while getopts ':s' option; do
		case "$option" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		$precmd sed -i '' "\|$2|d" "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_host_exists() {
	sudo grep -q $server_domain $hosts_path
}

mac_exports_exists() {
	test -f $exports_path && \
	sudo egrep -q "$exports_home_path|$exports_cloud_path" $exports_path
}

mac_ensure_nfsd() {
	sudo $nfsd_path enable
}

mac_update_nfsd() {
	sudo $nfsd_path update
}

mac_authorize_bin() {
	local name
	while :; do
		mac_open_privacy
		name=$(basename $1)
		echo \
		"Please drag the binary into the full disk access tab if $name don't appears," \
		"otherwise check the corresponding box"
		mac_show_file $1
		echo Press enter once done
		read
		if mac_bin_authorized "$@"; then
			break
		fi
	done
}

mac_show_file() {
	osascript -e 'tell application "Finder"' -e activate -e "reveal POSIX file \"$1\"" -e end tell >/dev/null 2>&1
}

mac_open_privacy() {
	open "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles" 
}

mac_bin_authorized() {
	local client result
	if [ ! -z $2 ]; then
		client=$2
	else
		client=$1
	fi
	case $mac_ver in
	10)
		sql="select 0 from access where allowed=true and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\""
	;;
	11)
		sql="select 0 from access where auth_value=2 and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\""
	;;
	esac
	result=$(
		sudo sqlite3 "$tcc_path" "$sql" 2>/dev/null
	)
	if [ $? = 1 ]; then
		return 1
	elif [ "$result" = 0 ]; then
		return 0
	else
		return 1
	fi
}

mac_authorize_terminal() {
	if ! mac_bin_authorized $terminal_path $terminal_client; then
		mac_authorize_bin $terminal_path $terminal_client
		echo Restart terminal and run the script again
		exit
	else
		echo Already authorized
	fi
}

mac_authorize_nfsd() {
	if ! mac_bin_authorized $nfsd_path; then
		mac_authorize_bin $nfsd_path
		mac_ensure_nfsd
	else
		echo Already authorized
	fi
}

mac_authorize_xhyve() {
	if ! mac_bin_authorized $local_xhyve_path; then
		mac_authorize_bin $local_xhyve_path
	else
		echo Already authorized
	fi
}

mac_trust_cert() {
	while ! $(server_ssh test -f $ingress_cert_path); do
		printf .
		sleep $wait_count
	done
	cloud_copy server:$ingress_cert_path $local_cert_path
	sudo security add-trusted-cert \
	-d \
	-r trustRoot \
	-k /Library/Keychains/System.keychain \
	$local_cert_path
}

# XHYVE

xhyve_ensure() {
	if ! xhyve_running; then
		xhyve_start
	fi
}

xhyve_spawn() {
	sudo nohup xhyve \
	-U $server_id \
	-A \
	-c $server_cpus \
	-m $server_mem \
	-s 0,hostbridge \
	-s 2,virtio-net \
	-s 4,virtio-blk,$local_disk_path \
	-f "fbsd,$local_userboot_path,$local_disk_path," \
	&>$local_log_path &
	echo $! > $local_pid_path
}

xhyve_booting() {
	! $(server_ssh pwd >/dev/null 2>&1)
}

xhyve_wait_boot() {
	while xhyve_booting; do
		printf .
		sleep $wait_count
	done
	echo
}

xhyve_start() {
	xhyve_spawn
	xhyve_wait_boot "$@"
}

xhyve_safe_start() {
	if ! xhyve_running; then
		xhyve_start
	else
		echo Already running
	fi
}

xhyve_pid() {
	local pid
	pid=$(cat $local_pid_path)
	pgrep -P $pid
}

xhyve_stop() {
	server_ssh poweroff
	xhyve_wait_pid "$@"
	rm $local_pid_path
}

xhyve_safe_stop() {
	if xhyve_running; then
		xhyve_stop
	else
		echo Not running
	fi
}

xhyve_safe_restart() {
	xhyve_safe_stop
	xhyve_safe_start
}

xhyve_wait_pid() {
	while xhyve_running; do
		printf .
		sleep $wait_count
	done
	echo
}

xhyve_running() {
	if [ -f $local_pid_path ]; then
		ps -p $(xhyve_pid) >/dev/null 2>&1
	else
		return 1
	fi
}

# CLOUD 

cmd_cloud_open() {
	local url
	app_load
	if [ $cloud_context = local ]; then
		url=https://$app_name-$cloud_env.$server_domain
	else
		if [ -z $server_domain ]; then
			url=http://$server_ip
		else
			url=https://$server_domain
		fi
	fi
	open $url
}

cmd_cloud_bin() {
	local abs_path target real_path cmd alt name
	abs_path=$1
	target=$(basename $abs_path)
	if [ -d ./cloud ]; then
		app_load
		shift
		rel_path=bin/$target
		if [ -f $rel_path ]; then
			cmd=$rel_path
		else
			cmd=$target
		fi
		name=$(container_expand_name rails)
		container_exec -c $name $cmd $@
	else
		alt=$(which -a $target | grep -A 1 $abs_path | tail -n 1)
		if [ -z "$alt" ]; then
			error "No alternative found for \`$target\`"
		else
			$alt "$@"
		fi
	fi
}

cmd_cloud_install() {
	begin Cloning Repository
	cloud_clone
	begin Adding Binaries
	cloud_add_bins
	begin Authorizing Terminal
	mac_authorize_terminal
	begin Authorizing NFSD
	mac_authorize_nfsd
	begin Authorizing XHYVE
	mac_authorize_xhyve
}

cmd_cloud_uninstall() {
	begin Deleting Binaries
	cloud_delete_bins
	begin Deleting Cloud
	cloud_delete_repo
}

cmd_cloud_update() {
	local current_path current_branch new_branch
	begin Updating Script
	current_path=$PWD
	cd $local_path
	git pull
	current_branch=$(git branch | cut -d ' ' -f2)
	if [ -z "$2" ]; then
		new_branch=$branch
	else
		new_branch=$2
	fi
	if [ $current_branch != $new_branch ]; then
		git checkout $new_branch
	fi
	cd "$current_path"
}

cmd_cloud_gen_key() {
	gen_pass
}

cmd_cloud_encrypt() {
	cloud_encrypt $@
}

cmd_cloud_decrypt() {
	cloud_decrypt $@
}

cmd_cloud_help() {
	unknown
	cat <<-DOC
		Usage: cloud <command> [options]

		Available commands:
			install       Installs cloud
			uninstall     Uninstalls cloud
			update [tag]  Syncs latest or specific version
			branch        Manages branches
			tunnel        Manages tunnels
			ingress       Manages ingress
			container     Manages containers
			server        Manages servers
			help          Prints documentation
	DOC
}

cloud_encrypt() {
	local input secret
	if [ -z "$@" ]; then
		input="$(cat -)"
	else
		input="$@"
	fi
	cloud_ensure_args "$input"
	secret=$(echo "$input" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -e | sed 's/\\n//')
	echo "ENC($secret)"
}

cloud_decrypt() {
	local input secret
	if [ -z "$@" ]; then
		input="$(cat -)"
	else
		input="$@"
	fi
	cloud_ensure_args "$input"
	secret=$(echo "$input" | sed 's/^ENC(//' | sed 's/)$//')
	echo "$secret" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -d
}

cloud_copy() {
	local source destination
	source=$(cloud_target_normalize $1)
	destination=$(cloud_target_normalize $2)
	fast_scp \
	$source \
	$destination
}

cloud_target_normalize() {
	local host path
	if echo $1 | grep -q :; then
		host=$(echo $1 | cut -d : -f 1)
		path=$(echo $1 | cut -d : -f 2)
		case $host in
		server)
			host=$server_user@$server_ip
		;;
		esac
		echo $host:$path
	else
		echo $1	
	fi
}

cloud_clone() {
	if [ -d $local_path ]; then
		echo Already exists
	else
		sudo mkdir -p $local_path
		sudo chown $USER:admin $local_path
		git clone $github_url --single-branch --branch $branch $local_path
		mkdir -p $local_run_path
		mkdir -p $local_transfers_path
		if [ $? != 0 ]; then
			error "Can't clone repo"
		else
			echo Cloned into $local_path
		fi
	fi
}

cloud_refresh_hosts() {
	if [ $cloud_context = local ]; then
		local namespaces namespace line name env envs
		begin Refreshing Hosts
		line=$(echo $server_ip $server_domain)
		namespaces=$(cat $hosts_path | grep $server_domain | cut -d ' ' -f 3- | sed "s/.$server_domain//g")
		for namespace in $namespaces; do
			name=$(echo $namespace | rev | cut -d - -f 2- | rev)
			env=$(echo $namespace | rev | cut -d - -f 1 | rev)
			if container_list_all_created | grep -q ${name}-${env}-rails; then
				line+=" ${name}-$env.$server_domain"
				if [ $env = development ]; then
					line+=" ${name}-test.$server_domain"
				fi
			fi
		done
		if ! (echo $namespaces | grep -q ${app_name}-$cloud_env); then
			line+=" ${app_name}-$cloud_env.$server_domain"
			if [ $cloud_env = development ]; then
				line+=" ${app_name}-test.$server_domain"
			fi
		fi
		mac_delete_line -s $hosts_path $server_domain
		mac_add_line -s $hosts_path "$line"
	fi
}

cloud_config() {
	cloud_context=${CLOUD_CONTEXT:-local}
	cloud_key=$CLOUD_KEY
	cloud_ssh_key=$CLOUD_SSH_KEY
	if [ -z $CLOUD_ENV ]; then
		if [ -z $RAILS_ENV ]; then
			if [ $cloud_context != local ]; then
				cloud_env=production
			else
				cloud_env=development
			fi
		else
			cloud_env=$RAILS_ENV
		fi
	fi
	cloud_read_ini $local_conf_path
	if [ $cloud_context = local ]; then
		server_user=$server_local_user
		server_ip_range=$server_local_ip_range
		server_ext_if=$server_local_ext_if
		server_domain=$server_local_domain
		server_ip=$server_local_ip
		server_mem=$server_local_mem
		server_cpus=$server_local_cpus
		server_id=$server_local_id
	fi
}

cloud_load() {
	mac_ensure_ver
	cloud_config
	cloud_boot
}

cloud_boot() {
	local context_path
	if [ $cloud_context != local ]; then
		context_path=$PWD/cloud/contexts/$cloud_context
		if [ -f "$context_path" ]; then
			cloud_read_ini "$context_path"
		else
			error Context not found
		fi
		echo "** Executing on context \"$cloud_context\" **\n"
	fi
}

cloud_ensure_args() {
	if [ -z $cloud_key ]; then
		error '$CLOUD_KEY not defined'
	fi
	if [ -z "$1" ]; then
		error 'No arg provided'
	fi
}

cloud_delete_repo() {
	if [ -d $local_path ]; then
		echo $local_path
		sudo rm -rf $local_path
	else
		echo Not found
	fi
}

cloud_get_bin_names() {
	find $local_bin_path -type f -name '[a-z]*' -exec basename {} \;
}

cloud_add_bins() {
	local path bin_name
	for bin_name in $(cloud_get_bin_names); do
		path=$bin_path/$bin_name
		if [ $branch != master ]; then
			path+=-$branch
		fi
		if [ ! -f $path ]; then
			ln -s $local_bin_path/$bin_name $path
			echo $path
		fi
	done
}

cloud_delete_bins() {
	local path bin_name
	if [ -d $local_path ]; then
		for bin_name in $(cloud_get_bin_names); do
			path=$bin_path/$bin_name
			if [ $branch != master ]; then
				path+=-$branch
			fi
			if [ -f $path ]; then
				rm -v $path
			fi
		done
	fi
}

cloud_read_ini() {
	local OPTIND option callback vars var name value group
	while getopts ':c:' option; do
		case $option in
		c)
			callback=$OPTARG
		;;
		esac
	done
	shift $((OPTIND-1))
	vars=()
	while [ ! -z "$1" ]; do
		if [ -f "$1" ]; then
			while IFS=' = ' read name value; do
				case $name in
				\[*\])
					group=$(echo $name | sed 's/\[//' | sed 's/\]//')
					if [ ! -z "$callback" ]; then
						$callback $group
					fi
				;;
				*)
					if [ ! -z "$value" ]; then
						case $value in
						ENC\(*\))
							value=$(cloud_decrypt "$value")
						;;
						esac
						var="${group}_${name}=\"$value\""
						if echo $value | grep -qe '[$]'; then
							vars+=($var)
						else
							eval export "$var"
						fi
					fi
				esac
			done < "$1"
		fi
		shift
	done
	for var in ${vars[@]}; do
		eval export "$var"
	done
}

# APP

app_load() {
	xhyve_ensure
	app_config
	app_ensure_cloud
	app_ensure_env
	app_boot
}

app_config() {
	app_path=$PWD
	app_cloud_path=$app_path/cloud
	app_branch_path=$app_cloud_path/branch
	app_contexts_path=$app_cloud_path/contexts
	app_context_path=$app_contexts_path/$cloud_context
	app_local_path=$app_contexts_path/local
	app_containers_path=$app_cloud_path/containers
	app_envs_path=$app_cloud_path/environments
	app_base_path=$app_envs_path/base
	app_env_path=$app_envs_path/$cloud_env
	app_tmp_path=$app_path/tmp/cloud
	app_jails=()
}

app_ensure_cloud() {
	if ! app_cloud_exists; then
		error No cloud directory found
	fi
}

app_cloud_exists() {
	test -d "$app_cloud_path"
}

app_env_exists() {
	test -f "$app_env_path"
}

app_ensure_env() {
	if ! app_env_exists; then
		error Environment not found
	fi
}

app_boot() {
	local name path
	cloud_read_ini \
	-c app_add_jail \
	"$app_base_path" \
	"$app_env_path"
	app_id=$app_name-$cloud_env
}

app_jail_exists() {
	echo "${app_jails[@]}" | grep -q $1
}

app_add_jail() {
	local short_name long_name
	short_name=$(echo $1 | dashify)
	if [ $short_name != app ] && [ $short_name != server ]; then
		long_name=$(container_expand_name $short_name)
		if ! $(app_jail_exists $long_name); then
			export "${1}_host=$long_name"
			export "${1}_name=$long_name"
			if [ $short_name = rails ]; then
				if [ $cloud_context = local ]; then
					rails_vols="$rails_vols "
					rails_vols+="rails:/rails"
				else
					rails_vols="$rails_vols "
					rails_vols+="rails-tmp:/rails/tmp "
					rails_vols+="rails-log:/rails/log "
					rails_vols+="rails-bundle:/rails/vendor/bundle "
					rails_vols+="rails-node:/rails/node_modules "
					rails_vols+="rails-storage:/rails/storage "
					rails_vols+="rails-assets:/rails/public/assets"
				fi
			fi
			app_jails+=($long_name)
		fi
	fi
}

# BRANCH

cmd_branch_list() {
	local branches branch
	branches=$(branch_list)
	for branch in $branches; do
		printf $branch
		if [ $branch = $(branch_read) ]; then
			printf ' *'
		fi
		echo
	done
}

cmd_branch_checkout() {
	local long_name short_name
	container_stop
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		branch_checkout_one $long_name $short_name $1
	done
	echo $1 > "$app_branch_path"
	container_start
}

cmd_branch_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud branch <command> [options]

		Available commands:
			list          Lists branches
			checkout      Checkouts branch
			help          Prints documentation
	DOC
}

branch_read() {
	if [ -f "$app_branch_path" ]; then
		cat "$app_branch_path"
	else
		echo master
	fi
}

branch_list() {
	cat <<-SH | sort | uniq
		$(
			fs_list |
			grep -o ".*-$app_name-$cloud_env-.*" |
			sed "s/-$app_name-$cloud_env-.*$//"
		)
		$(branch_read)
	SH
}

branch_checkout_one() {
	local active_branch active_fs active_branch_fs new_branch new_branch_fs
	active_branch=$(branch_read)
	active_fs=$fs_data_path/$1
	active_branch_fs=$fs_data_path/${active_branch}-$1
	new_branch=$3
	new_branch_fs=$fs_data_path/${new_branch}-$1
	if [ $active_branch != $new_branch ]; then
		printf "Checking out \"$2\" branch \"$3\" ..."
		server_ssh <<-SSH
			zfs umount -f $active_fs
			zfs rename $active_fs $active_branch_fs
		SSH
		if fs_exists ${new_branch}-$1; then
			server_ssh <<-SSH
				zfs rename $new_branch_fs $active_fs
				zfs mount $active_fs
			SSH
		else
			server_ssh <<-SSH
				zfs snapshot $active_branch_fs@$new_branch
				zfs clone $active_branch_fs@$new_branch $active_fs
			SSH
		fi
		echo DONE!
	else
		echo Already in branch $active_branch
	fi
}

# VOLUME

cmd_volume_list() {
	local name
	for name in $(volume_list); do
		size=$(volume_read_size $name)
		printf "%-20s %-10s\n" $name $size
	done
}

cmd_volume_delete() {
	local short_name long_name
	if [ -z "$1" ]; then
		volume_delete_all
	else
		short_name=$1
		long_name=$app_id/$1
		volume_ensure_instance $1
		volume_ensure_no_dependents $1
		volume_delete_one $long_name $short_name
	fi
}

cmd_volume_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud volume <command> [options]

		Available commands:
			list          Lists volumes
			delete        Deletes volume
			help          Prints documentation
	DOC
}

volume_list() {
	server_ssh <<-SSH
		if [ -d $jail_shared_path ]; then
			ls $jail_shared_path/$app_id
		fi
	SSH
}

volume_exists() {
	volume_list | grep -q $1
}

volume_ensure_instance() {
	if ! volume_exists $1; then
		error Volume $1 not found
	fi
}

volume_read_size() {
	fs_read_size $jail_shared_path/$app_id/$1
}

volume_ensure_no_dependents() {
	local container vols
	for container in $(container_list_created); do
		container=$(container_collapse_name $container)
		vols=$(echo $container | underscore)_vols
		for vol in ${!vols}; do
			if echo $vol | grep -q "^$1:"; then
				error Volume $1 in use by $container
			fi
		done
	done
}

volume_delete_all() {
	local vol
	for vol in $(volume_list); do
		volume_delete_one $app_id/$vol $vol
	done
}

volume_delete_one() {
	printf "Deleting volume \"$2\" ... "
	server_ssh <<-SSH
		zfs destroy $fs_shared_path/$1
	SSH
	echo DONE!
}

# TUNNEL

cmd_tunnel_start() {
	local long_name
	short_name=$1
	long_name=$(container_expand_name $short_name)
	server_ssh <<-SSH
		echo "rdr on $server_ext_if proto tcp from any to ($server_ext_if) port $2 -> $long_name port $2" |
		pfctl -a tunnels -f -
	SSH
	echo "$server_domain:$2 => $short_name:$2"
}

cmd_tunnel_stop() {
	server_ssh <<-SSH
		pfctl -a tunnels -F all >/dev/null 2>&1
	SSH
}

cmd_tunnel_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud tunnel <command> [options]

		Available commands:
			start         Starts tunnel
			stop          Stops tunnel
			help          Prints documentation
	DOC
}

# INGRESS

cmd_ingress_restart() {
	container_restart_one system-ingress ingress
}

cmd_ingress_shell() {
	container_ssh system-ingress
}

cmd_ingress_build() {
	if [ $cloud_context = local ]; then
		image_build_one system-ingress ingress
	else
		error Can only run locally
	fi
}

cmd_ingress_push() {
	image_push_one system-ingress ingress
}

cmd_ingress_export() {
	image_export system-ingress
}

cmd_ingress_log() {
	container_log system-ingress
}

cmd_ingress_deploy() {
	container_create system-ingress ingress system-ingress ingress
}

cmd_ingress_delete() {
	local name
	container_delete_one system-ingress ingress
	for name in nginx ssl; do
		volume_delete_one system/$name $name
	done
}

cmd_ingress_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud ingress <command> [options]

		Available commands:
			restart       Restarts ingress
			shell         Opens shell
			exec          Execs command
			help          Prints documentation
	DOC
}

# IMAGE

cmd_image_list() {
	local long_name short_name size
	for long_name in $(image_list); do
		short_name=$(image_collapse_name $long_name)
		size=$(image_read_size $long_name)
		printf "%-20s %-10s\n" $short_name $size
	done
}

cmd_image_build() {
	local short_name long_name
	if [ $cloud_context = local ]; then
		if [ -z "$1" ]; then
			image_build_all
		else
			short_name=$1
			long_name=$(image_expand_name $short_name)
			image_safe_build_one $long_name $short_name
		fi
	else
		error Can only build images locally
	fi
}

cmd_image_push() {
	local short_name long_name
	if [ -z "$1" ]; then
		image_push_all
	else
		short_name=$1
		long_name=$(image_expand_name $short_name)
		image_safe_push_one $long_name $short_name
	fi
}

cmd_image_delete() {
	local long_name short_name
	if [ -z "$1" ]; then
		image_delete_all
	else
		short_name=$1
		long_name=$(image_expand_name $short_name)
		image_delete_one $long_name $short_name
	fi
}

cmd_image_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud image <command> [options]

		Available commands:
			list          List images
			build         Build images
			delete        Delete images
			help          Prints documentation
	DOC
}

image_read_size() {
	fs_read_size $jail_repo_path/$1
}

image_read_date() {
	server_ssh <<-SSH
		stat -f %Sm $jail_repo_path/$1
	SSH
}

image_expand_name() {
	echo ${app_name}-${1} | dashify
}

image_collapse_name() {
	echo $1 | sed "s/^${app_name}-//"
}

image_list_all() {
	server_ssh <<-SSH
		ls $jail_repo_path
	SSH
}

image_list() {
	image_list_all | grep ^${app_name}-[^\ ]*
}

image_exists() {
	image_list_all | grep -q ^${1}$
}

image_delete_all() {
	local long_name short_name
	for long_name in $(image_list); do
		short_name=$(image_collapse_name $long_name)
		image_delete_one $long_name $short_name
	done
}

image_delete_one() {
	local path
	if image_exists $1; then
		printf "Deleting image \"$2\" ... "
		path=$fs_repo_path/$1
		server_ssh <<-SSH
			zfs destroy -r $path
		SSH
		echo DONE!
	else
		error Image $2 not found
	fi
}

image_build_all() {
	local container_long_name image_short_name image_long_name
	for container_long_name in $(container_list_declared); do
		image_short_name=$(container_collapse_name $container_long_name)
		image_long_name=$(image_expand_name $image_short_name)
		image_safe_build_one $image_long_name $image_short_name
	done
}

image_safe_build_one() {
	local base_var base_short_name base_long_name
	base_var="$2_base"
	base_short_name=${!base_var}
	if [ ! -z $base_short_name ]; then
		base_long_name=$(image_expand_name $base_short_name)
		if ! image_exists $base_long_name; then
			image_safe_build_one $base_long_name $base_short_name
		fi
	fi
	image_build_one $1 $2 $base_long_name $base_short_name
}

image_build_one() {
	local short_name long_name suffixed_name container_path \
	main_process_path build_path requires_name vols_name \
	requires_value vols_value data_path rc_path bin_path \
	main_process_bin_path main_process_rc_path fs_old_path \
	fs_new_path snap_path
	begin Building image \"$2\"
	long_name=$1
	short_name=$2
	suffixed_name=${long_name}--build
	if echo $long_name | grep -q ^system-.*; then
		container_path=$local_lib_path/$short_name
	else
		container_path=$app_containers_path/$short_name
	fi
	main_process_path=$container_path/main_process
	build_path=$container_path/build
	if container_exists $suffixed_name; then
		container_delete_one $suffixed_name $short_name
	fi
	if image_exists $long_name; then
		image_delete_one $long_name $short_name
	fi
	requires_name="${short_name}_requires"
	vols_name="${short_name}_vols"
	requires_value=${!requires_name}
	vols_value=${!vols_name}
	unset $requires_name
	export "$vols_name=mnt"
	container_create $suffixed_name $short_name $3 $4
	if [ -f "$main_process_path" ]; then
		data_path=$jail_data_path/$suffixed_name
		rc_path=$data_path/usr/local/etc/rc.d
		main_process_rc_path=$rc_path/main_process
		bin_path=$data_path/usr/local/bin
		main_process_bin_path=$bin_path/main_process
		server_ssh <<-SSH
			mkdir -p $rc_path
			mkdir -p $bin_path
			cp $local_lib_path/rc.d/main_process $main_process_rc_path
			cp "$main_process_path" $main_process_bin_path
			chmod +x $main_process_rc_path
			chmod +x $main_process_bin_path
		SSH
	fi
	cat <<-SSH | container_ssh $suffixed_name
		pkg install -y screen
		$(cat "$build_path")
	SSH
	if [ $? != 0 ]; then
		container_delete_one $suffixed_name $short_name
		error Build failed
	else
		if [ -f "$main_process_path" ]; then
			cat <<-SSH | container_ssh $suffixed_name
				service main_process enable
			SSH
		fi
		container_stop_one $suffixed_name $short_name
		fs_old_path=$fs_data_path/$suffixed_name
		fs_new_path=$fs_repo_path/$long_name
		snap_path=$fs_new_path@last
		server_ssh <<-SSH
			umount -f $fs_old_path
			zfs rename $fs_old_path $fs_new_path
			if zfs list -H -o name -t snapshot | grep -q $snap_path; then
				zfs destroy $snap_path
			fi
			zfs snapshot $snap_path
			zfs mount $fs_new_path
		SSH
		container_delete_one $suffixed_name $short_name
	fi
	export "$requires_name=$requires_value"
	export "$vols_name=$vols_value"
}

image_push_all() {
	local container_long_name image_short_name image_long_name
	for container_long_name in $(container_list_declared); do
		image_short_name=$(container_collapse_name $container_long_name)
		image_long_name=$(image_expand_name $image_short_name)
		if image_exists $image_long_name; then
			image_push_one $image_long_name $image_short_name
		fi
	done
}

image_safe_push_one() {
	if image_exists $1; then
		image_push_one $@
	else
		error Image not found $2
	fi
}

image_push_one() {
	local tar_name tar_path zfs_path fs_path
	tar_name=$1.tar.gz
	tar_path=$local_transfers_path/$tar_name
	zfs_path=$local_transfers_path/$1
	if [ $cloud_context != local ]; then
		begin Pushing image \"$2\"
		image_export $1
		server_ssh <<-SSH
			mkdir -p $local_transfers_path
			rm -f $tar_path
		SSH
		fast_scp $tar_path $server_user@$server_ip:$tar_path
		if [ $cloud_context != registry ]; then
			fs_path=$fs_repo_path/$1
			server_ssh <<-SSH
				tar -C $local_transfers_path -xvvf $tar_path
				if zfs list -H -o name -t snapshot | grep -q $fs_path; then
					zfs destroy -r $fs_path
				fi
				zfs receive $fs_path < $zfs_path
				rm $zfs_path $tar_path
			SSH
		fi
	else
		error Must be executed remotely
	fi
}

image_pull() {
	local path
	tar_name=$1.tar.gz
	transfer_path=$local_transfers_path/$tar_name
	tar_path=/tmp/$tar_name
	if [ $cloud_context != local ]; then
		if [ -f $path ]; then
			rm $path
		fi
		fast_scp $server_user@$server_ip:$tar_path $transfer_path
	else
		error Must be executed remotely
	fi
}

image_export() {
	local tar_path zfs_path
	zfs_path=$local_transfers_path/$1
	tar_path=$zfs_path.tar.gz
	cat <<-SSH | server_ssh -l
		mkdir -p $local_transfers_path
		rm -f $tar_path
		zfs send $fs_repo_path/$1@last > $zfs_path
		tar -C $local_transfers_path -czvf $tar_path $1
		rm $zfs_path
	SSH
}

# CONTEXT

cmd_context_list() {
	local name line
	for name in $(context_list); do
		line=$name
		if [ $cloud_context = $name ]; then
			line+=" *"
		fi
		echo "$line"
	done
}

cmd_context_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud context <command> [options]

		Available commands:
			list          Lists all names
			help          Prints documentation
	DOC
}

context_list() {
	local list
	list=$(ls "$app_contexts_path")
	if ! (echo "$list" | grep -q local); then
		list+="\nlocal"
	fi
	echo "$list"
}

# CONTAINER

cmd_container_list() {
	local list long_name short_name status
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		if container_running $long_name; then
			status=RUNNING
		else
			status=STOPPED
		fi
		printf "%-20s %-20s\n" $short_name $status
	done
}

cmd_container_exec() {
  local long_name short_name
	short_name=$1
	long_name=$(container_expand_name $short_name)
	if [ -t 0 ]; then
		if [ $# -gt 2 ] && [ "$3" = -- ]; then
			shift 3
		else
			error Wrong format
		fi
	else
		shift 2
	fi
	container_exec -c $long_name $@
}

cmd_container_deploy() {
	local long_name short_name
	if [ -z "$1" ]; then
		container_deploy_all
		cloud_refresh_hosts
	else
		short_name=$1
		long_name=$(container_expand_name $1)
		container_safe_deploy_one $long_name $short_name
		cloud_refresh_hosts
	fi
}

cmd_container_log() {
	local long_name short_name
	short_name=$1
	long_name=$(container_expand_name $short_name)
	container_log $long_name
}

cmd_container_attach() {
	local long_name short_name
	short_name=$1
	long_name=$(container_expand_name $short_name)
	container_ssh $long_name screen -r main_process
}

cmd_container_delete() {
	local long_name short_name
	if [ -z "$1" ]; then
		container_delete_all
	else
		short_name=$1
		long_name=$(container_expand_name $1)
		container_safe_delete_one $long_name $short_name
	fi
}

cmd_container_stop() {
	local long_name short_name
	if [ -z "$1" ]; then
		container_stop_all
	else
		short_name=$1
		long_name=$(container_expand_name $1)
		container_safe_stop_one $long_name $short_name
	fi
}

cmd_container_start() {
	local long_name short_name
	if [ -z "$1" ]; then
		container_start_all
	else
		short_name=$1
		long_name=$(container_expand_name $1)
		container_safe_start_one $long_name $short_name
	fi
}

cmd_container_restart() {
	local long_name short_name
	if [ -z "$1" ]; then
		container_restart_all
	else
		short_name=$1
		long_name=$(container_expand_name $1)
		container_restart_one $long_name $short_name
	fi
}

cmd_container_shell() {
	local long_name short_name
	short_name=$1
	long_name=$(container_expand_name $short_name)
	container_ensure_instance $long_name
	container_ssh -c $long_name
}

cmd_container_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud container <command> [options]

		Available commands:
			status        Displays status
			list          Lists all names
			shell         Opens shell
			exec          Executes command
			tunnel        Tunnels into server
			help          Prints documentation
	DOC
}

container_log() {
	cat <<-SSH | container_ssh $1
		tail -f /var/log/main_process
	SSH
}

container_exec() {
	local OPTIND option change long_name args
	while getopts ':c' option; do
		case $option in
		c)
			change=true
		;;
		esac
	done
	shift $((OPTIND-1))
	long_name=$1
	shift
	container_ensure_instance $long_name
	args="$long_name $@"
	if [ "$change" = true ]; then
		container_ssh -c $args
	else
		container_ssh $args
	fi
}

container_deploy_all() {
	local long_name short_name
	for long_name in $(container_list_declared); do
		short_name=$(container_collapse_name $long_name)
		container_safe_deploy_one $long_name $short_name
	done
}

container_deploy_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_deploy_one $long_name $short_name
	done
}

container_safe_deploy_one() {
	if ! container_exists $1; then
		container_deploy_requires $1 $2
		container_deploy_one $1 $2
	elif ! container_running $1; then
		container_start_requires $1 $2
		container_start_one $1 $2
	fi
}

container_deploy_one() {
	local image_short_name image_long_name
	image_short_name=$2
	image_long_name=$(image_expand_name $2)
	if [ $cloud_context = local ] && ! image_exists $image_long_name; then
		image_safe_build_one $image_long_name $image_short_name
	fi
	begin Deploying container \"$2\"
	container_create $1 $2 $image_long_name $image_short_name
}

container_delete_all() {
	local long_name short_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		container_delete_one $long_name $short_name
	done
}

container_safe_delete_one() {
	container_ensure_instance $1
	container_ensure_no_dependents $1 $2
	container_delete_one $1 $2
}

container_delete_one() {
	local fs_path
	if container_running $1; then
		container_stop_one $1 $2
	fi
	container_delete_ip $1 $2
	printf "Deleting container \"$2\" ... "
	fs_path=$fs_data_path/$1
	if fs_exists $1; then
		server_ssh <<-SSH
			rm $jail_fstab_path/$1
			umount -f $fs_path
			zfs destroy -r $fs_path
		SSH
	fi
	if [ -z "$(container_list_created)" ]; then
		rm -f "$app_branch_path"
	fi
	echo DONE!
}

container_delete_ip() {
	local hosts_paths build name
	hosts_paths="$hosts_path $jail_hosts_path"
	build=$(container_is_build $1 && echo true)
	if [ "$build" != true ] && [ $2 = rails ]; then
		server_ssh <<-SSH
			for path in $hosts_paths; do
				sed -i '' 's/ $app_name-test.cloud.local//' \$path
			done
		SSH
	fi
	server_ssh <<-SSH
		sed -i '' "/$1 { .* }/d" $jail_conf_path
		for path in $hosts_paths; do
			sed -i '' "/.* $1/d" \$path
		done
	SSH
	if [ $2 = rails ]; then
		if [ $cloud_context = local ]; then
			name=$1
		else
			name=rails
		fi
		server_ssh <<-SSH
			sed -i '' "/$name .*/d" $ingress_hosts_path
		SSH
	fi
	if [ "$build" != true ] && [ $1 != system-ingress ]; then
		server_reload_ingress
	fi
}

container_stop_all() {
	local long_name short_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		container_stop_one $long_name $short_name
	done
}

container_safe_stop_one() {
	container_ensure_instance $1
	container_ensure_no_dependents_running $1 $2
	if container_running $1; then
		container_stop_one $1 $2
	else
		echo Already stopped container \"$2\"
	fi
}

container_stop_one() {
	printf "Stopping container \"$2\" ... "
	container_service stop $1
	echo DONE!
}

container_start_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_start_one $long_name $short_name
	done
}

container_start_all() {
	local long_name short_name
	for long_name in $(container_list_created $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_start_one $long_name $short_name
	done
}

container_safe_start_one() {
	container_ensure_instance $1
	if ! container_running $1; then
		container_start_requires $1 $2
		container_start_one $1 $2
	else
		echo Already running container \"$2\"
	fi
}

container_start_one() {
	container_config $1 $2
	printf "Starting container \"$2\" ... "
	container_service start $1
	echo DONE!
}

container_restart_all() {
	local long_name short_name
	for long_name in $(container_list_created $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_restart_one $long_name $short_name
	done
}

container_safe_restart_one() {
	container_ensure_instance $1
	container_restart_one $1 $2
}

container_restart_one() {
	if container_running $1; then
		container_stop_one $1 $2
	fi
	container_start_one $1 $2
}

container_ensure_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		if ! container_running $1; then
			error Container \"$short_name\" requires \"$2\"
		fi
	done
}

container_ensure_no_dependents() {
	local long_name short_name
	for long_name in $(container_list_dependent $1 $2); do
		short_name=$(container_collapse_name $long_name)
		error Container \"$2\" is dependent on \"$short_name\"
	done
}

container_ensure_no_dependents_running() {
	local long_name short_name
	for long_name in $(container_list_dependent $1 $2); do
		short_name=$(container_collapse_name $long_name)
		if container_running $long_name; then
			error Container \"$2\" is dependent on \"$short_name\"
		fi
	done
}

container_create() {
	local build new_path repo_path
	container_assign_ip $1 $2
	build=$(container_is_build $1 && echo true)
	new_path=$fs_data_path/$1
	if [ "$build" = true ] && [ -z "$3" ]; then
		server_ssh <<-SSH
			zfs clone $fs_skel_path@last $new_path
		SSH
	else
		repo_path=$fs_repo_path/$3
		if image_exists $3; then
			server_ssh <<-SSH
				zfs send $repo_path@last | zfs receive $new_path
			SSH
		else
			error Image $4 not found
		fi
	fi
	server_ssh <<-SSH
		zfs destroy $new_path@last
	SSH
	container_config $1 $2
	server_ssh <<-SSH
		jail -c $1
	SSH
	if [ "$build" = true ] && [ -z "$3" ]; then
		server_ssh <<-SSH
			jexec $1 chsh -s /bin/sh
		SSH
	fi
}

container_list_declared() {
	local name
	for name in ${app_jails[@]}; do
		echo $name
	done
}

container_list_all_created() {
	server_ssh <<-SSH
		cat /etc/jail.conf | grep -o ^.*-[^\ ]* | grep -v system-ingress
	SSH
}

container_list_created() {
	server_ssh <<-SSH
		cat /etc/jail.conf | grep -o ^${app_name}-${cloud_env}-[^\ ]* | grep -v '\-\-build$'
	SSH
}

container_list_required() {
	local requires_name requires long_name short_name
	requires_name=$(echo $2 | underscore)_requires
	requires=${!requires_name}
	if [ ! -z "$requires" ]; then
		for short_name in $requires; do
			long_name=$(container_expand_name $short_name)
			echo $long_name
		done
	fi
}

container_list_dependent() {
	local long_name short_name requires_name requires require_short_name require_long_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		requires_name=$(echo $short_name | underscore)_requires
		requires=${!requires_name}
		if [ ! -z "$requires" ]; then
			for require_short_name in $requires; do
				if [ $require_short_name = $2 ]; then
					echo $long_name
				fi
			done
		fi
	done
}

container_exists() {
	container_list_all_created | grep -q ^$1$
}

container_service() {
	local cmd
	cmd="service jail $1"
	if [ ! -z "$2" ]; then
		cmd+=" $2"
	fi
	server_ssh $cmd >/dev/null 2>&1
}

container_ensure_name() {
	if [ -z "$1" ]; then
		error Missing container name
	fi
}

container_ensure_instance() {
	local name
	if ! container_exists $1; then
		name=$(container_collapse_name $1)
		error Container \"$name\" not found
	fi
}

container_ensure_no_instance() {
	local name
	if container_exists $1; then
		name=$(container_collapse_name $1)
		error Container \"$name\" already exists
	fi
}

container_expand_name() {
	echo ${app_name}-${cloud_env}-${1} | dashify
}

container_collapse_name() {
	echo $1 | sed "s/^${app_name}-${cloud_env}-//"
}

container_running() {
	server_ssh jls name | grep -q $1
}

container_config() {
	container_gen_fstab $1 $2
	container_gen_profile $1 $2
}

container_gen_fstab() {
	local fstab_path data_path vols vol_name vol_path rel_path shared_path shared_fs
	fstab_path=$jail_fstab_path/$1
	data_path=$jail_data_path/$1
	server_ssh <<-SSH
		echo $jail_base_path $data_path/base nullfs ro 0 0 > $fstab_path
	SSH
	vols=$(echo $2 | underscore)_vols
	vols=${!vols}
	if [ ! -z "$vols" ]; then
		for vol in $vols; do
			vol_name=$(echo $vol | cut -d ':' -f 1)
			vol_path=$(echo $vol | cut -d ':' -f 2)
			case $1 in
			system-*)
				if [ $vol_name = mnt ]; then
					shared_path=$local_path
					vol_path=$data_path/mnt
				else
					rel_path=/system/$vol_name
					shared_fs=$fs_shared_path$rel_path
					shared_path=$jail_shared_path$rel_path
					vol_path=$data_path$vol_path
				fi
			;;
			*)
				case $vol_name in
				rails)
					shared_path=$app_path
					vol_path=$data_path/rails
				;;
				mnt)
					shared_path=$app_path
					vol_path=$data_path/mnt
				;;
				*)
					rel_path=/$app_name-$cloud_env/$vol_name
					shared_fs=$fs_shared_path$rel_path
					shared_path=$jail_shared_path$rel_path
					vol_path=$data_path$vol_path
				;;
				esac
			;;
			esac
			if [ ! -z "$shared_fs" ] && ! volume_exists $vol_name; then
				server_ssh <<-SSH
					zfs create -p $shared_fs
					if [ -d $vol_path ] && [ ! -z "\$(ls $vol_path)" ]; then
						mv $vol_path/* "$shared_path"
					fi
				SSH
			fi
			server_ssh <<-SSH
				if [ -d "$shared_path" ]; then
					mkdir -p $vol_path
					echo $(echo "$shared_path" | sed 's/ /\\\\040/g') $vol_path nullfs rw 0 0 >> $fstab_path
				fi
			SSH
		done
	fi
}

container_gen_profile() {
	local path prefix skips vars var name value
	path=$jail_data_path/$1/etc/profile
	server_ssh <<-SSH
		rm $path
		echo '$ps1' > $path
	SSH
	prefix=$(echo $2 | underscore)
	skips="name|base|host|port|vols|requires"
	if [ $1 = system-ingress ]; then
		skips+="$skips|hosts_path|nginx_path|shared_path|ssl_path"
	fi
	vars=$(declare | grep "^${prefix}_" | egrep -v "^${prefix}_($skips)=")
	vars+="\r$(declare | egrep "^cloud_(context|env)=")"
	vars+="\r$(declare | egrep "^app_name=")"
	vars+="\r$(declare | egrep "^server_(ip|domain|mail)=")"
	vars=$(echo "$vars" | tr '\r' '\n' | sed '/^$/d')
	while read var; do
		name=$(echo "$var" | cut -d = -f 1 | upcase)
		value=$(echo "$var" | cut -d = -f 2)
		server_ssh <<-SSH
			echo export $name=\"$value\" >> $path
		SSH
	done <<< "$vars"
}

container_jls() {
	server_ssh jls $@
}

container_ssh() {
	local OPTIND option change long_name short_name args cmd cd
	while getopts ':c' option; do
		case $option in
		c)
			change=true
		;;
		esac
	done
	shift $((OPTIND-1))
	long_name=$1
	if [ ! -z "$app_name" ]; then
		short_name=$(container_collapse_name $1)
	fi
	shift
	args=$@
	cmd="server_ssh jexec $long_name su - root"
	cd="cd /rails"
	if [ -z "$args" ]; then
		if [ -t 0 ]; then
			if [ "$change" = true ] && [ "$short_name" = rails ]; then
				$cmd -c \"$cd \&\& sh\"
			else
				$cmd
			fi
		else
			if [ "$change" = true ] && [ "$short_name" = rails ]; then
				cat <<-SSH | $cmd
					$cd
					$(cat -)
				SSH
			else
				$cmd
			fi
		fi
	else
		if [ "$change" = true ] && [ "$short_name" = rails ]; then
			args="$cd && $args"
		fi
		$cmd -c \"$args\"
	fi
}

container_next_ip() {
	local last_ip first_range last_range new_ip
	last_ip=$(server_ssh <<-SSH
		cat $jail_conf_path |
		grep -o 'ip4.addr = [0-9]*\.[0-9]*\.[0-9]*\.[0-9]*' |
		grep -o '[0-9]*\.[0-9]*$' |
		sort -t . -k 1,1n -k 2,2n |
		tail -n1
	SSH
	)
	if [ -z $last_ip ]; then
		first_range=0
		last_range=2
	else
		first_range=$(echo $last_ip | cut -d . -f 1)
		last_range=$(echo $last_ip | cut -d . -f 2)
		if [ $last_range = 255 ]; then
			first_range=$((first_range+1))
			last_range=1
		else
			last_range=$((last_range+1))
		fi
	fi
	echo $server_ip_range.0.$first_range.$last_range
}

container_is_build() {
	echo $1 | grep -q '\-\-build$'
}

container_assign_ip() {
	local ip hosts_paths build name
	ip=$(container_next_ip)
	hosts_paths="$hosts_path $jail_hosts_path"
	build=$(container_is_build $1 && echo true)
	if [ "$build" != true ] && [ $2 = rails ]; then
		server_ssh <<-SSH
			for path in $hosts_paths; do
				sed -i '' 's/ system-ingress/ system-ingress $app_name-test.cloud.local/' \$path
			done
		SSH
	fi
	server_ssh <<-SSH
		for path in $hosts_paths; do
			echo '$ip $1' >> \$path
		done
		echo '$1 { ip4.addr = $ip; }' >> $jail_conf_path
	SSH
	if [ $2 = rails ]; then
		if [ $cloud_context = local ]; then
			name=$1
		else
			name=rails
		fi
		server_ssh <<-SSH
			mkdir -p $ingress_nginx_path
			echo '$name $ip;' >> $ingress_hosts_path
		SSH
	fi
	if [ "$build" != true ] && [ $1 != system-ingress ]; then
		server_reload_ingress
	fi
}

# SERVER

cmd_server_install() {
	if [ $cloud_context = local ]; then
		begin Dowloading Server
		server_download
		begin Configuring Server
		server_config
		begin Creating Disk
		server_create_disk
		begin First Start
		server_first_start
		begin Sharing Directories
		server_share_dirs
	fi
	if [ $cloud_context != local ]; then
		begin Setting Preferences
		server_set_prefs
		begin Initializing Jails
		server_jail_init
	fi
	begin Downloading Ingress
	server_ingress_init
	if [ $cloud_context = local ]; then
		begin Installing Certificates
		mac_trust_cert
	fi
}

cmd_server_uninstall() {
	if [ $cloud_context = local ]; then
		begin Unsharing Directories
		server_unshare_dirs
		begin Stopping Server
		xhyve_stop
		begin Deleting Files
		server_delete_files
		begin Deleting Hostname
		server_delete_host
	else
		error Not implemented yet
	fi
}

cmd_serverconfig() {
	if [ $cloud_context = local ]; then
		server_choose_settings
		echo "\nChanges will take effect on the next restart"
	else
		error Not implemented yet
	fi
}

cmd_server_start() {
	if [ $cloud_context = local ]; then
		xhyve_safe_start
	else
		error Not implemented yet
	fi
}

cmd_server_stop() {
	if [ $cloud_context = local ]; then
		xhyve_safe_stop
	else
		error Not implemented yet
	fi
}

cmd_server_restart() {
	if [ $cloud_context = local ]; then
		xhyve_safe_restart
	else
		error Not implemented yet
	fi
}

cmd_server_shell() {
	xhyve_ensure
	server_ssh
}

cmd_server_exec() {
	xhyve_ensure
	if [ -t 0 ]; then
		if [ $# -gt 1 ] && [ "$1" = -- ]; then
			shift
		else
			error Wrong format
		fi
	fi
	server_ssh $@
}

cmd_server_expand() {
	if [ $cloud_context = local ]; then
		if xhyve_running; then
			begin Stopping server
			xhyve_stop
		fi
		begin Expanding disk
		dd if=/dev/zero bs=1g count=20 >> $local_disk_path
		begin Starting server
		xhyve_start
		begin Expanding filesystem
		server_ssh <<-SSH
			gpart recover vtbd0
			gpart resize -i 2 vtbd0
			zpool online -e zroot vtbd0p2
		SSH
	else
		error Not implemented yet
	fi
}

cmd_server_update() {
	xhyve_ensure
	server_update
}

cmd_server_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud server <command> [options]

		Available commands:
			install       Installs server
			uninstall     Uninstalls server
			start         Starts server
			stop          Stops server
			restart       Stops and starts server
			shell         Opens shell
			exec          Executes command
			update        Updates operating system
			help          Prints documentation
	DOC
}

server_disable_send_ips() {
	server_ssh <<-SSH
		sed -i '' '/send-ips/d' /etc/rc.local
	SSH
}

server_download() {
	if [ ! -f $local_userboot_path ] || [ ! -f $local_disk_path ]; then
		if [ ! -f $local_userboot_path ]; then
			curl -o $local_userboot_path $s3_userboot_url
		fi
		if [ ! -f $local_disk_xz_path ]; then
			curl -o $local_disk_xz_path $s3_disk_url
		fi
	else
		echo Already downloaded
	fi
}

server_create_disk() {
	if [ ! -f $local_disk_path ]; then
		tar xJvf $local_disk_xz_path -C $local_run_path
	else
		echo Disk already created
	fi
}

server_share_dirs() {
	local rel_path abs_path
	if ! mac_exports_exists; then
		if [ ! -f $exports_path ]; then
			sudo touch $exports_path
			chown root:wheel $exports_path
		fi
		for rel_path in $exports_paths; do
			abs_path=$exports_data_path$rel_path
			mac_add_line -s $exports_path "$abs_path -mapall=$(id -u)"
		done
		mac_update_nfsd
		for rel_path in $exports_paths; do
			abs_path=$exports_data_path$rel_path
			server_ssh <<-SSH
				echo '$mac_ip:$abs_path	$rel_path	nfs	rw	0	0' >> /etc/fstab
				mkdir -p $rel_path
				mount $rel_path
			SSH
		done
	else
		echo Already shared
	fi
}

server_config() {
	if [ $cloud_context = local ]; then
		if [ ! -f $local_conf_path ]; then
			mac_ensure_file $local_conf_path
			server_choose_settings
		else
			echo Already initialized
		fi
	fi
}

server_set_prefs() {
	server_ssh <<-SSH
		chsh -s /bin/sh
	SSH
	server_reset_session
	server_ssh <<-SSH
		touch /root/.hushlogin
		echo '$ps1' > /etc/profile
	SSH
}

server_ssh() {
	local OPTIND option local user ip
	while getopts ':l' option; do
		case $option in
		l)
			local=true
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ "$local" = true ]; then
		user=$server_local_user
		ip=$server_local_ip
	else
		user=$server_user
		ip=$server_ip
	fi
	fast_ssh $user $ip $@
}

server_update() {
	server_ssh <<-SSH
		export ASSUME_ALWAYS_YES=yes
		freebsd-update fetch install
		pkg upgrade
	SSH
}

server_jail_init() {
	server_ssh <<-SSH
		for fs in $fs_jail_path $fs_base_path $fs_skel_path $fs_data_path $fs_fstab_path $fs_repo_path $fs_shared_path; do
			zfs create \$fs
		done
		zfs set mountpoint=$jail_path $fs_jail_path

		for name in base lib32; do
			fetch $freebsd_url/\$name.txz -o /tmp
			tar -xf /tmp/\$name.txz -C $jail_base_path
		done
		freebsd-update --not-running-from-cron -b $jail_base_path fetch install
		chflags -R noschg $jail_base_path/var/empty
		for name in dev media mnt net proc root tmp var etc; do
			mv $jail_base_path/\$name $jail_skel_path
		done
		mkdir $jail_base_path/etc
		for name in .cshrc .profile bin boot lib libexec rescue sbin sys; do
			ln -s base/\$name $jail_skel_path
		done
		mkdir -p $jail_skel_path/usr/local
		for name in bin include lib lib32 libdata libexec obj sbin share src tests; do
			ln -s ../base/usr/\$name $jail_skel_path/usr
		done
		for name in resolv.conf localtime; do
			cp /etc/\$name $jail_base_path/etc
		done
		for name in hosts resolv.conf localtime; do
			rm -f $jail_skel_path/etc/\$name
			ln -s ../base/etc/\$name $jail_skel_path/etc
		done
		mkdir $jail_skel_path/base
		touch $jail_skel_path/root/.hushlogin

		mkdir -p /var/log/jail
		cat <<-CONF > $jail_conf_path
			exec.clean;
			exec.consolelog = "/var/log/jail/\\\$name";
			exec.start = '/bin/sh /etc/rc';
			exec.stop = '/bin/sh /etc/rc.shutdown';

			mount.devfs;
			mount.fstab = "$jail_fstab_path/\\\$name";
			path = "$jail_data_path/\\\$name";
			interface = 'lo1';
			host.hostname = "\\\$name";
			allow.raw_sockets = 1;
			allow.sysvipc = 1;

		CONF

		cat <<-CONF | tee $hosts_path $jail_hosts_path
			::1 localhost localhost.my.domain
			127.0.0.1 localhost localhost.my.domain
		CONF

		cat <<-CONF > $jail_skel_path/etc/rc.conf
			sendmail_enable="NONE"
			sshd_enable="YES"
		CONF

		cat <<-CONF >> /etc/pf.conf
			EXT_IF="$ext_if"
			JAIL_NET="$server_ip_range.0.0.0/16"
			INGRESS_IP="$server_ip_range.0.0.2"

			rdr-anchor tunnels
			nat on \\\$EXT_IF from \\\$JAIL_NET to any -> (\\\$EXT_IF)
			rdr pass on \\\$EXT_IF inet proto tcp to port { http, https } -> \\\$INGRESS_IP

			pass out quick all keep state
			pass in quick proto tcp from any to any
		CONF

		cat <<-CONF >> /etc/rc.conf
			jail_enable="YES"
			pf_enable="YES"
			gateway_enable="YES"
			cloned_interfaces="lo1"
			sendmail_enable="NONE"
		CONF

		if ! (cat /etc/rc.conf | grep -q zfs_enable); then
			cat <<-CONF >> /etc/rc.conf
				zfs_enable="YES"
			CONF
		fi

		zfs snapshot $fs_skel_path@last
		service netif start lo1
		service pf start

		mkdir -p $local_transfers_path
	SSH
	server_reset_session
}

server_reset_session() {
	rm -f /tmp/$server_user@$server_ip
}

server_reload_ingress() {
	printf "Reloading ingress ... "
	cat <<-SSH | container_ssh system-ingress
		main_process reload >/dev/null 2>&1
	SSH
	echo DONE!
}

server_ingress_init() {
	if ! image_exists system-ingress; then
		server_ssh <<-SSH
			fetch $s3_ingress_url -o $local_ingress_tar_path
			tar -C $local_tmp_path -xvvf $local_ingress_tar_path
			zfs receive $fs_repo_path/system-ingress < $local_ingress_zfs_path
			rm $local_ingress_tar_path $local_ingress_zfs_path
		SSH
	fi
	if ! container_exists system-ingress; then
		container_create system-ingress ingress system-ingress ingress
	fi
}

server_first_start() {
	local line
	if mac_host_exists; then
		xhyve_ensure
	else
		if xhyve_running; then
			xhyve_stop
		fi
		nc -l 1234 > $local_ips_path &
		sleep 5
		xhyve_spawn
		while [ -z "$(cat $local_ips_path )" ]; do
			printf .
			sleep $wait_count
      if ! xhyve_running; then
        error Xhyve process failed check $local_log_path
      fi
		done
		. $local_ips_path
		server_ip=$server_local_ip
		mac_add_conf $local_conf_path mac_ip
		mac_add_conf $local_conf_path server_local_ip
		rm $local_ips_path
		line="$server_ip $server_domain"
		echo
		mac_add_line -s $hosts_path "$line"
		server_disable_send_ips
	fi
}

server_delete_files() {
	rm -rvf $local_tmp_path/*
	rm -rvf $local_run_path/*
}

server_delete_host() {
	if mac_host_exists; then
		echo $server_domain
		mac_delete_line -s $hosts_path $server_domain
	else
		echo Not found
	fi
}

server_unshare_dirs() {
	local rel_path abs_path
	if mac_exports_exists; then
		for rel_path in $exports_paths; do
			abs_path=$exports_data_path$rel_path
			echo $abs_path
			mac_delete_line -s $exports_path $abs_path 
		done
		mac_update_nfsd
	else
		echo Not shared
	fi
}

server_choose_settings() {
	local indexes i desc value name
	indexes=${!user_setting_names[@]}
	for i in $indexes; do
		desc=${user_setting_descs[$i]}
		value=${!user_setting_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${user_setting_descs[$i]}
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			echo $desc: $value
			if ! correct; then
				printf 'Enter new value: '
				read $name
			fi
			echo
		done
		touch $local_conf_path
		for i in $indexes; do
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			mac_delete_conf $local_conf_path $name
			mac_add_conf $local_conf_path $name $value
		done
		server_choose_settings
	fi
}

trap 'exit' INT TERM
trap 'kill 0' EXIT

cloud_load

case $1 in
bin)
	shift
	cmd_cloud_bin $@
;;
install)
	cmd_cloud_install
	cmd_server_install
	complete
;;
uninstall)
	cmd_server_uninstall
	cmd_cloud_uninstall
	complete
;;
update)
	cmd_cloud_update
;;
open)
	cmd_cloud_open
;;
gen-key)
	cmd_cloud_gen_key
;;
encrypt)
	shift
	cmd_cloud_encrypt $@
;;
decrypt)
	shift
	cmd_cloud_decrypt $@
;;
branch|volume|tunnel|ingress|image|context|container|server)
	group=$1
	cmd=$2
	shift 2
	case $group in
	branch|volume|tunnel|image|context|container)
		app_load
		case $group in
		''|branch)
			case $cmd in
			list)
				cmd_branch_list
			;;
			checkout)
				cmd_branch_checkout $@
			;;
			*)
				cmd_branch_help $cmd
			;;
			esac
		;;
		volume)
			case $cmd in
			''|list)
				cmd_volume_list
			;;
			delete)
				cmd_volume_delete $1
			;;
			*)
				cmd_volume_help $cmd
			;;
			esac
		;;
		tunnel)
			case $cmd in
			stop)
				cmd_tunnel_stop
			;;
			start)
				cmd_tunnel_start $@
			;;
			*)
				cmd_tunnel_help $cmd
			;;
			esac
		;;
		image)
			case $cmd in
			''|list)
				cmd_image_list
			;;
			build)
				cmd_image_build $@
			;;
			push)
				cmd_image_push $@
			;;
			delete)
				cmd_image_delete $@
			;;
			*)
				cmd_image_help $cmd
			;;
			esac
		;;
		context)
			case $cmd in
			''|list)
				cmd_context_list
			;;
			*)
				cmd_context_help $cmd
			esac
		;;
		container)
			case $cmd in
			''|list)
				cmd_container_list
			;;
			log)
				cmd_container_log $@
			;;
			attach)
				cmd_container_attach $@
			;;
			exec)
				cmd_container_exec $@
			;;
			deploy)
				cmd_container_deploy $@
			;;
			delete)
				cmd_container_delete $@
			;;
			stop)
				cmd_container_stop $@
			;;
			start)
				cmd_container_start $@
			;;
			restart)
				cmd_container_restart $@
			;;
			shell)
				cmd_container_shell $@
			;;
			*)
				cmd_container_help $cmd
			;;
			esac
		;;
		esac
	;;
	server)
		case $cmd in
		install)
			cmd_server_install
			complete
		;;
		uninstall)
			cmd_server_uninstall
			complete
		;;
		start)
			cmd_server_start
		;;
		stop)
			cmd_server_stop
		;;
		restart)
			cmd_server_restart
		;;
		shell)
			cmd_server_shell
		;;
		expand)
			cmd_server_expand
		;;
		exec)
			cmd_server_exec $@
		;;
		update)
			cmd_server_update
		;;
		help)
			cmd_server_help
		;;
		*)
			cmd_server_help $cmd
		;;
		esac
	;;
	ingress)
		if [ $cloud_context != local ]; then
			app_load
		fi
		case $cmd in
		restart)
			cmd_ingress_restart
		;;
		shell)
			cmd_ingress_shell
		;;
		log)
			cmd_ingress_log $@
		;;
		exec)
			cmd_ingress_exec $@
		;;
		build)
			cmd_ingress_build
		;;
		push)
			cmd_ingress_push
		;;
		export)
			cmd_ingress_export
		;;
		deploy)
			cmd_ingress_deploy
		;;
		delete)
			cmd_ingress_delete
		;;
		*)
			cmd_ingress_help $cmd
		;;
		esac
	;;
	esac
;;
help)
	cmd_cloud_help
;;
*)
	cmd_cloud_help $1
;;
esac
