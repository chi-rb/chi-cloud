#!/bin/sh

base_url=https://raw.githubusercontent.com/chi-rb/chi-cloud/master/install
tmp_path=/tmp
hosts_path=/etc/hosts
exports_path=/etc/exports
cloud_path=~/.cloud
conf_path=$cloud_path/conf

app_path=$(pwd)
app_cloud_path=cloud
app_conf_path=$app_cloud_path/conf
app_envs_path=$app_cloud_path/envs
app_build_path=$app_cloud_path/build
app_deploy_path=$app_cloud_path/deploy

mp_path=/usr/local/bin/multipass
mp_ver=0.8.0
mp_pkg_url=https://github.com/CanonicalLtd/multipass/releases/download/v$mp_ver/multipass-$mp_ver%2Bmac-Darwin.pkg
mp_pkg_path=$tmp_path/multipass.pkg
mp_uninstall_path=/Library/Application\ Support/com.canonical.multipass/uninstall.sh

vm_name=cluster
vm_mem=2G
vm_cpus=2
vm_disk=10G
vm_init_name=cloud-init.yml
vm_init_path=$tmp_path/$vm_init_name
vm_init_url=$base_url/$vm_init_name
vm_agent_name=com.$vm_name.plist
vm_agent_url=$base_url/$vm_agent_name
vm_agent_path=~/Library/LaunchAgents/$vm_agent_name
vm_agent_tmp_path=$tmp_path/$vm_agent_name

conf_names=(
	vm_mem
	vm_cpus
	vm_disk
	mp_ver
)
conf_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
	'Virtual machine disk'
	'Multipass version'
)

ok() {
	if [ "$beginned" = true ]; then
		echo "Ok\n"
	fi
}

complete() {
	ok
	echo $1 complete
	if [ "$beginned" != true ]; then
		echo Nothing to do
	fi
}

begin() {
	ok
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

configure() {
	indexes=${!conf_names[@]}
	for i in $indexes; do
		desc=${conf_descs[$i]}
		value=${!conf_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${conf_descs[$i]}
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		mkdir -p $cloud_path
		rm -f $conf_path
		touch $conf_path
		for i in $indexes; do
			name=${conf_names[$i]}
			value=${!conf_names[$i]}
			echo $name=$value >> $conf_path
		done
		configure
	fi
}

mp_current_ver() {
	echo $(multipass version | head -n1 | awk '{ print $2 }' | sed 's/+.*//')
}

vm_exists() {
	multipass info $vm_name > /dev/null 2>&1
}

host_exists() {
	sudo grep $vm_name $hosts_path > /dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep '# Cloud' $exports_path > /dev/null 2>&1
}

mp_exec() {
	multipass exec $vm_name -- sudo $@
}

kubectl() {
	mp_exec microk8s.kubectl $@
}

appctl() {
	mp_exec appctl $@
}

find_pod() {
	echo $(kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	kubectl exec -it $(find_pod $name) -- $@
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]' | sed 's/-//g')
}

app_exists() {
	test -d $app_cloud_path
}

load_app() {
	if app_exists; then
		. $app_conf_path
		app_env_name=${1:-development}
		ensure_app_env $app_env_name
		. $app_env_path
		if [ $app_env_name = development ]; then
			app_path=/mnt/$app_id
			registry_url=localhost:32000
		fi
		app_env=$app_env_name
	else
		echo No cloud folder found
		exit 1
	fi
}

unknown() {
	echo Unknown command
}

app_env_exists() {
	if [ ! -z $1 ]; then
		app_env_path=$app_envs_path/$1
		if [ ! -f $app_env_path ]; then
			return 1
		fi
	else
		echo No environment specified
		exit 1
	fi
}

ensure_app_env() {
	if ! app_env_exists $1; then
		echo Environment $1 not exists
		exit 1
	fi
}

process_ymls() {
	yml_paths=$(find cloud/$1 -type f -name '*.yml')
	for yml_path in $yml_paths; do
		processed_yml=$(cat $yml_path)
		var_names=$(grep -o '{{ [a-z_]* }}' $yml_path | sed 's/[{} ]//g' | uniq)
		for var_name in $var_names; do
			if [ -z ${!var_name} ]; then
				echo {{ $var_name }} undefined, processing $yml_path in $app_env_name
				exit 1
			fi
			var_value=$(echo ${!var_name} | sed 's/\//\\\//g')
			processed_yml=$(echo "$processed_yml" | sed "s/{{ $var_name }}/$var_value/g")
		done
		if [ -z "$output" ]; then
			output=$processed_yml
		else
			output="$output\n---\n$processed_yml"
		fi
	done
	echo "$output"
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR $1
	fi
}

if [ -f $conf_path ]; then
	. $conf_path
fi

case $1 in
add)

	if ! app_exists; then
		begin Generating Cloud Folder
		mkdir -p $app_build_path $app_deploy_path
		app_id=$(gen_id)
		echo app_id=$app_id >> $app_conf_path

		begin Sharing Application
		if ! export_exists; then
			echo '# Cloud' | sudo tee -a $exports_path
		fi
		echo $app_path -mapall=$(id -u) | sudo tee -a $exports_path
		sudo nfsd restart
		mp_exec appctl add $app_id $app_path
	else
		echo Already exists
	fi

;;
remove)

	load_app

	begin Unsharing Application
	mp_exec appctl remove $app_id
	sudo sed -i '' "/$app_id/d" $exports_path
	sudo nfsd restart

	begin Removing Cloud Folder
	rm -rf $app_cloud_path

;;
install)

	begin Choosing Configuration
	configure

	if [ ! -f $mp_path ] || [ $mp_ver != $(mp_current_ver) ]; then
		begin Installing Multipass $mp_ver
		if [ -f $mp_path ] && [ ! -z "$(sudo pgrep multipass)" ]; then
			echo Multipass is running, close it and run the script again
			exit
		fi
		curl -Lo $mp_pkg_path $mp_pkg_url
		sudo installer -pkg $mp_pkg_path -target /
		rm $mp_pkg_path
	fi

	if ! vm_exists; then
		begin Creating Cluster
		curl -o $vm_init_path $vm_init_url
		multipass launch -c $vm_cpus -m $vm_mem -d $vm_disk -n $vm_name --cloud-init $vm_init_path
		rm $vm_init_path
		mp_exec appctl install
	fi

	if ! host_exists; then
		begin Adding Hostname
		vm_ip=$(multipass info $vm_name | grep IP | awk '{ print $2 }')
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if [ ! -f $vm_agent_path ]; then
		begin Installing Agent
		curl -o $vm_agent_path $vm_agent_url
		launchctl load -w $vm_agent_path
	fi

	complete Installation

;;
uninstall)

	if [ -f $vm_agent_path ]; then
		begin Uninstalling Agent
		launchctl unload -w $vm_agent_path
		rm $vm_agent_path
	fi

	if [ -f $mp_path ]; then
		begin Uninstalling Multipass
		yes | sudo sh "$mp_uninstall_path"
	fi

	if host_exists; then
		begin Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		begin Removing Shared Folder
		sudo sed -i '' '/# Cloud/,$ d' /etc/exports
	fi

	if [ -f $cloud_path ]; then
		begin Removing Configuration
		rm -rf $cloud_path
	fi

	complete Uninstallation

;;
reinstall)

	cloud uninstall
	echo
	cloud install

;;
envs)

	load_app
	case $2 in
	'')
		list=$(ls -1 $app_envs_path)
		if [ -z "$list" ]; then
			echo No environments found
		else
			echo "$list"
		fi
	;;
	add)
		if env_exists $3; then
			echo Environment $3 already exists
		else
			mkdir -p $app_envs_path
			touch $app_env_path
			cloud envs edit $3
		fi
	;;
	edit)
		ensure_app_env $3
		edit $app_env_path
	;;
	remove)
		ensure_app_env $3
		rm -f $app_env_path
	;;
	*)
		unknown
	;;
	esac

;;
start)

	multipass start $vm_name

;;
stop)

	multipass stop $vm_name

;;
restart)

	cloud stop
	echo
	cloud start

;;
build)

	load_app
	echo "$(process_ymls build)"

;;
deploy)

	load_app
	echo "$(process_ymls deploy)"

;;
undeploy)

	load_app
	echo "$(process_ymls deploy)"

;;
clear)

	load_app
	kubectl delete --all pods

;;
status)

	case $2 in
	cluster)
		mp_exec top
	;;
	'')
		kubectl get pods
	;;
	*)
		kubectl describe pod $2
	;;
	esac

;;
shell)

	if [ "$2" = cluster ]; then
		multipass shell $vm_name
	else
		pod_exec ${2:-rails} /bin/bash
	fi

;;
console)

	if [ -z $2 ] || [ "$2" = rails ]; then
		pod_exec rails bin/rails c
	fi

;;
logs)

	kubectl logs -f $(find_pod ${2:-rails})

;;
help)

	cat <<-EOF
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  help          Prints documentation
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  envs          Manages environments
		  start         Boots cluster
		  stop          Halts cluster
		  restart       Stops and starts
		  build         Builds docker images
		  deploy        Applies one or all deploy yamls
		  undeploy      Unapplies one or all deploy yamls
		  clear         Deletes all pods
		  shell         Attachs bash session in pod or cluster (rails pod by default)
		  console       Attachs rails console
		  status        Lists pods, describes pod or runs top in cluster (lists pods by default)
		  logs          Tails pod logs (rails pod by default)
	EOF

;;
*)

	unknown

;;
esac
