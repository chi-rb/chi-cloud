#!/bin/sh

# SETTINGS

name=cloud
pid=$$
mac_ver=$(sw_vers -productVersion | cut -d . -f 1)
branch=master
bin_path=/usr/local/bin
xhyve_path=$bin_path/xhyve
wait_count=15
freebsd_url="ftp://ftp.tw.freebsd.org/pub/FreeBSD/releases/amd64/\$(uname -r)/"
hosts_path=/etc/hosts
nfsd_path=/sbin/nfsd
tcc_path=/Library/Application\ Support/com.apple.TCC/TCC.db
ps1="export PS1=\"\h \w > \""

terminal_path=/System/Applications/Utilities/Terminal.app
terminal_client=com.apple.Terminal

tmp_path=/tmp/$name
tmp_repo_path=$tmp_path/repo
tmp_base_path=$tmp_path/base
tmp_cloud_path=$tmp_base_path/cloud
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com/freebsd
if [ $branch = dev ]; then
	s3_url+=/dev
fi
s3_userboot_url=$s3_url/userboot.so
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/$name
repo_app_path=$repo_path/app
repo_base_path=$repo_app_path/base
repo_tmp_path=$repo_path/tmp
repo_userboot_path=$repo_tmp_path/userboot.so
repo_disk_path=$repo_tmp_path/disk.img.xz
repo_bin_path=$repo_path/bin
repo_lib_path=$repo_path/lib
repo_xhyve_path=$repo_bin_path/xhyve

user_cloud_path=$HOME/.$name
user_branch_path=$user_cloud_path/branch
user_log_path=$user_cloud_path/log
user_conf_path=$user_cloud_path/conf
user_pid_path=$user_cloud_path/pid
user_disk_path=$user_cloud_path/disk.img
user_ssl_path=$user_cloud_path/ssl
user_cert_path=$user_ssl_path/fullchain.pem

jail_path=/jail
jail_data_path=$jail_path/data
jail_base_path=$jail_path/base
jail_skel_path=$jail_path/skel
jail_fstab_path=$jail_path/fstab
jail_shared_path=$jail_path/shared
jail_hosts_path=$jail_base_path/etc/hosts
jail_conf_path=/etc/jail.conf

ingress_shared_path=$jail_shared_path/system
ingress_nginx_path=$ingress_shared_path/nginx
ingress_ssl_path=$ingress_shared_path/ssl
ingress_hosts_path=$ingress_nginx_path/hosts
system_ingress_vols='ssl:/ssl nginx:/usr/local/etc/nginx'

fs_jail_path=zroot/jail
fs_data_path=$fs_jail_path/data
fs_base_path=$fs_jail_path/base
fs_skel_path=$fs_jail_path/skel
fs_fstab_path=$fs_jail_path/fstab
fs_shared_path=$fs_jail_path/shared

vm_user=root
vm_name=$name.local
vm_host=$vm_name
vm_mem=4G
vm_cpus=4
vm_id=8299FDAA-4CC0-4FF2-AE5B-A1E1DEC574D7

ca_path=/usr/local/share/ca-certificates
ca_cert_path=$ca_path/cloud.crt

net_setting_names=(
	mac_ip
	vm_ip
)
user_setting_names=(
	vm_mem
	vm_cpus
)
user_setting_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

# HELPERS

escape_path() {
	echo $1 | sed 's/\//\\\//g'
}

escape_path2() {
	printf "%q " "$@"
}

complete() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo DONE!
}

error() {
	echo $@ >&2
	kill -10 $pid
	exit 1
}

begin() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "---> $@\n"
	beginned=true
}

correct() {
	local yn
	printf 'Correct (Y/n)? '
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

unknown() {
	if [ ! -z $1 ]; then
		echo "Unknown command \`$1\` \n"
	fi
}

downcase() {
	tr '[:upper:]' '[:lower:]'
}

upcase() {
	tr '[:lower:]' '[:upper:]'
}

fast_ssh_opts() {
	echo \
	-o ConnectTimeout=10 \
	-o ControlMaster=auto \
	-o ControlPersist=600 \
	-o ControlPath=/tmp/%r@%h \
	-o UserKnownHostsFile=/dev/null \
	-o StrictHostKeyChecking=no
}

fast_ssh_cmd() {
	local user host
	user=$1
	host=$2
	shift 2
	echo ssh -tq \
	$(fast_ssh_opts) \
	$user@$host $@
}

fast_scp_cmd() {
	echo scp \
	$(fast_ssh_opts) \
	$@
}

fast_ssh() {
	$(fast_ssh_cmd $@)
}

fast_scp() {
	$(fast_scp_cmd $@)
}

gen_id() {
	echo $(uuidgen | downcase)
}

gen_pass() {
	echo $(uuidgen | sed 's/-//g' | downcase)
}

gen_timestamp() {
	echo $(date +'%Y%m%d%H%M%S')
}

# MAC

mac_delete_conf() {
	local OPTIND o precmd target_group target_name i name value group
	while getopts ':s' o; do
		case "$o" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		target_group=[$(echo $2 | cut -d '_' -f 1)]
		target_name=$(echo $2 | cut -d '_' -f 2-)
		i=1
		while IFS=' = ' read name value; do
			case $name in
			\[*\])
				group=$name
			;;
			*)
				if [ ! -z $value ] && [ "$group" = $target_group ] && [ "$name" = $target_name ]; then
					$precmd sed -i '' "$i,1d" "$1"
					break
				fi
			esac
			i=$(($i+1))
		done < "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_add_conf() {
	local OPTIND o precmd group name conf
	while getopts ':s:' o; do
		case "$o" in
		s)
			$precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		group=$(echo $2 | cut -d '_' -f 1)
		name=$(echo $2 | cut -d '_' -f 2-)
		if [ -z $3 ]; then
			conf="$name = ${!2}"
		else
			conf="$name = $3"
		fi
		if ! cat "$1" | grep -q "\[$group\]"; then
			echo "\n[$group]" | $precmd tee -a "$1" >/dev/null
		fi
		$precmd sed -i '' $"/\[$group\]/a\\
$conf\\
" "$1"
	else
		error "File $1 don't exist"
	fi
}

mac_ensure_file() {
	mkdir -p "$(dirname "$1")"
	touch "$1"
}

mac_edit_file() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR "$1"
	fi
}

mac_delete_line() {
	local OPTIND o precmd path
	while getopts ':s' o; do
		case "$o" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		path=$(escape_path2 $1)
		$precmd sed -i '' /$2/d $path
	else
		error "File $1 don't exist"
	fi
}

mac_host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

mac_export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path >/dev/null 2>&1
}

mac_ensure_nfsd() {
	sudo $nfsd_path enable
	sudo $nfsd_path start
}

mac_update_nfsd() {
	sudo $nfsd_path update
}

mac_add_host_line() {
	echo $@ | sudo tee -a $hosts_path
}

mac_authorize_bin() {
	local name
	while :; do
		mac_open_privacy
		name=$(basename $1)
		echo \
		"Please drag the binary into the full disk access tab if $name don't appears," \
		"otherwise check the corresponding box"
		mac_show_file $1
		echo Press enter once done
		read
		if mac_bin_authorized "$@"; then
			break
		fi
	done
}

mac_show_file() {
	osascript -e 'tell application "Finder"' -e activate -e "reveal POSIX file \"$1\"" -e end tell >/dev/null 2>&1
}

mac_open_privacy() {
	open "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles" 
}

mac_bin_authorized() {
	local client result
	if [ ! -z $2 ]; then
		client=$2
	else
		client=$1
	fi
	case $mac_ver in
	10)
		sql="select 0 from access where allowed=true and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\""
	;;
	11)
		sql="select 0 from access where auth_value=2 and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\""
	;;
	esac
	result=$(
		sudo sqlite3 "$tcc_path" "$sql" 2>/dev/null
	)
	if [ $? = 1 ]; then
		return 1
	elif [ "$result" = 0 ]; then
		return 0
	else
		return 1
	fi
}

mac_authorize_terminal() {
	if ! mac_bin_authorized $terminal_path $terminal_client; then
		mac_authorize_bin $terminal_path $terminal_client
		echo Restart terminal and run the script again
		exit
	else
		echo Already authorized
	fi
}

mac_authorize_nfsd() {
	if ! mac_bin_authorized $nfsd_path; then
		mac_authorize_bin $nfsd_path
		mac_ensure_nfsd
		mac_update_nfsd
	else
		echo Already authorized
	fi
}

mac_authorize_xhyve() {
	if ! mac_bin_authorized $repo_xhyve_path; then
		mac_authorize_bin $repo_xhyve_path
	else
		echo Already authorized
	fi
}

# XHYVE

xhyve_ensure() {
	if ! xhyve_running; then
		xhyve_start
	fi
}

xhyve_spawn() {
	sudo nohup xhyve \
	-U $vm_id \
	-A \
	-c $vm_cpus \
	-m $vm_mem \
	-s 0,hostbridge \
	-s 2,virtio-net \
	-s 4,virtio-blk,$user_disk_path \
	-f "fbsd,$repo_userboot_path,$user_disk_path," \
	&>$user_log_path &
	echo $! > $user_pid_path
}

xhyve_booting() {
	! $(vm_ssh pwd >/dev/null 2>&1)
}

xhyve_wait_boot() {
	while xhyve_booting; do
		printf .
		sleep $wait_count
	done
	echo
}

xhyve_start() {
	xhyve_spawn
	xhyve_wait_boot "$@"
}

xhyve_safe_start() {
	if ! xhyve_running; then
		xhyve_start
	else
		echo Already running
	fi
}

xhyve_pid() {
	local pid
	pid=$(cat $user_pid_path)
	pgrep -P $pid
}

xhyve_stop() {
	vm_ssh poweroff
	xhyve_wait_pid "$@"
	rm $user_pid_path
}

xhyve_safe_stop() {
	if xhyve_running; then
		xhyve_stop
	else
		echo Not running
	fi
}

xhyve_safe_restart() {
	xhyve_safe_stop
	xhyve_safe_start
}

xhyve_wait_pid() {
	while xhyve_running; do
		printf .
		sleep $wait_count
	done
	echo
}

xhyve_running() {
	if [ -f $user_pid_path ]; then
		ps -p $(xhyve_pid) >/dev/null 2>&1
	else
		return 1
	fi
}

# CLOUD 

cmd_cloud_open() {
	local url
	app_load
	if [ $cloud_context = local ]; then
		url=$app_name-$cloud_env.$vm_name
	else
		url=$app_domain
	fi
	open https://$url
}

cmd_cloud_bin() {
	local abs_path target real_path cmd alt name
	abs_path=$1
	target=$(basename $abs_path)
	if [ -d ./cloud ]; then
		app_load
		shift
		cmd=$(echo $cmd)
		rel_path=bin/$target
		if [ -f $rel_path ]; then
			cmd=$rel_path
		else
			cmd=$target
		fi
		name=$(container_expand_name rails)
		container_exec $name /rails/$cmd "$@"
	else
		alt=$(which -a $target | grep -A 1 $abs_path | tail -n 1)
		if [ -z "$alt" ]; then
			error "No alternative found for \`$target\`"
		else
			$alt "$@"
		fi
	fi
}

cmd_cloud_install() {
	cloud_clean_tmp
	begin Cloning Repository
	cloud_clone
	begin Adding Binaries
	cloud_add_bins
	begin Authorizing Terminal
	mac_authorize_terminal
	begin Authorizing NFSD
	mac_authorize_nfsd
	begin Authorizing XHYVE
	mac_authorize_xhyve
}

cmd_cloud_uninstall() {
	begin Deleting Settings
	cloud_delete_settings
	begin Deleting Binaries
	cloud_delete_bins
	begin Deleting Cloud
	cloud_delete_repo
}

cmd_cloud_update() {
	local current_path current_branch new_branch
	begin Updating Script
	current_path=$PWD
	cd $repo_path
	git pull
	current_branch=$(git branch | cut -d ' ' -f2)
	if [ -z "$2" ]; then
		new_branch=$branch
	else
		new_branch=$2
	fi
	if [ $current_branch != $new_branch ]; then
		git checkout $new_branch
	fi
	cd "$current_path"
}

cmd_cloud_gen_key() {
	gen_pass
}

cmd_cloud_encrypt() {
	local secret
	cloud_ensure_args "$@"
	secret=$(echo "$@" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -e | sed 's/\\n//')
	echo "ENC($secret)"
}

cmd_cloud_decrypt() {
	local secret
	cloud_ensure_args "$@"
	secret=$(echo "$@" | sed 's/^ENC(//' | sed 's/)$//')
	echo "$secret" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -d
}

cmd_cloud_help() {
	unknown
	cat <<-DOC
		Usage: cloud <command> [options]

		Available commands:
			install       Installs cloud
			uninstall     Uninstalls cloud
			update [tag]  Syncs latest or specific version
			snapshots     Manages snapshots
			branches      Manages branches
			containers    Manages containers
			vm            Manages virtual machine
			help          Prints documentation
	DOC
}

cloud_copy() {
	local source destination
	source=$(cloud_target_normalize $1)
	destination=$(cloud_target_normalize $2)
	fast_scp \
	$source \
	$destination
}

cloud_target_normalize() {
	local host path
	if echo $1 | grep -q :; then
		host=$(echo $1 | cut -d : -f 1)
		path=$(echo $1 | cut -d : -f 2)
		case $host in
		vm)
			host=$vm_user@$vm_host
		;;
		esac
		echo $host:$path
	else
		echo $1	
	fi
}

cloud_rev() {
	git -C $1 rev-parse HEAD
}

cloud_clean_tmp() {
	rm -rf $tmp_path
	mkdir -p $tmp_path
}

cloud_clone() {
	local current_rev new_rev
	git clone git@github.com:chi-rb/chi-cloud.git --single-branch --branch $branch $tmp_repo_path
	if [ $? == 0 ]; then
		if [ ! -d $repo_path ]; then
			sudo mv $tmp_repo_path $repo_path
		else
			current_rev=$(cloud_rev $repo_path)
			new_rev=$(cloud_rev $tmp_repo_path)
			if [ $current_rev != $new_rev ]; then
				rm -rf $tmp_path
				error "\nSeems you're changing Cloud's version, please run \"cloud uninstall\" first"
			else
				echo Already cloned
			fi
		fi
	else 
		error "Can't clone repo"
	fi
}

cloud_refresh_hosts() {
	if [ $cloud_context = local ]; then
		begin Refreshing Hosts
		local namespaces namespace line name env envs
		line=$(echo $vm_ip $vm_name)
		namespaces=$(cat $hosts_path | grep $vm_name | cut -d ' ' -f 3- | sed "s/.$vm_name//g")
		for namespace in $namespaces; do
			name=$(echo $namespace | rev | cut -d - -f 2- | rev)
			env=$(echo $namespace | rev | cut -d - -f 1 | rev)
			if [ $env = test ] || container_list_all_created | grep -q ${name}-${env}-rails; then
				line+=" ${app_name}-$env.$vm_name"
			fi
		done
		if ! echo $namespaces | grep -q ${app_name}-$cloud_env; then
			line+=" ${app_name}-$env.$vm_name"
			if [ $cloud_env = development ]; then
				line+=" ${app_name}-test.$vm_name"
			fi
		fi
		mac_delete_line -s $hosts_path $vm_name
		mac_add_host_line $line
	fi
}

cloud_load() {
	cloud_key=$CLOUD_KEY
	if [ -z $cloud_context ]; then
		cloud_context=${CLOUD_CONTEXT:-local}
	fi
	if [ -z $cloud_env ]; then
		if [ -z $RAILS_ENV ]; then
			if [ $cloud_context != local ]; then
				cloud_env=production
			else
				cloud_env=development
			fi
		else
			cloud_env=$RAILS_ENV
		fi
	fi
}

cloud_ensure_args() {
	if [ -z $cloud_key ]; then
		error '$CLOUD_KEY not defined'
	fi
	if [ -z "$1" ]; then
		error 'No arg provided'
	fi
}

cloud_delete_settings() {
	if [ -d $user_cloud_path ]; then
		rm -rf $user_cloud_path
	else
		echo Not found
	fi
}

cloud_delete_repo() {
	if [ -d $repo_path ]; then
		sudo rm -rf $repo_path
	else
		echo Not found
	fi
}

cloud_get_bin_names() {
	find $repo_bin_path -type f -name '[a-z]*' -exec basename {} \;
}

cloud_add_bins() {
	local path bin_name
	for bin_name in $(cloud_get_bin_names); do
		path=$bin_path/$bin_name
		if [ $branch != master ]; then
			path+=-$branch
		fi
		if [ ! -f $path ]; then
			ln -s $repo_bin_path/$bin_name $path
		fi
	done
}

cloud_delete_bins() {
	local path bin_name
	if [ -d $repo_path ]; then
		for bin_name in $(cloud_get_bin_names); do
			path=$bin_path/$bin_name
			if [ $branch != master ]; then
				path+=-$branch
			fi
			if [ -f $path ]; then
				rm $path
			fi
		done
	fi
}

cloud_trust_cert() {
	while [ ! -f $user_cert_path ]; do
		printf .
		sleep $wait_count
	done
	sudo security add-trusted-cert \
	-d \
	-r trustRoot \
	-k /Library/Keychains/System.keychain \
	$user_cert_path
}

cloud_read_ini() {
	local o callback path vars var name value group
	while getopts ':c:' o; do
		case $o in
		c)
			callback=$OPTARG
		;;
		esac
	done
	shift $((OPTIND-1))
	vars=()
	for path in $@; do
		while IFS=' = ' read name value; do
			case $name in
			\[*\])
				group=$(echo $name | sed 's/\[//' | sed 's/\]//')
				if [ ! -z "$callback" ]; then
					$callback $group
				fi
			;;
			*)
				if [ ! -z "$value" ]; then
					case $value in
					ENC\(*\))
						value=$(cloud_decrypt "$value")
					;;
					esac
					var="${group}_${name}=\"$value\""
					if echo $value | grep -e '[$]' >/dev/null 2>&1; then
						vars+=($var)
					else
						eval export $var
					fi
				fi
			esac
		done < "$path"
	done
	for var in ${vars[@]}; do
		eval export $var
	done
}

# APP

app_load() {
	xhyve_ensure
	app_config
	app_ensure_cloud
	app_ensure_context
	app_ensure_env
	app_boot
}

app_config() {
	if [ $cloud_context = local ]; then
		app_domain=$vm_name
		app_host=$app_domain
	fi
	if [ ! -z "$CLOUD_PATH" ]; then
		if [ ${CLOUD_PATH:0:1} = / ]; then
			app_cloud_path=$CLOUD_PATH
		else
			app_cloud_path=$PWD/$CLOUD_PATH
		fi
		app_path=$(dirname $app_cloud_path)
	else
		app_path=$PWD
		app_cloud_path=$app_path/cloud
	fi
	app_branch_path=$app_cloud_path/branch
	app_contexts_path=$app_cloud_path/contexts
	app_context_path=$app_contexts_path/$cloud_context
	app_local_path=$app_contexts_path/local
	app_envs_path=$app_cloud_path/environments
	app_base_path=$app_envs_path/base
	app_dev_path=$app_envs_path/development
	app_prod_path=$app_envs_path/production
	app_env_path=$app_envs_path/$cloud_env
	app_tmp_path=$app_path/tmp/cloud
	app_builds_path=$app_cloud_path/builds
	app_jails=()
}

app_ensure_cloud() {
	if ! app_cloud_exists; then
		error No cloud directory found
	fi
}

app_cloud_exists() {
	test -d "$app_cloud_path"
}

app_ensure_context() {
	if ! app_context_exists; then
		error Context not found
	fi
}

app_context_exists() {
	test -f "$app_context_path"
}

app_env_exists() {
	test -f "$app_env_path"
}

app_ensure_env() {
	if ! app_env_exists; then
		error Environment not found
	fi
}

app_boot() {
	local name
	cloud_read_ini \
	-c app_add_jail \
	"$app_context_path" \
	"$app_base_path" \
	"$app_env_path"
	app_id=$app_name-$cloud_env
	if [ $cloud_context = local ]; then
		app_relative_path=/$app_name/$cloud_env
	else
		app_relative_path=/
	fi
}

app_jail_exists() {
	echo "${app_jails[@]}" | grep -q $1
}

app_add_jail() {
	local name
	if [ $1 != app ] && ! $(app_jail_exists $1); then
		name=$(container_expand_name $1)
		export "${1}_host=$name"
		export "${1}_name=$name"
		app_jails+=($name)
	fi
}

# FS

fs_list() {
	node_ssh <<-SSH
		zfs list -Hro name $fs_data_path
	SSH
}

fs_exists() {
	local path
	path=$fs_data_path/$1
	fs_list | grep $path >/dev/null 2>&1
}

# BRANCH

cmd_branch_list() {
	local branches branch
	branches=$(branch_list)
	for branch in $branches; do
		printf $branch
		if [ $branch = $(branch_read) ]; then
			printf ' *'
		fi
		echo
	done
}

cmd_branch_checkout() {
	local long_name short_name
	container_stop
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		branch_checkout_one $long_name $short_name $1
	done
	echo $1 > "$app_branch_path"
	container_start
}

cmd_branch_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud branch <command> [options]

		Available commands:
			list          Lists branches
			checkout      Checkouts branch
			help          Prints documentation
	DOC
}

branch_read() {
	if [ -f "$app_branch_path" ]; then
		cat "$app_branch_path"
	else
		echo master
	fi
}

branch_list() {
	cat <<-SH | sort | uniq
		$(
			fs_list |
			grep -o ".*-$app_name-$cloud_env-.*" |
			sed "s/-$app_name-$cloud_env-.*$//"
		)
		$(branch_read)
	SH
}

branch_checkout_one() {
	local active_branch active_fs active_branch_fs new_branch new_branch_fs
	active_branch=$(branch_read)
	active_fs=$fs_data_path/$1
	active_branch_fs=$fs_data_path/${active_branch}-$1
	new_branch=$3
	new_branch_fs=$fs_data_path/${new_branch}-$1
	if [ $active_branch != $new_branch ]; then
		printf "Checking out \"$2\" branch \"$3\" ..."
		node_ssh <<-SSH
			zfs umount -f $active_fs
			zfs rename $active_fs $active_branch_fs
		SSH
		if fs_exists ${new_branch}-1; then
			node_ssh <<-SSH
				zfs rename $new_branch_fs $active_fs
				zfs mount $active_fs
			SSH
		else
			node_ssh <<-SSH
				zfs snapshot $active_branch_fs@$new_branch
				zfs clone $active_branch_fs@$new_branch $active_fs
			SSH
		fi
		echo DONE!
	else
		echo Already in branch $active_branch
	fi
}

# VOLUME

cmd_volume_list() {
	volume_list
}

cmd_volume_delete() {
	if [ -z "$1" ]; then
		volume_delete_all
	else
		volume_ensure_instance $1
		volume_ensure_no_dependents $1
		volume_delete_one $1
	fi
}

cmd_volume_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud volume <command> [options]

		Available commands:
			list          Lists volumes
			delete        Deletes volume
			help          Prints documentation
	DOC
}

volume_list() {
	cat <<-SSH | vm_ssh
		ls $jail_shared_path/$app_id
	SSH
}

volume_exists() {
	volume_list | grep -q $1
}

volume_ensure_instance() {
	if ! volume_exists $1; then
		error Volume $1 not found
	fi
}

volume_ensure_no_dependents() {
	local container vols
	for container in $(container_list_created); do
		container=$(container_collapse_name $container)
		vols=${container}_vols
		for vol in ${!vols}; do
			if echo $vol | grep -q "^$1:"; then
				error Volume $1 in use by $container
			fi
		done
	done
}

volume_delete_all() {
	local vol
	for vol in $(volume_list); do
		volume_delete_one $vol
	done
}

volume_delete_one() {
	printf "Deleting volume $1 ..."
	cat <<-SSH | vm_ssh
		rm -rf $jail_shared_path/$app_id/$1
	SSH
	echo DONE!
}

# SNAPSHOT

cmd_snapshot_list() {
	local prefix escaped_prefix name creation snapshots snapshot long_name short_name
	prefix=$fs_data_path
	escaped_prefix=$(escape_path $prefix/)
	snapshots=$(node_ssh "zfs list -Hrt snapshot -o name,creation $prefix | sed 's/$escaped_prefix//'")
	while read name creation; do
		snapshot=$(echo $name | cut -d @ -f 2)
		case $snapshot in
		*-snap)
			snapshot=$(echo $snapshot | sed 's/-snap$//')
			long_name=$(echo $name | cut -d @ -f 1)
			short_name=$(container_collapse_name $long_name)
			echo "$short_name@$snapshot\t$creation"
		;;
		esac
	done <<< "$snapshots"
}

cmd_snapshot_create() {
	local suffix snapshot
	if [ -z "$1" ]; then
		echo "Microservice name required"
	else
		if [ -z "$3" ]; then
			suffix=$(gen_timestamp)
		else
			suffix=$3
		fi
		name=$(snapshot_build_name $1 $suffix)
		node_ssh <<-SSH
			zfs snapshot -r $name
		SSH
	fi
}

cmd_snapshot_delete() {
	local name
	name=$(snapshot_build_name $1 $3)
	node_ssh <<-SSH
		zfs destroy $name
	SSH
}

cmd_snapshot_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud snapshot <command> [options]

		Available commands:
			list          Lists snapshot
			create        Creates snapshot
			delete        Deletes snapshot
			help          Prints documentation
	DOC
}

snapshot_exists() {
	snapshot_list $1 | grep $2 >/dev/null 2>&1
}

snapshot_build_name() {
	echo $fs_data_path/$1@$2-snap
}

# TUNNEL

cmd_tunnel_start() {
	node_ssh <<-SSH
		echo "rdr on vtnet0 proto tcp from any to (vtnet0) port $3 -> $1 port $3" |
		pfctl -a tunnels -f -
	SSH
	echo "$vm_host:$3 => $1:$3"
}

cmd_tunnel_stop() {
	node_ssh <<-SSH
		pfctl -a tunnels -F all >/dev/null 2>&1
	SSH
}

cmd_tunnel_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud tunnel <command> [options]

		Available commands:
			start         Starts tunnel
			stop          Stops tunnel
			help          Prints documentation
	DOC
}

# CONTAINER

cmd_container_list() {
	local list long_name short_name state
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		printf "$short_name\t"
		if container_running $short_name; then
			echo 'RUNNING'
		else
			echo 'STOPPED'
		fi
	done
}

cmd_container_exec() {
  local name
	if [ -t 0 ]; then
		if [ $# -gt 2 ] && [ "$3" = -- ]; then
			name=$1
			shift 3
		else
			error Wrong format
		fi
	fi
	container_exec $name $@
}

cmd_container_deploy() {
	container_deploy $1 $2
	cloud_refresh_hosts
}

cmd_container_delete() {
	container_delete $1 $2
}

cmd_container_stop() {
	container_stop $1 $2
}

cmd_container_start() {
	container_start $1 $2
}

cmd_container_restart() {
	container_restart $1 $2
}

cmd_container_export() {
	local suffix path name
	suffix=last
	snapshot_create $1 $suffix
	name=$(snapshot_build_name $1 $suffix)
	path=/tmp/$1-export
	node_ssh <<-SSH
		mkdir -p $path
		zfs send -R $name > $path/zfs
		tar -C $path -czvf $1.tar.gz .
		zfs destroy $name
		rm -rf $path
	SSH
}

cmd_container_restore() {
	local path
	container_delete $1
	container_assign_ip $1
	path=/tmp/$1-restore
	node_ssh <<-SSH
		mkdir -p $path
		tar -C $path -xvvf $3
		zfs receive $fs_data_path/$1 < $path/zfs
		jail -c $1
		rm -rf $path
	SSH
}

cmd_container_shell() {
	container_ensure_instance $1
	container_ssh $1
}

cmd_container_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud container <command> [options]

		Available commands:
			status        Displays status
			list          Lists all names
			shell         Opens shell
			exec          Executes command
			tunnel        Tunnels into vm
			help          Prints documentation
	DOC
}

container_exec() {
	local name
	name=$1
	shift
	container_ensure_instance $name
	container_ssh $name $@
}

container_deploy() {
	if [ -z "$1" ]; then
		container_deploy_all
	else
		container_safe_deploy_one $1 $2
	fi
}

container_deploy_all() {
	local long_name short_name
	for long_name in $(container_list_declared); do
		short_name=$(container_collapse_name $long_name)
		container_safe_deploy_one $long_name $short_name
	done
}

container_deploy_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_deploy_one $long_name $short_name
	done
}

container_safe_deploy_one() {
	if ! container_exists $1; then
		container_deploy_requires $1 $2
		container_deploy_one $1 $2
	elif ! container_running $1; then
		container_start_requires $1 $2
		container_start_one $1 $2
	fi
}

container_deploy_one() {
	local path
	begin Creating container $2
	container_create $1 $2
	path="$app_builds_path/$2"
	cat <<-SSH | container_ssh $1
		$(cat "$path")
	SSH
}

container_delete() {
	if [ -z "$1" ]; then
		container_delete_all
	else
		container_safe_delete_one $1 $2
	fi
}

container_delete_all() {
	local long_name short_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		container_delete_one $long_name $short_name
	done
}

container_safe_delete_one() {
	container_ensure_instance $1
	container_ensure_no_dependents $1 $2
	container_delete_one $1 $2
}

container_delete_one() {
	container_stop_one $1 $2
	printf "Deleting container $2 ..."
	node_ssh <<-SSH
		rm $jail_fstab_path/$1
		rm -f /tmp/root@$1
		umount -f $fs_data_path/$1
		zfs destroy -R $fs_data_path/$1
		sed -i '' "/$1 { .* }/d" $jail_conf_path
		sed -i '' "/.* $1/d" $jail_hosts_path
		sed -i '' "/$1 .*/d" $ingress_hosts_path
		sed -i '' "/.* $1/d" $hosts_path
	SSH
	if [ -z "$(container_list_created)" ]; then
		rm -f "$app_branch_path"
	fi
	echo DONE!
}

container_stop() {
	if [ -z "$1" ]; then
		container_stop_all
	else
		container_safe_stop_one $1 $2
	fi
}

container_stop_all() {
	local long_name short_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		container_stop_one $long_name $short_name
	done
}

container_safe_stop_one() {
	container_ensure_instance $1
	container_ensure_no_dependents_running $1 $2
	if container_running $1; then
		container_stop_one $1 $2
	else
		echo Already stopped container \"$2\"
	fi
}

container_stop_one() {
	printf "Stopping container \"$2\" ... "
	container_service stop $1
	echo DONE!
}

container_start() {
	if [ -z "$1" ]; then
		container_start_all
	else
		container_safe_start_one $1 $2
	fi
}

container_start_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_start_one $long_name $short_name
	done
}

container_start_all() {
	local long_name short_name
	for long_name in $(container_list_created $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_safe_start_one $long_name $short_name
	done
}

container_safe_start_one() {
	container_ensure_instance $1
	if ! container_running $1; then
		container_start_requires $1 $2
		container_start_one $1 $2
	else
		echo Already running container \"$2\"
	fi
}

container_start_one() {
	container_config $1 $2
	printf "Starting container \"$2\" ... "
	container_service start $1
	echo DONE!
}

container_restart() {
	if [ -z "$1" ]; then
		container_restart_all
	else
		container_restart_one $1 $2
	fi
}

container_restart_all() {
	local long_name short_name
	for long_name in $(container_list_created $1 $2); do
		short_name=$(container_collapse_name $long_name)
		container_restart_one $long_name $short_name
	done
}

container_safe_restart_one() {
	container_ensure_instance $1
	container_restart_one $1 $2
}

container_restart_one() {
	if container_running $1; then
		container_stop_one $1 $2
	fi
	container_start_one $1 $2
}

container_ensure_requires() {
	local long_name short_name
	for long_name in $(container_list_required $1 $2); do
		short_name=$(container_collapse_name $long_name)
		if ! container_running $1; then
			error Container \"$short_name\" requires \"$2\"
		fi
	done
}

container_ensure_no_dependents() {
	local long_name short_name
	for long_name in $(container_list_dependent $1 $2); do
		short_name=$(container_collapse_name $long_name)
		error Container \"$2\" is dependent on \"$short_name\"
	done
}

container_ensure_no_dependents_running() {
	local long_name short_name
	for long_name in $(container_list_dependent $1 $2); do
		short_name=$(container_collapse_name $long_name)
		if container_running $long_name; then
			error Container \"$2\" is dependent on \"$short_name\"
		fi
	done
}

container_create() {
	container_assign_ip $1
	node_ssh <<-SSH
		zfs clone $fs_skel_path@last $fs_data_path/$1
	SSH
	container_gen_ssh $1 $2
	container_config $1 $2
	node_ssh <<-SSH
		jail -c $1
		jexec $1 chsh -s /bin/sh
	SSH
}

container_list_declared() {
	local name
	for name in ${app_jails[@]}; do
		echo $name
	done
}

container_list_all_created() {
	node_ssh <<-SSH
		cat /etc/jail.conf | grep -o ^.*-[^\ ]* | grep -v system-ingress
	SSH
}

container_list_created() {
	node_ssh <<-SSH
		cat /etc/jail.conf | grep -o ^${app_name}-${cloud_env}-[^\ ]*
	SSH
}

container_list_required() {
	local requires_name requires long_name short_name
	requires_name=$2_requires
	requires=${!requires_name}
	if [ ! -z "$requires" ]; then
		for short_name in $requires; do
			long_name=$(container_expand_name $short_name)
			echo $long_name
		done
	fi
}

container_list_dependent() {
	local long_name short_name requires_name requires require_short_name require_long_name
	for long_name in $(container_list_created); do
		short_name=$(container_collapse_name $long_name)
		requires_name=${short_name}_requires
		requires=${!requires_name}
		if [ ! -z "$requires" ]; then
			for require_short_name in $requires; do
				if [ $require_short_name = $2 ]; then
					echo $long_name
				fi
			done
		fi
	done
}

container_normalize_args() {
	local name
	if [ ! -z "$1" ]; then
		name=$(container_expand_name $1)
		echo "$name $@"
		shift
	else
		echo $@
	fi
}

container_exists() {
	container_list_created | grep $1 >/dev/null 2>&1
}

container_service() {
	local cmd
	cmd="service jail $1"
	if [ ! -z "$2" ]; then
		cmd+=" $2"
	fi
	node_ssh $cmd >/dev/null 2>&1
}

container_ensure_name() {
	if [ -z "$1" ]; then
		error Missing container name
	fi
}

container_ensure_instance() {
	local name
	if ! container_exists $1; then
		name=$(container_collapse_name $1)
		error Container \"$name\" not found
	fi
}

container_ensure_no_instance() {
	local name
	if container_exists $1; then
		name=$(container_collapse_name $1)
		error Container \"$name\" already exists
	fi
}

container_expand_name() {
	echo ${app_name}-${cloud_env}-${1} | tr _ -
}

container_collapse_name() {
	echo $1 | sed "s/^${app_name}-${cloud_env}-//"
}

container_running() {
	vm_ssh jls name | grep -q $1
}

container_config() {
	container_gen_fstab $1 $2
	container_gen_profile $1 $2
}

container_gen_ssh() {
	local ssh_path
	ssh_path=$jail_data_path/$1/root/.ssh
	node_ssh <<-SSH
		mkdir -p $ssh_path
		ssh-keygen -t rsa -f $ssh_path/id_rsa -q -N ''
	SSH
}

container_gen_fstab() {
	local fstab_path data_path vols vol_name vol_path shared_path
	fstab_path=$jail_fstab_path/$1
	data_path=$jail_data_path/$1
	node_ssh <<-SSH
		echo $jail_base_path $data_path/base nullfs ro 0 0 > $fstab_path
	SSH
	vols=${2}_vols
	for vol in ${!vols}; do
		vol_name=$(echo $vol | cut -d ':' -f 1)
		vol_path=$(echo $vol | cut -d ':' -f 2)
		case $1 in
		system-*)
			shared_path=$jail_shared_path/system/$vol_name
			vol_path=$data_path$vol_path
		;;
		*)
			if [ $vol_name = rails ]; then
				shared_path=$app_path
				vol_path=$data_path/rails
			else
				shared_path=$jail_shared_path/$app_name-$cloud_env/$vol_name
				vol_path=$data_path$vol_path
			fi
		;;
		esac
		node_ssh <<-SSH
			mkdir -p "$shared_path"
			mkdir -p $vol_path 
			echo $shared_path $vol_path nullfs rw 0 0 >> $fstab_path
		SSH
	done
}

container_gen_profile() {
	local path vars var name value
	path=$jail_data_path/$1/etc/profile
	node_ssh <<-SSH
		rm $path
		echo '$ps1' > $path
	SSH
	vars=$(declare | grep "^${2}_" | egrep -v "^${2}_(name|host|port|vols)=")
	vars+="\r$(declare | egrep "^cloud_(context|env)=")"
	vars+="\r$(declare | egrep "^app_(host|domain)=")"
	vars=$(echo "$vars" | tr '\r' '\n' | sed '/^$/d')
	while read var; do
		name=$(echo "$var" | cut -d = -f 1 | upcase)
		value=$(echo "$var" | cut -d = -f 2)
		node_ssh <<-SSH
			echo export $name=\"$value\" >> $path
		SSH
	done <<< "$vars"
}

container_jls() {
	node_ssh jls $@
}

container_ssh() {
	local long_name short_name home_name home_path cmd
	long_name=$1
	shift
	short_name=$(container_collapse_name $long_name)
	home_name=${short_name}_home
	home_path=${!home_name}
	if [ ! -z "$home_path" ] && ([ -t 0 ] && [ ! -z $@ ]); then
		if [ -t 0 ]; then
			cmd=$@
		else
			cmd=$(cat -)
		fi
		cat <<-SSH | node_ssh $(fast_ssh_cmd root $long_name)
			cd $home_path
			$cmd
		SSH
	else
		node_ssh $(fast_ssh_cmd root $long_name $@)
	fi
}

container_next_ip() {
	local last_ip first_range last_range new_ip
	last_ip=$(node_ssh <<-SSH
		cat $jail_conf_path |
		grep -o 'ip4.addr = [0-9]*\.[0-9]*\.[0-9]*\.[0-9]*' |
		grep -o '[0-9]*\.[0-9]*$' |
		sort -t . -k 1,1n -k 2,2n |
		tail -n1
	SSH
	)
	if [ -z $last_ip ]; then
		first_range=0
		last_range=2
	else
		first_range=$(echo $last_ip | cut -d . -f 1)
		last_range=$(echo $last_ip | cut -d . -f 2)
		if [ $last_range = 255 ]; then
			first_range=$((first_range+1))
			last_range=1
		else
			last_range=$((last_range+1))
		fi
	fi
	echo 10.0.$first_range.$last_range
}

container_assign_ip() {
	local ip
	ip=$(container_next_ip)
	node_ssh <<-SSH
		echo '$ip $1' >> $hosts_path
		echo '$ip $1' >> $jail_hosts_path
		mkdir -p $ingress_nginx_path
		echo '$1 $ip;' >> $ingress_hosts_path
		echo '$1 { ip4.addr = $ip; }' >> $jail_conf_path
	SSH
}

# NODE

node_host() {
	if [ $cloud_context = local ]; then
		echo $vm_host
	else
		error Not implemented yet
	fi
}

node_ssh() {
	local host
	host=$(node_host)
	fast_ssh root $host $@
}

node_update() {
	node_ssh <<-SSH
		export ASSUME_ALWAYS_YES=yes
		freebsd-update fetch install
		pkg upgrade
	SSH
}

node_jail_init() {
	local ext_if host
	if [ $cloud_context = local ]; then
		ext_if=vtnet0
	fi
	node_ssh <<-SSH
		zfs create $fs_jail_path
		zfs create $fs_base_path
		zfs create $fs_skel_path
		zfs create $fs_data_path
		zfs create $fs_fstab_path
		zfs create $fs_shared_path

		for name in base lib32; do
			fetch $freebsd_url/\$name.txz -o /tmp
			tar -xf /tmp/\$name.txz -C $jail_base_path
		done
		for name in resolv.conf localtime; do
			cp /etc/\$name $jail_base_path/etc
		done
		freebsd-update --not-running-from-cron -b $jail_base_path fetch install
		chflags -R noschg $jail_base_path/var/empty
		for name in dev media mnt net proc root tmp var etc; do
			mv $jail_base_path/\$name $jail_skel_path
		done
		for name in .cshrc .profile bin boot lib libexec rescue sbin sys; do
			ln -s base/\$name $jail_skel_path
		done
		mkdir -p $jail_skel_path/usr/local
		for name in bin include lib lib32 libdata libexec obj sbin share src tests; do
			ln -s ../base/usr/\$name $jail_skel_path/usr
		done
		rm $jail_skel_path/etc/hosts
		ln -s ../base/etc/hosts $jail_skel_path/etc
		mkdir $jail_skel_path/base

		mkdir -p $jail_base_path/etc/ssh
		mv $jail_skel_path/etc/ssh/sshd_config $jail_base_path/etc/ssh
		ln -s ../../base/etc/ssh/sshd_config $jail_skel_path/etc/ssh
		sed -i '' 's/#PermitRootLogin.*/PermitRootLogin yes/' $jail_base_path/etc/ssh/sshd_config
		sed -i '' 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' $jail_base_path/etc/ssh/sshd_config
		sed -i '' 's/AuthorizedKeysFile.*/AuthorizedKeysFile .ssh\/authorized_keys \/etc\/ssh\/authorized_keys/' $jail_base_path/etc/ssh/sshd_config

		ssh-keygen -t rsa -f ~/.ssh/id_rsa -q -N ''
		cat ~/.ssh/id_rsa.pub > $jail_base_path/etc/ssh/authorized_keys
		ln -s ../../base/etc/ssh/authorized_keys $jail_skel_path/etc/ssh

		touch /root/.hushlogin
		touch $jail_skel_path/root/.hushlogin

		cat <<-CONF > /etc/profile
			$ps1
		CONF

		mkdir -p /var/log/jail
		cat <<-CONF > $jail_conf_path
			exec.clean;
			exec.consolelog = "/var/log/jail/\\\$name";
			exec.start = '/bin/sh /etc/rc';
			exec.stop = '/bin/sh /etc/rc.shutdown';

			mount.devfs;
			mount.fstab = "$jail_fstab_path/\\\$name";
			path = "$jail_data_path/\\\$name";
			interface = 'lo1';
			host.hostname = "\\\$name";
			allow.raw_sockets = 1;
			allow.sysvipc = 1;

		CONF

		cat <<-CONF | tee $hosts_path $jail_hosts_path
			::1 localhost localhost.my.domain
			127.0.0.1 localhost localhost.my.domain
		CONF

		cat <<-CONF > $jail_skel_path/etc/rc.conf
			sendmail_enable="NONE"
			sshd_enable="YES"
		CONF

		cat <<-CONF >> /etc/pf.conf
			# Jails
			EXT_IF="$ext_if"
			JAIL_NET="10.0.0.0/16"
			INGRESS_IP="10.0.0.2"
			MAC_IP="$mac_ip"

			rdr-anchor tunnels

			nat on \\\$EXT_IF from \\\$JAIL_NET to any -> (\\\$EXT_IF)

			rdr pass on \\\$EXT_IF inet proto tcp to port { http, https } -> \\\$INGRESS_IP

			pass out quick all keep state
			pass in quick proto tcp from any to any
		CONF

		cat <<-CONF >> /etc/rc.conf
			# Jails
			zfs_enable="YES"
			jail_enable="YES"
			pf_enable="YES"
			gateway_enable="YES"
			cloned_interfaces="lo1"
			sendmail_enable="NONE"
		CONF

		zfs snapshot $fs_skel_path@last
		service netif start lo1
		service pf restart
		chsh -s /bin/sh
	SSH
	host=$(node_host)
	rm /tmp/root@$host
}

node_ingress_init() {
	local data_path etc_path nginx_path rc_path target
	data_path=$jail_data_path/system-ingress
	etc_path=$data_path/usr/local/etc
	nginx_path=$etc_path/nginx
	rc_path=$etc_path/rc.d
	mkdir -p $user_ssl_path
	cat <<-SSH | vm_ssh
		mkdir -p $ingress_shared_path
		ln -s $user_ssl_path $ingress_ssl_path
	SSH
	container_create system-ingress system_ingress
	cat <<-SSH | container_ssh system-ingress
  	pkg install -y \
		nginx \
		py37-certbot \
		py37-certbot-nginx \
		py37-certbot-dns-cloudflare
		touch /usr/local/etc/nginx/hosts
	SSH
	for target in proxy.conf nginx.conf hosts.map; do
		cloud_copy $repo_lib_path/$target vm:$nginx_path
	done
	cloud_copy $repo_lib_path/nginx-ssl vm:$rc_path
	cat <<-SSH | container_ssh system-ingress
		service nginx-ssl enable
		service nginx-ssl start
	SSH
}

# VM

cmd_vm_install() {
	begin Dowloading Images
	vm_download
	begin Initializing Virtual Machine
	vm_init
	begin Creating Disk
	vm_create_disk
	begin First Start
	vm_first_start
	begin Sharing Home Directory
	vm_share_home
	begin Initializing Jails
	node_jail_init
	begin Initializing Ingress
	node_ingress_init
	begin Installing Certificates
	cloud_trust_cert
}

cmd_vm_uninstall() {
	begin Stopping Virtual Machine
	xhyve_safe_stop
	begin Deleting Files
	vm_delete_files
	begin Deleting Hostname
	vm_delete_host
	begin Unsharing Home Directory
	vm_unshare_home
}

cmd_vm_config() {
	vm_choose_settings
	echo "\nChanges will take effect on the next restart"
}

cmd_vm_start() {
	xhyve_safe_start
}

cmd_vm_stop() {
	xhyve_safe_stop
}

cmd_vm_restart() {
	xhyve_safe_restart
}

cmd_vm_shell() {
	xhyve_ensure
	vm_ssh
}

cmd_vm_exec() {
	xhyve_ensure
	if [ -t 0 ]; then
		if [ $# -gt 1 ] && [ "$1" = -- ]; then
			shift
		else
			error Wrong format
		fi
	fi
	vm_ssh $@
}

cmd_vm_update() {
	xhyve_ensure
	node_update
}

cmd_vm_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud vm <command> [options]

		Available commands:
			install       Installs virtual machine
			uninstall     Uninstalls virtual machine
			start         Starts xhyve
			stop          Stops xhyve
			restart       Stops and starts xhyve
			shell         Opens shell
			exec          Executes command
			update        Updates operating system
			help          Prints documentation
	DOC
}

vm_disable_send_ips() {
	vm_ssh <<-SSH
		sed -i '' '/send-ips/d' /etc/rc.local
	SSH
}

vm_ssh() {
	local pre cmd
	cmd="fast_ssh $vm_user $vm_host"
	if [ $cloud_context = local ]; then
		case $PWD in
		$HOME*)
			pre="cd '$PWD' >/dev/null 2>&1"
		;;
		esac
	fi
	if [ ! -z "$pre" ]; then
		if [ $# -gt 0 ]; then
			if [ ! -t 0 ]; then
				cat <<-ARGS | $cmd $@
					$pre
					$(cat -)
				ARGS
			else
				cat <<-ARGS | $cmd
					$pre
					$@
				ARGS
			fi
		elif [ ! -t 0 ]; then
			cat <<-ARGS | $cmd
				$pre
				$(cat -)
			ARGS
		else
			$cmd
		fi
	else
		$cmd $@
	fi
}

vm_download() {
	if [ ! -d $repo_tmp_path ]; then
		sudo mkdir -p $repo_path
		sudo chown $USER:admin $repo_path
		mkdir -p $repo_tmp_path
		curl -o $repo_userboot_path $s3_userboot_url
		curl -o $repo_disk_path $s3_disk_url
	else
		echo Already downloaded
	fi
}

vm_create_disk() {
	if [ ! -f $user_disk_path ]; then
		tar xJvf $repo_disk_path -C $user_cloud_path
	else
		echo Disk already created
	fi
}

vm_share_home() {
	if ! mac_export_exists; then
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		mac_update_nfsd
		vm_ssh <<-SSH
			echo '$mac_ip:$exports_home_path	$HOME	nfs	rw	0	0' >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	else
		echo Already shared
	fi
}

vm_init() {
	if [ ! -f $user_conf_path ]; then
		mac_ensure_file $user_conf_path
		vm_choose_settings
	else
		echo Already initialized
	fi
}

vm_first_start() {
	local line
	if mac_host_exists; then
		xhyve_ensure
	else
		if xhyve_running; then
			xhyve_stop
		fi
		mkdir -p $tmp_path
		nc -l 1234 > $tmp_conf_path &
		sleep 5
		xhyve_spawn
		while [ -z "$(cat $tmp_conf_path)" ]; do
			printf .
			sleep $wait_count
      if ! xhyve_running; then
        error Xhyve process failed check ~/.cloud/log
      fi
		done
		. $tmp_conf_path
		mac_add_conf $user_conf_path mac_ip
		mac_add_conf $user_conf_path vm_ip
		rm $tmp_conf_path
		line="$vm_ip $vm_name"
		mac_add_host_line $line
	fi
}

vm_delete_files() {
	if [ -d $repo_tmp_path ]; then
		rm -rf $repo_tmp_path
		rm -rf $user_disk_path
	else
		echo Not found
	fi
}

vm_delete_host() {
	if mac_host_exists; then
		mac_delete_line -s $hosts_path $vm_name
	else
		echo Not found
	fi
}

vm_unshare_home() {
	if mac_export_exists; then
		mac_delete_line -s $exports_path $(escape_path $exports_home_path)
		mac_update_nfsd
	else
		echo Not shared
	fi
}

vm_choose_settings() {
	local indexes i desc value name
	indexes=${!user_setting_names[@]}
	for i in $indexes; do
		desc=${user_setting_descs[$i]}
		value=${!user_setting_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${user_setting_descs[$i]}
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			echo $desc: $value
			if ! correct; then
				printf 'Enter new value: '
				read $name
			fi
			echo
		done
		touch $user_conf_path
		for i in $indexes; do
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			mac_delete_conf $user_conf_path $name
			mac_add_conf $user_conf_path $name $value
		done
		vm_choose_settings
	fi
}

vm_load() {
	if [ ! -z $CLOUD_CONTEXT ] && [ $CLOUD_CONTEXT != local ]; then
		vm_host=$cloud_ip
	fi
}

# AWS

aws() {
	vm_ssh \
	AWS_ACCESS_KEY_ID=$aws_access_key_id \
	AWS_SECRET_ACCESS_KEY=$aws_secret_access_key \
	AWS_DEFAULT_REGION=$aws_region \
	AWS_PAGER= \
	aws "$@" ||
	exit
}

aws_config() {
	local secret
	begin Configure AWS
	if [ -z $aws_access_key_id ] || [ -z $aws_secret_access_key ] || [ -z $aws_region ]; then
		if [ -z $aws_access_key_id ]; then
			printf 'Enter access key id: '
			read -s aws_access_key_id
			secret=$(cloud_encrypt $aws_access_key_id)
			mac_add_conf "$cloud_context_path" aws_access_key_id $secret
		fi
		if [ -z $aws_secret_access_key ]; then
			printf 'Enter secret access key: '
			read -s aws_secret_access_key
			secret=$(cloud_encrypt $aws_secret_access_key)
			mac_add_conf "$cloud_context_path" aws_secret_access_key $secret
		fi
		if [ -z $aws_region ]; then
			echo
			printf 'Enter region: '
			read aws_region
			mac_add_conf "$cloud_context_path" aws_region
		fi
	else
		echo Already configured
	fi
}

aws_create_cloud() {
	aws_config
}

trap 'exit' INT TERM
trap 'kill 0' EXIT

if [ $mac_ver -lt 10 ] || [ $mac_ver -gt 11 ]; then
	error Only macOS supported versions are Catalina and Big Sur
fi

if [ -f $user_conf_path ]; then
	cloud_read_ini $user_conf_path
fi
cloud_load

case $1 in
bin)
	shift
	cmd_cloud_bin $@
;;
install)
	cmd_cloud_install
	cmd_vm_install
	complete
;;
uninstall)
	cmd_vm_uninstall
	cmd_cloud_uninstall
	complete
;;
update)
	cmd_cloud_update
;;
open)
	cmd_cloud_open
;;
gen-key)
	cmd_cloud_gen_key
;;
encrypt)
	shift
	cmd_cloud_encrypt $@
;;
decrypt)
	shift
	cmd_cloud_decrypt $@
;;
branch|volume|snapshot|tunnel|container|vm)
	group=$1
	cmd=$2
	shift 2
	case $group in
	branch|volume|snapshot|tunnel|container)
		app_load
		args=$(container_normalize_args $@)
		case $group in
		branch)
			case $cmd in
			list)
				cmd_branch_list
			;;
			checkout)
				cmd_branch_checkout $@
			;;
			*)
				cmd_branch_help $cmd
			;;
			esac
		;;
		volume)
			case $cmd in
			list)
				cmd_volume_list
			;;
			delete)
				cmd_volume_delete $1
			;;
			esac
		;;
		snapshot)
			case $cmd in
			list)
				cmd_snapshot_list
			;;
			create)
				cmd_snapshot_create $args
			;;
			delete)
				cmd_snapshot_delete $args
			;;
			*)
				cmd_snapshot_help $cmd
			;;
			esac
		;;
		tunnel)
			case $cmd in
			stop)
				cmd_tunnel_stop
			;;
			start)
				cmd_tunnel_start $args
			;;
			*)
				cmd_tunnel_help $cmd
			;;
			esac
		;;
		container)
			case $cmd in
			list)
				cmd_container_list
			;;
			log)
				cmd_container_log $args
			;;
			exec)
				cmd_container_exec $args
			;;
			deploy)
				cmd_container_deploy $args
			;;
			delete)
				cmd_container_delete $args
			;;
			stop)
				cmd_container_stop $args
			;;
			start)
				cmd_container_start $args
			;;
			restart)
				cmd_container_restart $args
			;;
			export)
				cmd_container_export $args
			;;
			restore)
				cmd_container_restore $args
			;;
			shell)
				cmd_container_shell $args
			;;
			*)
				cmd_container_help $cmd
			;;
			esac
		;;
		esac
	;;
	vm)
		vm_load
		case $cmd in
		install)
			cmd_vm_install
			complete
		;;
		uninstall)
			cmd_vm_uninstall
			complete
		;;
		config)
			cmd_vm_config
		;;
		start)
			cmd_vm_start
		;;
		stop)
			cmd_vm_stop
		;;
		restart)
			cmd_vm_restart
		;;
		shell)
			cmd_vm_shell
		;;
		exec)
			cmd_vm_exec $@
		;;
		update)
			cmd_vm_update
		;;
		help)
			cmd_vm_help
		;;
		*)
			cmd_vm_help $cmd
		;;
		esac
	;;
	esac
;;
help)
	cmd_cloud_help
;;
*)
	cmd_cloud_help $1
;;
esac
