#!/bin/sh

base_url=https://raw.githubusercontent.com/chi-rb/chi-cloud/master/install
tmp_path=/tmp
hosts_path=/etc/hosts
exports_path=/etc/exports
cloud_path=~/.cloud
settings_path=$cloud_path/settings
environment_path=./cloud/environment

multipass_path=/usr/local/bin/multipass
multipass_version=0.8.0
multipass_pkg_url=https://github.com/CanonicalLtd/multipass/releases/download/v$multipass_version/multipass-$multipass_version%2Bmac-Darwin.pkg
multipass_pkg_path=$tmp_path/multipass.pkg
multipass_uninstall_path=/Library/Application\ Support/com.canonical.multipass/uninstall.sh

vm_name=cluster
vm_memory=2G
vm_cpus=4
vm_disk=10G
vm_init_name=cloud-init.yml
vm_init_path=$tmp_path/$vm_init_name
vm_init_url=$base_url/$vm_init_name
vm_agent_name=com.$vm_name.plist
vm_agent_url=$base_url/$vm_agent_name
vm_agent_path=~/Library/LaunchAgents/$vm_agent_name
vm_agent_tmp_path=$tmp_path/$vm_agent_name

setting_names=(
  vm_memory
  vm_cpus
  vm_disk
  multipass_version
)
setting_descs=(
  'Virtual machine memory'
  'Virtual machine cpus'
  'Virtual machine disk'
  'Multipass version'
)

title() {
	if [ "$printed" = true ]; then
    echo
	fi
	echo "~> $@"
	printed=true
}

edit() {
  echo "Edit (y/N)? \c"
	read yn
  if [ "$yn" != y ]; then
    return 1
  fi
}

configure() {
  for i in ${!setting_names[@]}; do
    echo ${setting_descs[$i]}: ${!setting_names[$i]}
  done
  echo
  if edit; then
    echo
    for i in ${!setting_names[@]}; do
      setting "${setting_descs[$i]}" ${setting_names[$i]}
    done
    mkdir -p $cloud_path
    rm $settings_path
    touch $settings_path
    for i in ${!setting_names[@]}; do
      echo ${setting_names[$i]}=${!setting_names[$i]} >> $settings_path
    done
    configure
  fi
}

setting() {
  echo $1: ${!2}
  if edit; then
		echo "Enter new value: \c"
		read $2
  fi
  echo
}

multipass_current_version() {
	echo $(multipass version | head -n1 | awk '{ print $2 }' | sed 's/+.*//')
}

vm_exists() {
	multipass info $vm_name > /dev/null 2>&1
}

host_exists() {
	sudo grep $vm_name $hosts_path > /dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep '# Cloud' $exports_path > /dev/null 2>&1
}

multipass_exec() {
	multipass exec $vm_name -- sudo $@
}

kubectl() {
	multipass_exec microk8s.kubectl $@
}

find_pod() {
	echo $(kubectl get pod -l "name=$1" -o jsonpath='{.items[0].metadata.name}')
}

pod_exec() {
	name=$1
	shift
	kubectl exec -it $(find_pod $name) -- $@
}

app_deploys_path() {
  $app_mount_path/cloud/deploys
}

deploy_path() {
	if [ ! -z $1 ]; then
		echo $(app_deploys_path)/$1
  else
    echo $(app_deploys_path)
	fi
}

build_path() {
	path=/rails/cloud/builds
	if [ ! -z $1 ]; then
		path=$path/$1
	fi
	echo $path
}

gen_id() {
  echo $(uuidgen | tr '[:upper:]' '[:lower:]' | sed 's/-//g')
}

load() {
  . ./cloud/settings
}

if [ -f $settings_path ]; then
  . $settings_path
fi

case $1 in
add)

  title Generating Cloud Folder
  mkdir -p cloud/build cloud/deploy
  app_id=$(gen_id)
  echo app_id=$app_id >> cloud/settings

  title Sharing App Folder
  app_path=$(pwd)
  if ! export_exists; then
    echo '# Cloud' | sudo tee -a $exports_path
  fi
  echo $app_path -mapall=$(id -u) | sudo tee -a $exports_path
  sudo nfsd restart
  multipass_exec appctl add $app_id $app_path

;;
remove)

  if app_exists; then
    title Unsharing Application
    multipass_exec umount /mnt/$app_id
    $app_path=$(pwd)
    sudo sed -i '' "/$app_path/d" $exports_path
    sudo nfsd restart

    title Removing Cloud Folder
    rm -rf cloud
  fi

;;
install)

  configure

	if [ ! -f $multipass_path ] || [ $multipass_version != $(multipass_current_version) ]; then
		title Installing Multipass $multipass_version
		if [ -f $multipass_path ] && [ ! -z "$(sudo pgrep multipass)" ]; then
			echo Multipass is running, close it and run the script again
			exit
		fi
		curl -Lo $multipass_pkg_path $multipass_pkg_url
		sudo installer -pkg $multipass_pkg_path -target /
		rm $multipass_pkg_path
	fi

	if ! vm_exists; then
		title Creating Cluster
		curl -o $vm_init_path $vm_init_url
		multipass launch -c $vm_cpus -m $vm_memory -d $vm_disk -n $vm_name --cloud-init $vm_init_path
		rm $vm_init_path
    multipass_exec appctl install
	fi

	if ! host_exists; then
		title Adding Hostname
		vm_ip=$(multipass info $vm_name | grep IP | awk '{ print $2 }')
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	fi

	if [ ! -f $vm_agent_path ]; then
		title Installing Agent
		curl -o $vm_agent_path $vm_agent_url
		launchctl load -w $vm_agent_path
	fi

;;
uninstall)

	if [ -f $vm_agent_path ]; then
		title Uninstalling Agent
		launchctl unload -w $vm_agent_path
		rm $vm_agent_path
	fi

	if [ -f $multipass_path ]; then
		title Uninstalling Multipass
		yes | sudo sh "$multipass_uninstall_path"
	fi

	if host_exists; then
		title Removing Hostname
		sudo sed -i '' "/$vm_name/d" $hosts_path
	fi

	if export_exists; then
		title Removing Shared Folder
    sudo sed -i '' '/# Cloud/,$ d' /etc/exports
	fi

	if [ -f $cloud_path ]; then
		title Removing Configuration
		rm -rf $cloud_path
	fi

;;
reinstall)

	cloud uninstall
	cloud install

;;
environment)

  case $2 in
  list)
    ls -1 $environment_path/* | xargs basename
  ;;
  add)
    mkdir -p $environment_path
    touch $environment_path/$3
    cloud environment edit $3
  ;;
  edit)
    $EDITOR $environment_path/$3
  ;;
  delete)
    rm -f $environment_path/$3
  ;;
  esac

;;
start)

	multipass start $vm_name

;;
stop)

	multipass stop $vm_name

;;
build)

  if app_exists; then
    kubectl apply -Rf $(build_path $2)
  fi

;;
deploy)

  if app_exists; then
    kubectl apply -Rf $(deploy_path $2)
  fi

;;
undeploy)

  if app_exists; then
	  kubectl delete -Rf $(deploy_path $2)
  fi

;;
clear)

  if app_exists; then
    kubectl delete --all pods
  fi

;;
restart)

	cloud stop
	cloud start

;;
status)

	case $2 in
	cluster)
		multipass_exec top
	;;
	'')
		kubectl get pods
	;;
	*)
		kubectl describe pod $2
	;;
	esac

;;
shell)

	if [ "$2" = cluster ]; then
		multipass shell $vm_name
	else
		pod_exec ${2:-rails} /bin/bash
	fi

;;
console)

	if [ -z $2 ] || [ "$2" = rails ]; then
		pod_exec rails bin/rails c
	fi

;;
logs)

	kubectl logs -f $(find_pod ${2:-rails})

;;
help)

	cat <<-EOF
		Usage: cloud <commands> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
		  help          Prints documentation
		  install       Setups cloud
		  uninstall     Unsetups cloud
		  reinstall     Installs and uninstalls
		  environment   Manages environments
		  start         Boots cluster
		  stop          Halts cluster
		  restart       Stops and starts
		  build         Builds docker images
		  deploy        Applies one or all deploy yamls
		  undeploy      Unapplies one or all deploy yamls
		  clear         Deletes all pods
		  shell         Attachs bash session in pod or cluster (rails pod by default)
		  console       Attachs rails console
		  status        Lists pods, describes pod or runs top in cluster (lists pods by default)
		  logs          Tails pod logs (rails pod by default)
	EOF

;;
esac
