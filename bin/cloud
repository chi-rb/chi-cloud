#!/bin/sh

# SETTINGS

pid=$$
branch=dev
wait_count=15
hosts_path=/etc/hosts
nfsd_path=/sbin/nfsd
tcc_path=/Library/Application\ Support/com.apple.TCC/TCC.db
rails_pod=rails
bin_path=/usr/local/bin
xhyve_path=$bin_path/xhyve

terminal_path=/System/Applications/Utilities/Terminal.app
terminal_client=com.apple.Terminal

tmp_path=/tmp/chi-cloud
tmp_repo_path=$tmp_path/repo
tmp_base_path=$tmp_path/base
tmp_cloud_path=$tmp_base_path/cloud
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com/dev
s3_initrd_url=$s3_url/initrd
s3_vmlinuz_url=$s3_url/vmlinuz
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/cloud
repo_app_path=$repo_path/app
repo_base_path=$repo_app_path/base
repo_tmp_path=$repo_path/tmp
repo_initrd_path=$repo_tmp_path/initrd
repo_vmlinuz_path=$repo_tmp_path/vmlinuz
repo_disk_path=$repo_tmp_path/disk.img.xz
repo_bin_path=$repo_path/bin
repo_xhyve_path=$repo_bin_path/xhyve

user_cloud_path=$HOME/.cloud
user_conf_path=$user_cloud_path/conf
user_pid_path=$user_cloud_path/pid
user_disk_path=$user_cloud_path/disk.img
user_ssl_path=$user_cloud_path/ssl
user_cert_path=$user_ssl_path/fullchain.pem

vm_user=root
vm_name=cloud.local
vm_host=$vm_name
vm_mem=4G
vm_cpus=4
vm_id=3646C502-7C09-4259-B71D-4B4BB447D6A6

ca_path=/usr/local/share/ca-certificates
ca_cert_path=$ca_path/cloud.crt

k3s_latest_url=https://github.com/rancher/k3s/releases/latest
k3s_path=/usr/local/bin/k3s

net_setting_names=(
	mac_ip
	vm_ip
)
user_setting_names=(
	vm_mem
	vm_cpus
)
user_setting_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

# UTILS

complete() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo DONE!
}

is_pod() {
	echo "${cloud_pods[@]}" | grep -q $1
}

read_ini() {
	local OPTIND o name value group
	save_pods=false
	while getopts ':p' o; do
		case "$o" in
		p)
			save_pods=true
		;;
		esac
	done
	shift $((OPTIND-1))
	while IFS=' = ' read name value; do
		case $name in
		\[*\])
			group=$(echo $name | sed 's/\[//' | sed 's/\]//')
			if [ $save_pods = true ] && [ $group != cloud ] && ! $(is_pod $group); then
				cloud_pods+=($group)
			fi
			if [ $group = mysql ] || [ $group = postgres ]; then
				cloud_db=$group
			fi
		;;
		*)
			if [ ! -z $value ]; then
				case $value in
				ENC\(*\))
					value=$(cloud_decrypt "$value")
				;;
				esac
				eval export "${group}_${name}=\"$value\""
			fi
		esac
	done < "$1"
}

error() {
	echo $@ >&2
	kill -10 $pid
}

begin() {
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "---> $@\n"
	beginned=true
}

indent() {
 sed 's/^/    /'
}

correct() {
	local yn
	printf 'Correct (Y/n)? '
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

unknown() {
	if [ ! -z $1 ]; then
		echo "Unknown command \`$1\` \n"
	fi
}

downcase() {
	tr '[:upper:]' '[:lower:]'
}

gen_id() {
	echo $(uuidgen | downcase)
}

gen_pass() {
	echo $(uuidgen | sed 's/-//g' | downcase)
}

normalize_args() {
	printf "%q " "$@"
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR "$1"
	fi
}

ensure_file() {
	mkdir -p "$(dirname "$1")"
	touch "$1"
}

add_conf() {
	local OPTIND o precmd group name conf
	while getopts ':s:' o; do
		case "$o" in
		s)
			$precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		group=$(echo $2 | cut -d '_' -f 1)
		name=$(echo $2 | cut -d '_' -f 2-)
		if [ -z $3 ]; then
			conf="$name = ${!2}"
		else
			conf="$name = $3"
		fi
		if ! cat "$1" | grep -q "\[$group\]"; then
			echo "\n[$group]" | $precmd tee -a "$1" >/dev/null
		fi
		$precmd sed -i '' $"/\[$group\]/a\\
		$conf\\
		" "$1"
	else
		error "File $1 don't exist"
	fi
}

delete_conf() {
	local OPTIND o precmd target_group target_name i name value group
	while getopts ':s' o; do
		case "$o" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		target_group=[$(echo $2 | cut -d '_' -f 1)]
		target_name=$(echo $2 | cut -d '_' -f 2-)
		i=1
		while IFS=' = ' read name value; do
			case $name in
			\[*\])
				group=$name
			;;
			*)
				if [ ! -z $value ] && [ "$group" = $target_group ] && [ "$name" = $target_name ]; then
					$precmd sed -i '' "$i,1d" "$1"
					break
				fi
			esac
			i=$(($i+1))
		done < "$1"
	else
		error "File $1 don't exist"
	fi
}

delete_line() {
	local OPTIND o precmd path
	while getopts ':s' o; do
		case "$o" in
		s)
			precmd=sudo
		;;
		esac
	done
	shift $((OPTIND-1))
	if [ -f "$1" ]; then
		path=$(normalize_args $1)
		$precmd sed -i '' /$2/d $path
	else
		error "File $1 don't exist"
	fi
}

bin_authorized() {
	local client result
	if [ ! -z $2 ]; then
		client=$2
	else
		client=$1
	fi
	result=$(
		sudo sqlite3 "$tcc_path" \
		"select 0 from access where allowed=true and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\"" 2>/dev/null
	)
	if [ $? = 1 ]; then
		return 1
	elif [ "$result" = 0 ]; then
		return 0
	else
		return 1
	fi
}

show_file() {
	osascript -e 'tell application "Finder"' -e activate -e "reveal POSIX file \"$1\"" -e end tell >/dev/null 2>&1
}

get_bin_names() {
	find $repo_bin_path -type f -name '[a-z]*' -exec basename {} \;
}

open_privacy() {
	open "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles" 
}

authorize_bin() {
	local name
	while :; do
		open_privacy
		name=$(basename $1)
		echo \
		"Please drag the binary into the full disk access tab if $name don't appears," \
		"otherwise check the corresponding box"
		show_file $1
		echo Press enter once done
		read
		if bin_authorized "$@"; then
			break
		fi
	done
}

host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path >/dev/null 2>&1
}

update_nfsd() {
	sudo $nfsd_path update
}

normalize_path() {
	local host pod path
	if [ $(echo $1 | grep :) ]; then
		host=$(echo $1 | cut -d ':' -f 1)
		pod=$(cloud_find_pod $host)
		path=$(echo $1 | cut -d ':' -f 2)
	else
		pod=
		path=$1
	fi
	if [ ! -z $pod ] && [ ! -z $path ]; then
		echo $pod:$path
	else
		echo $path
	fi
}

# XHYVE

xhyve_ensure() {
	if ! xhyve_running; then
		xhyve_start silent
	fi
}

xhyve_spawn() {
	sudo nohup xhyve \
	-U $vm_id \
	-A \
	-c $vm_cpus \
	-m $vm_mem \
	-s 0,hostbridge \
	-s 2,virtio-net \
	-s 4,virtio-blk,$user_disk_path \
	-f "kexec,$repo_vmlinuz_path,$repo_initrd_path,root=/dev/vda1 ro" \
	&>/dev/null &
	echo $! > $user_pid_path
}

xhyve_start() {
	xhyve_spawn
	xhyve_wait_k8s "$@"
}

xhyve_pid() {
	local pid
	pid=$(cat $user_pid_path)
	pgrep -P $pid
}

xhyve_starting() {
	! $(vm_ssh kubectl get pods >/dev/null 2>&1)
}

xhyve_wait_k8s() {
	while xhyve_starting; do
		if [ "$1" != silent ]; then
			printf .
		fi
		sleep $wait_count
	done
	if [ "$1" != silent ]; then
		echo
	fi
}

xhyve_stop() {
	vm_exec -- halt
	xhyve_wait_pid "$@"
	rm $user_pid_path
}

xhyve_wait_pid() {
	while xhyve_running; do
		if [ "$1" != silent ]; then
			printf .
		fi
		sleep $wait_count
	done
	if [ "$1" != silent ]; then
		echo
	fi
}

xhyve_running() {
	if [ -f $user_pid_path ]; then
		ps -p $(xhyve_pid) >/dev/null 2>&1
	else
		return 1
	fi
}

# COMPILE

compile_statics() {
	local namespaces resources
	if [ $1 != build ]; then
		if [ ! -z "$cloud_kubeconfig" ]; then
			cat <<-YML > "$cloud_registry_docker_path"
				apiVersion: v1
				kind: Secret
				metadata:
				  name: registry-docker
				type: kubernetes.io/dockerconfigjson
				data:
				  .dockerconfigjson: $(printf "$cloud_docker_config" | base64)
			YML
		fi
	else
		if [ $cloud_context != local ]; then
			cat <<-YML > "$cloud_kaniko_docker_path"
				apiVersion: v1
				kind: Secret
				metadata:
				  name: kaniko-docker
				type: Opaque
				stringData:
				  config.json: |
				$(echo "$cloud_docker_config" | indent)
			YML
		fi
	fi
	cat <<-YML > "$cloud_data_path"
		apiVersion: v1
		kind: PersistentVolumeClaim
		metadata:
		  name: data
		  labels:
		    name: data
		spec:
		  storageClassName: $cloud_storage_class
		  accessModes:
		  - $cloud_access_mode
		  resources:
		    requests:
		      storage: 1Gi
	YML
	cat <<-YML > "$cloud_namespace_path"
		apiVersion: v1
		kind: Namespace
		metadata:
		  name: $cloud_id
		  labels:
		    name: $cloud_id
		    type: app
	YML
	namespaces=$(find "$cloud_apply_path" -type d -mindepth 1 -maxdepth 1 | xargs basename)
	resources=$(ls "$cloud_apply_path" | sed 's/^/  - /g')
	cat <<-YML > "$cloud_kustomization_path"
		namespace: $cloud_id
		resources:
		$resources
	YML
}

compile() {
	local OPTIND OPTARG cache o paths path name target
	begin Compiling YAMLs
	cache=true
	while getopts ':c:' o; do
		case "$o" in
		c)
			cache=$OPTARG
		;;
		esac
	done
	shift $((OPTIND-1))
	rm -rf "$cloud_apply_path" 
	mkdir -p "$cloud_apply_path"
	compile_set_globals
	case $1 in
	build)
		paths=$(find "$cloud_builds_path" -type d -depth 1)
		while read path; do
			name=$(basename "$path")
			compile_dockerfile $name
			compile_kaniko $name
		done <<< "$paths"
	;;
	deploy)
		for name in ${cloud_pods[@]}; do
			compile_$name $name
		done
	;;
	esac
	compile_statics $1
}

compile_set_globals() {
	local name pod_name image_name version_name
	for name in ${cloud_pods[@]}; do
		pod_name=$(echo $name | tr _ -)
		export "${name}_host=$pod_name"
		export "${name}_name=$pod_name"
		version_name=${name}_version
		if [ -d "$cloud_builds_path/$name" ]; then
			export "${name}_from=chirb/$name:${!version_name}"
			export "${name}_image=$cloud_registry_host/$cloud_name/$cloud_env/$name"
		else
			image_name=${name}_image
			if [ -z ${!image_name} ]; then
				export "${name}_image=$name:${!version_name}"
			else
				export "${name}_image=${!image_name}:${!version_name}"
			fi
		fi
	done
}

compile_dockerfile() {
	local dir_path dockerfile_path from build_path
	dir_path="$cloud_dockerfiles_path/$1"
	mkdir -p "$dir_path"
	dockerfile_path="$dir_path/Dockerfile"
	compile_set_vars $1 from
	cat <<-DOCKER > "$dockerfile_path"
		FROM $from

		RUN /mnt/tmp/cloud/dockerfiles/$1/build
	DOCKER
	build_path="$dir_path/build"
	cat <<-SH > "$build_path"
		#!/bin/sh

	SH
	if [ $1 = rails ]; then
		cat <<-SH >> "$build_path"
			if [ "\$RAILS_ENV" = production ]; then
				tar --exclude-from=/mnt/.dockerignore -C /mnt -cf - . | tar -C /rails -xf -
			fi

		SH
	fi
	cat <<-SH >> "$build_path"
		/mnt/cloud/builds/$1/build

	SH
	chmod +x "$build_path"
}

compile_kaniko() {
	local name image path
	compile_set_vars $1 name image
	path="$cloud_apply_path/$1.yml"
	cat <<-YML > "$path"
		apiVersion: v1
		kind: Pod
		metadata:
		  name: $name-build
		  labels:
		    name: $name-build
		    type: build
		spec:
		  restartPolicy: Never
		  containers:
		  - image: gcr.io/kaniko-project/executor:latest
		    name: kaniko
		    args:
		    - --destination=$image
		    - --context=/mnt
		    - --dockerfile=/tmp/cloud/dockerfiles/$name/Dockerfile
		    - --build-arg=RAILS_ENV=$cloud_env
	YML
	if [ $cloud_context = local ]; then
		cat <<-YML >> "$path"
		    - --skip-tls-verify
		YML
	fi
	cat <<-YML >> "$path"
			    volumeMounts:
			    - name: mnt
			      mountPath: /mnt
	YML
	if [ $cloud_context != local ]; then
		cat <<-YML >> "$path"
			    - name: docker
			      mountPath: /kaniko/.docker
		YML
	fi
	cat <<-YML >> "$path"
			  volumes:
			  - name: mnt
			    hostPath:
			      path: $app_path
	YML
	if [ $cloud_context != local ]; then
		cat <<-YML >> "$path"
			  - name: docker
			    secret:
			      secretName: kaniko-docker
		YML
	fi
	if [ $cloud_context = local ]; then
		cat <<-YML >> "$path"
			  hostAliases:
			  - ip: $vm_ip
			    hostnames:
			    - $cloud_registry_host
		YML
	fi
}

compile_mysql() {
	local name pass db
	compile_set_vars $1 pass db
	compile_service $1
	compile_deployment \
	-e MYSQL_ROOT_PASSWORD:$pass \
	-e MYSQL_DATABASE:$db \
	-v $1:/var/lib/mysql \
	$1
}

compile_service() {
	local port
	compile_set_vars $1 port path
	path="$cloud_apply_path/$1-service.yml"
	cat <<-YML > $path
		apiVersion: v1
		kind: Service
		metadata:
		  name: $1
		  labels:
		    name: $1
		spec:
		  selector:
		    name: $1
		  ports:
		  - name: $1
		    port: $port
		    nodePort: null
	YML
	if [ $cloud_context = local ] && [ $1 = rails ]; then
		cat <<-YML >> $path
			  - name: capybara
			    port: 3000
			    nodePort: null
		YML
	fi
}

compile_deployment() {
	local OPTIND OPTARG o path replicas strategy image pull_policy port \
	envs env env_name env_value rails data vols vol vol_name vol_path
	while getopts ':e:v:' o; do
		case "$o" in
		e)
			envs+="$OPTARG "
		;;
		v)
			vols+="$OPTARG "
		;;
		esac
	done
	shift $((OPTIND-1))
	compile_set_vars $1 replicas strategy image pull_policy port
	path="$cloud_apply_path/$1-deployment.yml"
	cat <<-YML > "$path"
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  name:  $1
		  labels:
		    name: $1
		spec:
		  replicas: $replicas
		  strategy:
		    type: $strategy
		  selector:
		    matchLabels:
		      name: $1
		  template:
		    metadata:
		      labels:
		        name: $1
		    spec:
	YML
	if [ $cloud_context != local ]; then
		cat <<-YML >> "$path"
        imagePullSecrets:
          - name: $cloud_pull_secret
		YML
	fi
	cat <<-YML >> "$path"
		      containers:
		      - image: $image
		        imagePullPolicy: $pull_policy
		        name: $1
		        tty: true
		        stdin: true
	YML
	if [ ! -z $port ]; then
		cat <<-YML >> "$path"
		        readinessProbe:
		          tcpSocket:
		            port: $port
		          initialDelaySeconds: 30
		          failureThreshold: 15
		YML
	fi
	if [ ! -z "$envs" ]; then
		cat <<-YML >> "$path"
		        env:
		YML
		for env in $envs; do
			env_name=$(echo $env | cut -d : -f 1)
			env_value=$(echo $env | cut -d : -f 2)
			cat <<-YML >> "$path"
				        - name: $env_name
				          value: '$env_value'
			YML
		done
	fi
	if [ ! -z "$vols" ]; then
		cat <<-YML >> "$path"
		        volumeMounts:
		YML
		for vol in $vols; do
			if [ $vol = rails ]; then
				rails=true
				cat <<-YML >> "$path"
					        - mountPath: /rails
					          name: rails
				YML
			else
				data=true
				vol_path=$(echo $vol | cut -d : -f 2)
				vol_name=$(echo $vol | cut -d : -f 1)
				cat <<-YML >> "$path"
					        - mountPath: $vol_path
					          name: data
					          subPath: $vol_name
				YML
			fi
		done
		cat <<-YML >> "$path"
			      volumes:
		YML
		if [ "$rails" = true ]; then
			cat <<-YML >> "$path"
			      - name: rails
			        hostPath:
			          path: $app_path
			YML
		fi
		if [ "$data" = true ]; then
			cat <<-YML >> "$path"
			      - name: data
			        persistentVolumeClaim:
			          claimName: data
			YML
		fi
	fi
  if [ $cloud_context = local ]; then
		cat <<-YML >> "$path"
			      hostAliases:
			      - ip: $vm_ip
			        hostnames:
			        - ${cloud_name}-test.$vm_name
		YML
  fi
}

compile_redis() {
	compile_service $1
	compile_deployment \
	-v $1:/data \
	$1
}

compile_hub() {
	compile_service $1
	compile_deployment $1
}

compile_chrome() {
	compile_deployment \
	-e GRID_HUB_HOST:hub \
	-v rails \
	$1
}

compile_rails() {
	local redis_url rails_url db_host_var db_port_var db_user_var db_pass_var
	db_host_name=${cloud_db}_host
	db_port_name=${cloud_db}_port
	db_user_name=${cloud_db}_user
	db_pass_name=${cloud_db}_pass
	compile_set_vars $1 rails_master_key rails_threads_min rails_threads_max \
	rails_workers $db_host_name $db_port_name $db_user_name $db_pass_name
	redis_url=redis://$redis_host:$redis_port
	rails_url=/$cloud_name/$cloud_env
	compile_service $1
	compile_deployment \
	-e CLOUD_NAME:$cloud_name \
	-e RAILS_MASTER_KEY:$rails_master_key \
	-e RAILS_ENV:$cloud_env \
	-e RAILS_THREADS_MIN:$rails_threads_min \
	-e RAILS_THREADS_MAX:$rails_threads_max \
	-e RAILS_WORKERS:$rails_workers \
	-e DB_HOST:${!db_host_name} \
	-e DB_PORT:${!db_port_name} \
	-e DB_USER:${!db_user_name} \
	-e DB_PASS:${!db_pass_name} \
	-e REDIS_URL:$redis_url \
	-v rails \
	$1
}

compile_get_var() {
	local original_var cloud_var pod_var target_var
	original_var=$2
	cloud_var=cloud_$2
	pod_var=$1_$2
	if [ ! -z "${!pod_var}" ]; then
		target_var=$pod_var
	elif [ ! -z "${!cloud_var}" ]; then
		target_var=$cloud_var
	elif [ ! -z "${!original_var}" ]; then
		target_var=$original_var
	fi
	echo ${!target_var}
}

compile_set_vars() {
	local pod var
	pod=$1
	shift
	for var in $@; do
		export "$var=$(compile_get_var $pod $var)"
	done
}

# CLOUD 

cloud_ensure_args() {
	if [ -z $cloud_key ]; then
		error '$CLOUD_KEY not defined'
	fi
	if [ -z "$1" ]; then
		error 'No arg provided'
	fi
}

cloud_gen_key() {
	gen_pass
}

cloud_encrypt() {
	local secret
	cloud_set_globals
	cloud_ensure_args "$1"
	secret=$(echo "$1" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -e | sed 's/\\n//')
	echo "ENC($secret)"
}

cloud_decrypt() {
	local secret
	cloud_set_globals
	cloud_ensure_args "$1"
	secret=$(echo "$1" | sed 's/^ENC(//' | sed 's/)$//')
	echo "$secret" | openssl enc -k $cloud_key -aes256 -salt -base64 -A -d
}

cloud_kubectl() {
	local cmd
	cmd=$@
	if [ ! -z $cloud_id ]; then
		cmd="--namespace $cloud_id $cmd"
	fi
	vm_kubectl $cmd
}

cloud_find_pod() {
	local name
	name=${1:-$rails_pod}
	echo $(cloud_kubectl get pod -l name=$name -o jsonpath={.items[0].metadata.name})
}

cloud_pod_exec() {
	local name
	name=$1
	shift
	cloud_kubectl exec -it $name -- "$@"
}

cloud_dir_exists() {
	test -d "$cloud_path"
}

cloud_load() {
	xhyve_ensure
	cloud_set_vars
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
}

cloud_set_registry_host() {
	cloud_registry_host=registry.$cloud_domain
}

cloud_boot() {
	local name
	read_ini "$cloud_context_path"
	read_ini -p "$cloud_base_path"
	read_ini -p "$cloud_env_path"
	cloud_id=$cloud_name-$cloud_env
	if [ $cloud_context = local ]; then
		cloud_relative_path=/$cloud_name/$cloud_env
	else
		cloud_set_registry_host
		cloud_relative_path=/
		cloud_docker_config=$(cat <<-JSON
				{
				  "auths": {
				    "https://$cloud_registry_host/v2/": {
				      "auth": "$(printf $cloud_registry_user:$cloud_registry_pass | base64)"
				    }
				  }
				}
			JSON
		)
		cloud_kubeconfig=$(cat <<-YML
			clusters:
			- cluster:
			    certificate-authority-data: $cloud_api_cert
			    server: $cloud_api_url
			  name: default
			contexts:
			- context:
			    cluster: default
			    user: default
			  name: default
			current-context: default
			kind: Config
			preferences: {}
			users:
			- name: default
			  user:
			    password: $cloud_api_pass
			    username: $cloud_api_user
		YML
		)
	fi
}

cloud_ensure_dir() {
	if ! cloud_dir_exists; then
		error No cloud directory found
	fi
}

cloud_context_exists() {
	test -f "$cloud_context_path"
}

cloud_ensure_context() {
	if ! cloud_context_exists; then
		error Context not found
	fi
}

cloud_env_exists() {
	test -f "$cloud_env_path"
}

cloud_ensure_env() {
	if ! cloud_env_exists; then
		error Environment not found
	fi
}

cloud_choose_name() {
	if [ -z $cloud_name ]; then
		printf 'Enter name: '
		read	cloud_name
	fi
}

cloud_set_globals() {
	cloud_key=$CLOUD_KEY
	if [ -z $cloud_context ]; then
		cloud_context=${CLOUD_CONTEXT:-local}
	fi
	cloud_pull_policy=Always
	cloud_access_mode=ReadWriteOnce
	if [ $cloud_context = local ]; then
		cloud_domain=$vm_name
		cloud_host=$cloud_domain
		cloud_set_registry_host
		cloud_storage_class=local-path
	else
		cloud_pull_secret=registry-docker
	fi
	cloud_pods=()
}

cloud_set_vars() {
	local OPTIND OPTARG o
	cloud_db=${cloud_db:-postgres}
	while getopts ':c:e:d:' o; do
		case "$o" in
		c)
			cloud_context=$OPTARG
		;;
		e)
			cloud_env=$OPTARG
		;;
		d)
			if [ $OPTARG != postgres ] && [ $OPTARG != mysql ]; then
				error Unknown database $OPTARG
			else
				cloud_db=$OPTARG
			fi
		;;
		esac
	done
	cloud_set_globals
	if [ -z $cloud_env ]; then
		if [ -z $RAILS_ENV ]; then
			if [ $cloud_context != local ]; then
				cloud_env=production
			else
				cloud_env=development
			fi
		else
			cloud_env=$RAILS_ENV
		fi
	fi
	shift $((OPTIND-1))
	if [ ! -z "$1" ]; then
		if [ ${1:0:1} = / ]; then
			app_path=$1
		else
			app_path=$PWD/$1
		fi
	else
		app_path=$PWD
	fi
	cloud_path=$app_path/cloud
	cloud_kube_path=$cloud_path/kube
	cloud_contexts_path=$cloud_path/contexts
	cloud_local_path=$cloud_contexts_path/local
	cloud_context_path=$cloud_contexts_path/$cloud_context
	cloud_envs_path=$cloud_path/environments
	cloud_base_path=$cloud_envs_path/base
	cloud_dev_path=$cloud_envs_path/development
	cloud_prod_path=$cloud_envs_path/production
	cloud_env_path=$cloud_envs_path/$cloud_env
	cloud_tmp_path=$app_path/tmp/cloud
	cloud_kubeconfig_path=$cloud_tmp_path/kubeconfig
	cloud_apply_path=$cloud_tmp_path/apply
	cloud_dockerfiles_path=$cloud_tmp_path/dockerfiles
	cloud_kaniko_docker_path=$cloud_apply_path/kaniko-docker.yml
	cloud_registry_docker_path=$cloud_apply_path/registry-docker.yml
	cloud_namespace_path=$cloud_apply_path/namespace.yml
	cloud_data_path=$cloud_apply_path/data.yml
	cloud_volume_path=$cloud_apply_path/volume.yml
	cloud_kustomization_path=$cloud_apply_path/kustomization.yml
	cloud_builds_path=$cloud_path/builds
	cloud_deploy_path=$cloud_path/deploy
	cloud_snippets_path=$cloud_deploy_path/snippets
	cloud_samples_path=$cloud_tmp_path/samples
	cloud_sample_paths=(
		config/puma.rb
		config/database.yml
		config/cable.yml
		test/test_helper.rb
		test/application_system_test_case.rb
	)
}

cloud_rev() {
	git -C $1 rev-parse HEAD
}

cloud_clean_tmp() {
	rm -rf $tmp_path
	mkdir -p $tmp_path
}

cloud_clone() {
	begin Cloning Repository
	local current_rev new_rev
	git clone git@github.com:chi-rb/chi-cloud.git --single-branch --branch $branch $tmp_repo_path
	if [ ! -d $repo_path ]; then
		sudo mv $tmp_repo_path $repo_path
	else
		current_rev=$(cloud_rev $repo_path)
		new_rev=$(cloud_rev $tmp_repo_path)
		if [ $current_rev != $new_rev ]; then
			rm -rf $tmp_path
			error "\nSeems you're changing Cloud's version, please run \"cloud uninstall\" first"
		else
			echo Already cloned
		fi
	fi
}

cloud_authorize_terminal() {
	begin Authorizing Terminal
	if ! bin_authorized $terminal_path $terminal_client; then
		authorize_bin $terminal_path $terminal_client
		echo Restart terminal and run the script again
		exit
	else
		echo Already authorized
	fi
}

cloud_authorize_nfsd() {
	begin Authorizing NFSD
	if ! bin_authorized $nfsd_path; then
		authorize_bin $nfsd_path
		update_nfsd
	else
		echo Already authorized
	fi
}

cloud_authorize_xhyve() {
	begin Authorizing XHYVE
	if ! bin_authorized $repo_xhyve_path; then
		authorize_bin $repo_xhyve_path
	else
		echo Already authorized
	fi
}

cloud_add_bins() {
	local name
	begin Adding Binaries
	for name in $(get_bin_names); do
		path=$bin_path/$name
		if [ ! -f $path ]; then
			ln -s $repo_bin_path/$name $path
		fi
	done
}

cloud_delete_bins() {
	local name path
	begin Deleting Binaries
	if [ -d $repo_path ]; then
		for name in $(get_bin_names); do
			path=$bin_path/$name
			if [ -f $path ]; then
				rm $path
			fi
		done
	fi
}

cloud_install() {
	cloud_clean_tmp
	cloud_clone
	cloud_add_bins
	cloud_authorize_terminal
	cloud_authorize_nfsd
	cloud_authorize_xhyve
	vm_install nested
	complete
}

cloud_delete_settings() {
	begin Deleting Settings
	if [ -d $user_cloud_path ]; then
		rm -rf $user_cloud_path
	else
		echo Not found
	fi
}

cloud_delete_repo() {
	begin Deleting Cloud
	if [ -d $repo_path ]; then
		sudo rm -rf $repo_path
	else
		echo Not found
	fi
}

cloud_uninstall() {
	vm_uninstall nested
	cloud_delete_settings
	cloud_delete_bins
	cloud_delete_repo
	complete
}

cloud_update() {
	local current_path current_branch new_branch
	begin Updating Script
	current_path=$PWD
	cd $repo_path
	git pull
	current_branch=$(git branch | cut -d ' ' -f2)
	new_branch=${2:-master}
	if [ $current_branch != $new_branch ]; then
		git checkout $new_branch
	fi
	cd "$current_path"
	complete
}

cloud_generate_tmp() {
	local path_name patch_path
	mkdir -p $tmp_path
	rm -rf $tmp_base_path
	cp -r $repo_base_path $tmp_base_path
	patch_name=$cloud_db.patch
	patch_path=$tmp_path/$patch_name
	cp $repo_app_path/$patch_name $tmp_path
	patch -s -p0 -d $tmp_path < $patch_path
	rm $patch_path
}

cloud_generate_app() {
	mkdir -p "$(dirname "$app_path")"
	mv $tmp_base_path "$app_path"
	git init "$app_path"
}

cloud_generate_dir() {
	local sample_path destination_path
	mv $tmp_cloud_path "$cloud_path"
	mkdir -p "$cloud_samples_path"
	for sample_path in "${cloud_sample_paths[@]}"; do
		destination_path=$cloud_samples_path/$sample_path
		mkdir -p "$(dirname "$destination_path")"
		cp $tmp_base_path/$sample_path "$destination_path"
	done
	rm -rf $tmp_base_path
	echo You might need to tweak a few files, try using tmp/cloud/samples as a guideline
}

cloud_choose_settings() {
	begin Choosing Settings
	if [ -z $cloud_name ]; then
		cloud_choose_name
	else
		echo Already setted
	fi
}

cloud_generate() {
	begin Generating Directory
	if ! cloud_dir_exists; then
		cloud_generate_tmp
		if [ ! -d "$app_path" ]; then
			cloud_generate_app
		else
			cloud_generate_dir
		fi
		add_conf "$cloud_base_path" cloud_name
	else
		echo Already generated
	fi
}

cloud_init() {
	cloud_set_vars "$@"
	cloud_choose_settings
	cloud_generate
	complete
}

cloud_open() {
	local url
	cloud_load
	if [ $cloud_context = local ]; then
		url=$cloud_name-$cloud_env.$cloud_host
	else
		url=$cloud_host
	fi
	open https://$url
}

cloud_bin() {
	local abs_path target real_path cmd alt
	cloud_load
	abs_path=$1
	target=$(basename $abs_path)
	if cloud_dir_exists; then
		shift
		rel_path=bin/$target
		if [ -f $rel_path ]; then
			cmd=$rel_path
		else
			cmd=$target
		fi
		if [ $cmd = kubectl ]; then
			vm_kubectl	"$@"
		else
			cloud_exec -- $cmd "$@"
		fi
	else
		alt=$(which -a $target | grep -A 1 $abs_path | tail -n 1)
		if [ -z "$alt" ]; then
			error "No alternative found for \`$target\`"
		else
			$alt "$@"
		fi
	fi
}

cloud_copy() {
	local from to
	cloud_load
	from=$(normalize_path $1)
	to=$(normalize_path $2)
	cloud_kubectl cp $from $to
}

cloud_delete_namespace() {
	begin Deleting Namespace
	vm_kubectl delete namespace $cloud_id
	cloud_refresh_hosts
}

cloud_delete_dir() {
	begin Deleting Cloud Directory
	if [ ! -d "$cloud_path" ]; then
		rm -rf "$cloud_path"
	else
		echo Not found
	fi
}

cloud_delete() {
	cloud_load
	cloud_delete_namespace
	complete
}

cloud_destroy() {
	cloud_load
	cloud_delete_namespace
	cloud_delete_dir
	complete
}

cloud_apply() {
	begin Applying YAMLs
	vm_kubectl apply -k \"$cloud_apply_path\"
}

cloud_clear_builds() {
	begin Clearing Builds
	cloud_kubectl delete pods -l type=build
}

cloud_log_builds() {
	begin Logging Builds
	cloud_kubectl wait pod \
	-l type=build \
	--for condition=Ready \
	--timeout=24h
	cloud_kubectl logs -f -l type=build
}

cloud_build() {
	cloud_load
	if [ $cloud_context != local ]; then
		unset cloud_kubeconfig
	fi
	cloud_clear_builds
	compile "$@" build
	cloud_apply
	cloud_log_builds
	complete
}

cloud_refresh_hosts() {
	begin Refreshing Hosts
	local namespaces namespace line name env subdomain
	namespaces=$(kubectl get namespaces -l type=app -o jsonpath={.items[0].metadata.name})
	line=$(echo $vm_ip cloud $vm_name registry.$vm_name)
	for namespace in $namespaces; do
		name=$(echo $namespace | rev | cut -d - -f 2- | rev)
		env=$(echo $namespace | rev | cut -d - -f 1 | rev)
		if [ $env = development ]; then
			for subdomain in $env test; do
				line+=" $name-$subdomain.$vm_name"
			done
		fi
	done
	vm_delete_host_line
	vm_add_host_line $line
}

cloud_deploy() {
	cloud_load
	compile deploy
	cloud_apply
	cloud_refresh_hosts
	complete
}

cloud_restart() {
	local cmd
	cloud_load
	if [ -z "$cloud_kubeconfig" ]; then
		cmd='delete pod '
		if [ -z $1 ]; then
			cmd+='-l type!=build'
		else
			cmd+=$(cloud_find_pod $1)
		fi
	else
		cmd="rollout restart deployment $1"
	fi
	cloud_kubectl $cmd
}

cloud_shell() {
	local name
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_pod_exec $name /bin/bash
}

cloud_attach() {
	local name
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_kubectl attach -it $name
}

cloud_tunnel() {
	local port name
	cloud_load
	port=$(cloud_kubectl get service $1 --no-headers=true | awk '{ print $5 }' | sed 's/\/.*//')
	name=$(cloud_find_pod $1)
	cloud_kubectl port-forward $name --address 0.0.0.0 $port:$port
}

cloud_exec() {
	local name
	cloud_load
	if [ $# -gt 2 ] && [ "$2" = -- ]; then
		name=$1
		shift 2
	elif [ $# -gt 1 ] && [ "$1" = -- ]; then
		shift
	else
		error Wrong format
	fi
	name=$(cloud_find_pod $name)
	cloud_pod_exec $name "$@"
}

cloud_status() {
	local name
	cloud_load
	if [ -z "$1" ]; then
		cloud_kubectl get pods
	else
		name=$(cloud_find_pod $1)
		cloud_kubectl describe pod $name
	fi
}

cloud_log() {
	local name
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_kubectl logs -f $name
}

cloud_gen_registry_auth() {
	local secret
	cloud_registry_user=cloud
	secret=$(cloud_encrypt $cloud_registry_user)
	add_conf "$cloud_context_path" cloud_registry_user $secret
	cloud_registry_pass=$(gen_pass)
	secret=$(cloud_encrypt $cloud_registry_pass)
	add_conf "$cloud_context_path" cloud_registry_pass $secret
	echo $(htpasswd -Bbn $cloud_registry_user $cloud_registry_pass)
}

cloud_config() {
	vm_kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml
	cat <<-YML | vm_kubectl apply -f -
		apiVersion: v1
		kind: PersistentVolumeClaim
		metadata:
		  name: data
		  labels:
		    name: data
		spec:
		  storageClassName: $cloud_storage_class
		  accessModes:
		  - $cloud_access_mode
		  resources:
		    requests:
		      storage: 1Gi
		---
		apiVersion: v1
		kind: Service
		metadata:
		  name: registry
		  labels:
		    name: registry
		spec:
		  selector:
		    name: registry
		  ports:
		  - name: registry
		    port: 5000
		    nodePort: null
	YML
	if [ $cloud_context = local ]; then
		cat <<-YML | vm_kubectl apply -f -
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  name:  registry
			  labels:
			    name: registry
			spec:
			  selector:
			    matchLabels:
			      name: registry
			  template:
			    metadata:
			      labels:
			        name: registry
			    spec:
			      containers:
			      - image: registry:2
			        name: registry
			        imagePullPolicy: Always
			        volumeMounts:
			        - name: data
			          mountPath: /var/lib/registry
			          subPath: registry
			      volumes:
			      - name: data
			        persistentVolumeClaim:
			          claimName: data
			---
			apiVersion: v1
			kind: Service
			metadata:
			  name: ingress
			  labels:
			    name: ingress
			spec:
			  type: LoadBalancer
			  selector:
			    name: ingress
			  ports:
			  - name: http
			    port: 80
			    targetPort: 80
			  - name: https
			    port: 443
			    targetPort: 443
			---
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  name: ingress
			  labels:
			   name: ingress
			spec:
			  selector:
			    matchLabels:
			      name: ingress
			  template:
			    metadata:
			      labels:
			        name: ingress
			    spec:
			      containers:
			      - name: ingress
			        image: chirb/nginx:1.14.0
			        imagePullPolicy: Always
			        env:
			        - name: CLOUD_CONTEXT
			          value: local
			        - name: CLOUD_REGISTRY_HOST
			          value: $cloud_registry_host
			        volumeMounts:
			        - name: conf
			          mountPath: /ssl
			          subPath: ssl
			      volumes:
			      - name: conf
			        hostPath:
			          path: $HOME/.cloud
		YML
	else
		htpasswd=$(cloud_gen_registry_auth)
		cat <<-YML | vm_kubectl apply -f -
			apiVersion: v1
			kind: Secret
			metadata:
			  name: registry-auth
			type: Opaque
			stringData:
			  htpasswd: |
			$(echo "$htpasswd" | indent)
			---
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  name:  registry
			  labels:
			    name: registry
			spec:
			  selector:
			    matchLabels:
			      name: registry
			  template:
			    metadata:
			      labels:
			        name: registry
			    spec:
			      containers:
			      - image: registry:2
			        name: registry
			        imagePullPolicy: Always
			        env:
			        - name: REGISTRY_AUTH
			          value: htpasswd
			        - name: REGISTRY_AUTH_HTPASSWD_PATH
			          value: /auth/htpasswd
			        - name: REGISTRY_AUTH_HTPASSWD_REALM
			          value: Registry
			        volumeMounts:
			        - name: data
			          mountPath: /var/lib/registry
			          subPath: registry
			        - name: auth
			          mountPath: /auth
			          readOnly: true
			      volumes:
			      - name: data
			        persistentVolumeClaim:
			          claimName: data
			      - name: auth
			        secret:
			          secretName: registry-auth
			---
			apiVersion: v1
			kind: Service
			metadata:
			  name: ingress
			  labels:
			    name: ingress
			spec:
			  type: LoadBalancer
			  selector:
			    name: ingress
			  ports:
			  - name: http
			    port: 80
			    targetPort: 80
			  - name: https
			    port: 443
			    targetPort: 443
			---
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  name: ingress
			  labels:
			    name: ingress
			spec:
			  selector:
			    matchLabels:
			      name: ingress
			  template:
			    metadata:
			      labels:
			        name: ingress
			    spec:
			      containers:
			      - name: ingress
			        image: chirb/nginx:1.18.0
			        imagePullPolicy: Always
			        env:
			        - name: CLOUD_NAME
			          value: $cloud_name
			        - name: CLOUD_CONTEXT
			          value: $cloud_context
			        - name: CLOUD_DOMAIN
			          value: $cloud_domain
			        - name: CLOUD_HOST
			          value: $cloud_host
			        - name: CLOUD_REGISTRY_HOST
			          value: $cloud_registry_host
			        - name: DNS_TYPE
			          value: $cloud_dns_type
			        - name: DNS_USER
			          value: $cloud_dns_user
			        - name: DNS_PASS
			          value: '$cloud_dns_pass'
			        volumeMounts:
			        - name: data
			          mountPath: /ssl
			          subPath: ssl
			      volumes:
			      - name: data
			        persistentVolumeClaim:
			          claimName: data
		YML
	fi
}

cloud_help() {
	unknown
	cat <<-DOC
		Usage: cloud <command> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
			install       Installs cloud
			uninstall     Uninstalls cloud
			update [tag]  Syncs latest or specific version
			init [path]   Generates directory and initializes
			delete        Deletes only namespace
			destroy       Deletes directory and purges
			build         Builds docker images
			deploy        Deploys application
			undeploy      Undeploys application
			status [pod]  Prints status of pods (all by default)
			restart [pod] Restart pod (rails by default)
			shell [pod]   Opens a shell in pod (rails by default)
			attach pod    Attachs into first process of pod (rails by default)
			tunnel pod    Creates temporary tunnel into pod
			exec [pod]    Executes shell command in pod (rails by default)
			open          Opens browser pointing to app
			log [pod]     Tails pod log (rails by default)
			envs          Manages environments
			vm            Manages virtual machine
			help          Prints documentation
	DOC
}

# CONTEXTS

contexts_list() {
	cloud_set_vars
	cloud_ensure_dir
	list=$(ls -1 "$cloud_contexts_path")
	if [ -z "$list" ]; then
		error No contexts found
	else
		echo "$list"
	fi
}

contexts_choose_provider() {
	local input
	printf 'Choose provider: AWS (A)? '
	read input
	case $input in
	A|a|'')
		cloud_provider=aws
	;;
	*)
		echo Invalid option, try again
		contexts_choose_provider
	esac
	add_conf "$cloud_context_path" cloud_provider
}

contexts_add() {
	xhyve_ensure
	cloud_set_vars -c $1
	cloud_ensure_dir
	if ! cloud_context_exists; then
		cloud_ensure_env
		begin Adding Context $1
		ensure_file "$cloud_context_path"
		contexts_choose_provider
		cloud_boot
		case $cloud_provider in
		aws)
			aws_create_cloud
		;;
		esac
		cloud_config
	else
		error Contexts already added
	fi
	complete
}

contexts_edit() {
	xhyve_ensure
	cloud_set_vars -c $1
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
	begin Editing Context $1
	edit "$cloud_context_path"
	case $cloud_provider in
	aws)
		aws_create_cloud
	;;
	esac
	complete
}

contexts_delete() {
	xhyve_ensure
	cloud_set_vars -c $1
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
	begin Deleting Context $1
	case $cloud_provider in
	aws)
		aws_delete_cloud
	;;
	esac
	rm -f "$cloud_context_path"
	complete
}

# ENVS

envs_list() {
	local list
	cloud_set_vars
	cloud_ensure_dir
	list=$(ls -1 "$cloud_envs_path")
	if [ -z "$list" ]; then
		error No environments found
	else
		echo "$list"
	fi
}

envs_add() {
	cloud_set_vars -e $1
	cloud_ensure_dir
	if ! cloud_env_exists; then
		begin Adding Environment $1
		ensure_file "$cloud_env_path"
		edit "$cloud_env_path"
	else
		error Environment already added
	fi
	complete
}

envs_edit() {
	cloud_set_vars -e $1
	cloud_ensure_dir
	cloud_ensure_env
	begin Editing Environment $1
	edit "$cloud_env_path"
	complete
}

envs_delete() {
	cloud_set_vars -e $1
	cloud_ensure_dir
	cloud_ensure_env
	begin Deleting Environment $1
	rm -f "$cloud_env_path"
	complete
}

envs_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud envs <command> [options]

		Available commands:
			list          Lists all
			add           Adds new
			edit          Edits existing
			delete        Delete existing 
			help          Prints documentation
	DOC
}

# VM

vm_shell() {
	xhyve_ensure
	vm_load
	vm_ssh
}

vm_ssh() {
	local ssh path cd cmd
	ssh=$(cat <<-SSH
		ssh -tq
		-o ConnectTimeout=10
		-o ControlMaster=auto
		-o ControlPersist=600
		-o ControlPath=/tmp/%r@%h
		-o UserKnownHostsFile=/dev/null
		-o StrictHostKeyChecking=no
		$vm_user@$vm_host
	SSH
	)
	if [ $# -gt 0 ] || [ ! -t 0 ]; then
		if [ $cloud_context = local ]; then
			case $PWD in
			$HOME*)
				cd="cd '$PWD' >/dev/null 2>&1"
			;;
			esac
		fi
		if [ $# -gt 0 ]; then
			cmd=$@
		else
			cmd=$(cat -)
		fi
		$ssh "
			$cd
			$cmd
		"
	else
		$ssh
	fi
}

vm_kubectl() {
	local kubectl
	kubectl='vm_ssh kubectl'
	if [ ! -z "$cloud_kubeconfig" ]; then
		echo "$cloud_kubeconfig" > "$cloud_kubeconfig_path"
		$kubectl --kubeconfig \"$cloud_kubeconfig_path\" "$@"
	else
		$kubectl "$@"
	fi
}

vm_download() {
	begin Dowloading Images
	if [ ! -d $repo_tmp_path ]; then
		mkdir -p $repo_tmp_path
		curl -o $repo_initrd_path $s3_initrd_url
		curl -o $repo_vmlinuz_path $s3_vmlinuz_url
		curl -o $repo_disk_path $s3_disk_url
	else
		echo Already downloaded
	fi
}

vm_create_disks() {
	begin Creating Disk
	if [ ! -f $user_disk_path ]; then
		tar xJvf $repo_disk_path -C $user_cloud_path
	else
		echo Disk already created
	fi
}

vm_share_home() {
	begin Sharing Home Directory
	if ! export_exists; then
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		update_nfsd
		vm_ssh <<-SSH
			echo '$mac_ip:$exports_home_path	$HOME	nfs	local_lock=all	0 0' >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	else
		echo Already shared
	fi
}

vm_init() {
	begin Initializing Virtual Machine
	if [ ! -f $user_conf_path ]; then
		ensure_file $user_conf_path
		vm_config nested
	else
		echo Already initialized
	fi
}

vm_delete_host_line() {
	delete_line -s $hosts_path $vm_name
}

vm_add_host_line() {
	echo $@ | sudo tee -a $hosts_path
}

vm_first_start() {
	local line
	begin First Start
	if host_exists; then
		xhyve_ensure
	else
		if xhyve_running; then
			xhyve_stop
		fi
		mkdir -p $tmp_path
		nc -l 1234 > $tmp_conf_path &
		xhyve_spawn
		while [ -z "$(cat $tmp_conf_path)" ]; do
			printf .
			sleep $wait_count
		done
		. $tmp_conf_path
		add_conf $user_conf_path mac_ip
		add_conf $user_conf_path vm_ip
		rm $tmp_conf_path
		line="$vm_ip cloud $vm_name registry.$vm_name"
		vm_add_host_line $line
		xhyve_wait_k8s
	fi
}

cloud_trust_cert() {
	begin Installing Certificates
	while [ ! -f $user_cert_path ]; do
		printf .
		sleep $wait_count
	done
	sudo security add-trusted-cert \
	-d \
	-r trustRoot \
	-k /Library/Keychains/System.keychain \
	$user_cert_path
	vm_ssh <<-SSH
		mkdir -p $ca_path
		cp $user_cert_path $ca_cert_path
		update-ca-certificates
		service k3s restart
	SSH
}

vm_install() {
	vm_download
	vm_init
	vm_create_disks
	vm_first_start
	cloud_set_globals
	vm_share_home
	cloud_config
	cloud_trust_cert
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_delete_files() {
	begin Deleting Files
	if [ -d $repo_tmp_path ]; then
		rm -rf $repo_tmp_path
		rm -rf $user_disk_path
	else
		echo Not found
	fi
}

vm_delete_host() {
	begin Deleting Hostname
	if host_exists; then
		delete_line -s $hosts_path $vm_name
	else
		echo Not found
	fi
}

vm_unshare_home() {
	local escaped_exports_home_path
	begin Unsharing Home Directory
	if export_exists; then
		escaped_exports_home_path=$(echo $exports_home_path | sed 's/\//\\\//g')
		delete_line -s $exports_path $escaped_exports_home_path
		update_nfsd
	else
		echo Not shared
	fi
}

vm_uninstall() {
	vm_stop nested
	if [ "$1" != nested ]; then
		vm_delete_files
	fi
	vm_delete_host
	vm_unshare_home
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_choose_settings() {
	local indexes i desc value name
	if [ "$1" != nested ]; then
		begin Choosing Settings
	fi
	indexes=${!user_setting_names[@]}
	for i in $indexes; do
		desc=${user_setting_descs[$i]}
		value=${!user_setting_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${user_setting_descs[$i]}
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			echo $desc: $value
			if ! correct; then
				printf 'Enter new value: '
				read $name
			fi
			echo
		done
		touch $user_conf_path
		for i in $indexes; do
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			delete_conf $user_conf_path $name
			add_conf $user_conf_path $name $value
		done
		vm_choose_settings nested
	fi
}

vm_config() {
	vm_choose_settings
	if [ "$1" != nested ]; then
		vm_restart
		complete
	fi
}

vm_start() {
	begin Starting Virtual Machine
	if [ "$1" != nested ]; then
		vm_load
	fi
	if ! xhyve_running; then
		xhyve_start
	else
		echo Already running
	fi
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_stop() {
	begin Stopping Virtual Machine
	if [ "$1" != nested ]; then
		vm_load
	fi
	if xhyve_running; then
		xhyve_stop
	else
		echo Not running
	fi
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_restart() {
	begin Restarting Virtual Machine
	vm_load
	vm_stop nested
	vm_start nested
	complete
}

vm_exec() {
	xhyve_ensure
	vm_load
	if [ $# -gt 1 ] && [ "$1" = -- ]; then
		shift
	else
		error Wrong format
	fi
	vm_ssh "$@"
}

vm_update_packages() {
	begin Updating Packages
	vm_ssh <<-SSH
		apt update
		DEBIAN_FRONTEND=noninteractive apt upgrade -y && apt autoremove -y
	SSH
}

vm_update_k3s() {
	local regex current_version latest_version url
	begin Updating K3S
	vm_load
	regex='v[0-9]+\.[0-9]+\.[0-9]+\+k3s.?[0-9]+'
	current_version=$(vm_ssh k3s -v | grep -oE $regex)
	latest_version=$(curl -s $k3s_latest_url | grep -oE $regex | head -n1)
	if [ -z $current_version ] || [ $current_version != $latest_version ]; then
		url="https://github.com/rancher/k3s/releases/download/$latest_version/k3s"
		vm_ssh <<-SSH
			systemctl stop k3s
			curl -Lo $k3s_path $url
			chmod +x $k3s_path
			systemctl start k3s
		SSH
	else
		echo Already updated
	fi
}

vm_load() {
	if [ ! -z $CLOUD_CONTEXT ] && [ $CLOUD_CONTEXT != local ]; then
		cloud_load
		vm_user=ubuntu
		vm_host=$cloud_ip
	else
		cloud_set_globals
	fi
}

vm_update() {
	xhyve_ensure
	vm_load
	vm_update_packages
	vm_update_k3s
	complete
}

vm_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud vm <command> [options]

		Available commands:
			install       Installs virtual machine
			uninstall     Uninstalls virtual machine
			start         Starts xhyve
			stop          Stops xhyve
			restart       Stops and starts xhyve
			shell         Opens a shell
			exec          Executes command
			update        Updates operating system
			help          Prints documentation
	DOC
}

# AWS

aws() {
	vm_ssh \
	AWS_ACCESS_KEY_ID=$aws_access_key_id \
	AWS_SECRET_ACCESS_KEY=$aws_secret_access_key \
	AWS_DEFAULT_REGION=$aws_region \
	AWS_PAGER= \
	aws "$@" ||
	exit
}

aws_config() {
	local secret
	begin Configure AWS
	if [ -z $aws_access_key_id ] || [ -z $aws_secret_access_key ] || [ -z $aws_region ]; then
		if [ -z $aws_access_key_id ]; then
			printf 'Enter access key id: '
			read -s aws_access_key_id
			secret=$(cloud_encrypt $aws_access_key_id)
			add_conf "$cloud_context_path" aws_access_key_id $secret
		fi
		if [ -z $aws_secret_access_key ]; then
			printf 'Enter secret access key: '
			read -s aws_secret_access_key
			secret=$(cloud_encrypt $aws_secret_access_key)
			add_conf "$cloud_context_path" aws_secret_access_key $secret
		fi
		if [ -z $aws_region ]; then
			echo
			printf 'Enter region: '
			read aws_region
			add_conf "$cloud_context_path" aws_region
		fi
	else
		echo Already configured
	fi
}

aws_create_cloud() {
	aws_config
}

trap 'exit 1' 10

if [ -f $user_conf_path ]; then
	read_ini $user_conf_path
fi

case $1 in
debug)
	
;;
install)
	cloud_install
;;
uninstall)
	cloud_uninstall
;;
update)
	cloud_update
;;
init)
	shift
	cloud_init "$@"
;;
open)
	cloud_open
;;
delete)
	cloud_delete
;;
destroy)
	cloud_destroy
;;
bin)
	shift 
	cloud_bin "$@"
;;
copy)
	cloud_copy $2 $3 $4
;;
build)
	shift
	cloud_build "$@"
;;
deploy)
	cloud_deploy
;;
restart)
	cloud_restart $2
;;
shell)
	cloud_shell $2
;;
attach)
	cloud_attach $2
;;
tunnel)
	cloud_tunnel $2
;;
gen-key)
	cloud_gen_key
;;
encrypt)
	cloud_encrypt "$2"
;;
decrypt)
	cloud_decrypt "$2"
;;
exec)
	shift
	cloud_exec "$@"
;;
status)
	cloud_status $2
;;
log)
	cloud_log $2
;;
envs)
	case $2 in
	''|list)
		envs_list
	;;
	add)
		envs_add $3
	;;
	edit)
		envs_edit $3
	;;
	delete)
		envs_delete $3
	;;
	help)
		envs_help
	;;
	*)
		envs_help $1
	;;
	esac
;;
contexts)
	case $2 in
	''|list)
		contexts_list
	;;
	add)
		contexts_add $3
	;;
	edit)
		contexts_edit $3
	;;
	delete)
		contexts_delete $3
	;;
	help)
		contexts_help
	;;
	*)
		contexts_help $1
	;;
	esac
;;
vm)
	case $2 in
	install)
		vm_install
	;;
	uninstall)
		vm_uninstall
	;;
	config)
		vm_config
	;;
	start)
		vm_start
	;;
	stop)
		vm_stop
	;;
	restart)
		vm_restart
	;;
	shell)
		vm_shell
	;;
	exec)
		shift 2
		vm_exec "$@"
	;;
	update)
		vm_update
	;;
	help)
		vm_help
	;;
	*)
		vm_help $2
	;;
	esac
;;
help)
	cloud_help
;;
*)
	cloud_help $1
;;
esac
