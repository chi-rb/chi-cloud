#!/bin/sh

# SETTINGS

wait_count=60
hosts_path=/etc/hosts
bin_path=/usr/local/bin
nfsd_path=/sbin/nfsd
tcc_path=/Library/Application\ Support/com.apple.TCC/TCC.db
rails_pod=rails

terminal_path=/System/Applications/Utilities/Terminal.app
terminal_client=com.apple.Terminal

agent_name=com.cloud
agent_filename=$agent_name.plist

tmp_path=/tmp/chi-cloud
tmp_repo_path=$tmp_path/repo
tmp_base_path=$tmp_path/base
tmp_cloud_path=$tmp_base_path/cloud
tmp_conf_path=$tmp_path/conf

exports_path=/etc/exports
exports_home_path=/System/Volumes/Data$HOME

s3_url=https://chi-rb.s3.amazonaws.com
s3_initrd_url=$s3_url/initrd
s3_vmlinuz_url=$s3_url/vmlinuz
s3_disk_url=$s3_url/disk.img.xz

repo_path=/usr/local/cloud
repo_app_path=$repo_path/app
repo_base_path=$repo_app_path/base
repo_vm_path=$repo_path/vm
repo_initrd_path=$repo_vm_path/initrd
repo_vmlinuz_path=$repo_vm_path/vmlinuz
repo_disk_path=$repo_vm_path/disk.img.xz
repo_bin_path=$repo_path/bin
repo_xhyve_path=$repo_bin_path/xhyve
repo_ruby_path=$repo_bin_path/ruby

user_cloud_path=$HOME/.cloud
user_conf_path=$user_cloud_path/conf
user_pid_path=$user_cloud_path/pid
user_disk_path=$user_cloud_path/disk.img
user_agent_path=$HOME/Library/LaunchAgents/$agent_filename

vm_user=root
vm_name=cloud
vm_mem=4G
vm_cpus=4

k3s_latest_url=https://github.com/rancher/k3s/releases/latest
k3s_path=/usr/local/bin/k3s

net_setting_names=(
	mac_ip
	vm_ip
)
user_setting_names=(
	vm_mem
	vm_cpus
)
user_setting_descs=(
	'Virtual machine memory'
	'Virtual machine cpus'
)

# UTILS

read_json() {
	cat - |
	grep -oE "$1\": \"[^\"]+" |
	head -n1 |
	awk '{ print $2 }' |
	tr -d '"'
}

wait_for() {
	while :; do
		printf .
		sleep $wait_count
		if [ -z $2 ]; then
			if $1; then
				break
			fi
		else
			if [ "$($1)" = $2 ]; then
				break
			fi
		fi
	done
	echo
}

ok() {
	if [ "$beginned" = true ]; then
		echo Ok
	fi
}

complete() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo Complete
}

authorize() {
	echo "Enter username: \c"
	read user
	echo "Enter password: \c"
	read -s pass
}

error() {
	echo $@ >&2
	exit 1
}

begin() {
	ok
	if [ "$beginned" = true ]; then
		echo
	fi
	echo "~> $@"
	beginned=true
}

correct() {
	echo "Correct (Y/n)? \c"
	read yn
	if [ "$yn" = n ]; then
		return 1
	fi
}

unknown() {
	if [ ! -z $1 ]; then
		echo "Unknown command \`$1\` \n"
	fi
}

gen_id() {
	echo $(uuidgen | tr '[:upper:]' '[:lower:]')
}

edit() {
	if [ -z $EDITOR ]; then
		echo Edit $1 to setup environment
	else
		$EDITOR "$1"
	fi
}

ensure_file() {
	mkdir -p "$(dirname "$1")"
	touch "$1"
}

add_conf() {
	if [ -f "$1" ]; then
		if [ $2 = - ]; then
			conf=$(cat -)
		else
			if [ -z $3 ]; then
				conf="$2=${!2}"
			else
				conf="$2=$3"
			fi
		fi
		echo "$conf" | sudo tee -a "$1" >/dev/null
	else
		error "File $1 don't exist"
	fi
}

delete_conf() {
	if [ -f "$1" ]; then
		sudo sed -i '' "/$2/d" "$1"
	else
		error "File $1 don't exist"
	fi
}

bin_authorized() {
	if [ ! -z $2 ]; then
		client=$2
	else
		client=$1
	fi
	result=$(
		sudo sqlite3 "$tcc_path" \
		"select 0 from access where allowed=true and service=\"kTCCServiceSystemPolicyAllFiles\" and client=\"$client\"" 2>/dev/null
	)
	if [ $? = 1 ]; then
		return 1
	elif [ "$result" = 0 ]; then
		return 0
	else
		return 1
	fi
}

show_file() {
	osascript -e 'tell application "Finder"' -e activate -e "reveal POSIX file \"$1\"" -e end tell >/dev/null 2>&1
}

open_privacy() {
	open "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles" 
}

authorize_bin() {
	while :; do
		open_privacy
		name=$(basename $1)
		echo \
		"Please drag the binary into the full disk access tab if $name don't appears," \
		"otherwise check the corresponding box"
		show_file $1
		echo Press enter once done
		read
		if bin_authorized $@; then
			break
		fi
	done
}

host_exists() {
	sudo grep $vm_name $hosts_path >/dev/null 2>&1
}

export_exists() {
	test -f $exports_path && sudo grep $exports_home_path $exports_path >/dev/null 2>&1
}

update_nfsd() {
	sudo $nfsd_path update
}

# AGENT

agent_start() {
	sudo launchctl load -w $user_agent_path >/dev/null
	sudo launchctl list | grep $agent_name | awk '{ print $1 }' > $user_pid_path
}

agent_stop() {
	sudo launchctl unload -w $user_agent_path >/dev/null 2>&1
	while agent_running; do
		sleep $wait_count
	done
	rm $user_pid_path
}

agent_running() {
	if [ -f $user_pid_path ]; then
		vm_pid=$(cat $user_pid_path)
		ps -p $vm_pid >/dev/null 2>&1
	else
		return 1
	fi
}

agent_ensure() {
	if ! agent_running; then
		error Agent not running
	fi
}

# COMPILE

compile_tpl() {
	output=$(cat "$1")
	subs=$(grep -o '{{ [a-z_. ]* }}' "$1" | uniq)
	while read sub; do
		sub_args=( $(echo $sub | sed 's/{{ //' | sed 's/ }}//') )
		case $sub in
		{{\ render\ *)
			render_path=${sub_args[1]}
			vars=("${sub_args[@]:2}")
			for var in $vars; do
				export $var
			done
			snippet_path=$cloud_snippets_path/$render_path.yml
			sub_value=$(compile_tpl "$snippet_path" $2 $3 | sed 's/\//\\\//g' | tr '\n' '\r')
			output=$(echo "$output" | sed "s/$sub/$sub_value/g" | tr '\r' '\n' | sed '/^$/d')
		;;
		*)
			sub_name=${sub_args[0]}
			cloud_sub_name=cloud_${sub_name}
			pod_sub_name=${2}_${sub_name}
			if [ ! -z "${!pod_sub_name}" ]; then
				target_sub_name=$pod_sub_name
			elif [ ! -z "${!cloud_sub_name}" ]; then
				target_sub_name=$cloud_sub_name
			elif [ ! -z "${!sub_name}" ]; then
				target_sub_name=$sub_name
			else
				error $sub undefined, compiling $1 in $cloud_env
			fi
			sub_value=$(echo ${!target_sub_name} | sed 's/\//\\\//g')
			output=$(echo "$output" | sed "s/$sub/$sub_value/g")
		;;
		esac
	done <<-EOF
		$(echo "$subs")
	EOF
	echo "$output"
}

compile_tpls() {
	paths=()
	names=()
	pod_names=()
	while read path; do
		paths+=("$path")
	done <<< "$(find "$cloud_compile_path" -type f -name '*.yml')"
	for i in ${!paths[@]}; do
		path=${paths[$i]}
		name=$(basename "$path" | sed 's/\.yml$//' | tr - _)
		names+=($name)
		pod_name=$(echo $name | tr _ -)
		pod_names+=($pod_name)
		export "${name}_host=$pod_name"
		export "${name}_name=$pod_name"
		if [ -f "$cloud_build_path/$name/Dockerfile" ]; then
			if [ $cloud_context = local ]; then
				host=cloud
			elif [ ! -z "$cloud_kubeconfig" ]; then
				host=127.0.0.1
			else
				host=$cloud_host
			fi
			export "${name}_image=$host:32000/$cloud_env/$name"
		fi
	done
	for i in ${!paths[@]}; do
		path=${paths[$i]}
		name=${names[$i]}
		pod_name=${pod_names[$i]}
		apply_path=$cloud_apply_path/${path#"$cloud_compile_path"/}
		mkdir -p "$(dirname "$apply_path")"
		echo "$(compile_tpl "$path" $name $pod_name)" >> "$apply_path"
	done
}

compile_statics() {
	if [ $cloud_context != local ]; then
		case $cloud_provider in
		aws)
			if [ ! -z "$cloud_kubeconfig" ]; then
				cat <<-YML > "$cloud_volume_path"
					apiVersion: v1
					kind: PersistentVolume
					metadata:
					  name: $cloud_id
					spec:
					  capacity:
					    storage: 1Gi
					  volumeMode: Filesystem
					  accessModes:
					  - ReadWriteMany
					  persistentVolumeReclaimPolicy: Retain
					  storageClassName: efs-sc
					  csi:
					    driver: efs.csi.aws.com
					    volumeHandle: $aws_file_system_id
				YML
			fi
			cat <<-YML > "$cloud_docker_path"
				apiVersion: v1
				kind: ConfigMap
				metadata:
				  name: docker
				data:
				  config.json: |
				    { "credsStore": "ecr-login" }
			YML
		;;
		esac
	fi
	cat <<-YML > "$cloud_namespace_path"
		apiVersion: v1
		kind: Namespace
		metadata:
		  name: $cloud_id
		  labels:
		    name: $cloud_id
	YML
	cat <<-YML > "$cloud_claim_path"
		apiVersion: v1
		kind: PersistentVolumeClaim
		metadata:
		  name: data
		  labels:
		    name: data
		spec:
		  storageClassName: $cloud_storage_class
		  accessModes:
		  - $cloud_access_mode
		  resources:
		    requests:
		      storage: 1Gi
	YML
	namespaces=$(find "$cloud_apply_path" -type d -mindepth 1 -maxdepth 1 | xargs basename)
	resources=$(ls "$cloud_apply_path" | sed 's/^/  - /g')
	cat <<-YML > "$cloud_kustomization_path"
		namespace: $cloud_id
		resources:
		$resources
	YML
}

compile() {
	begin Compiling YAMLs
	cache=true
	while getopts 'c:' o; do
		case "$o" in
		c)
			cache=$OPTARG
		;;
		esac
	done
	shift $((OPTIND-1))
	rm -rf "$cloud_compile_path" "$cloud_apply_path" 
	mkdir -p "$cloud_compile_path"
	paths=$(find "$cloud_deploy_path/base" "$cloud_deploy_path/$cloud_env" -name \*.yml)
	case $1 in
	build)
		while read path; do
			name=$(basename "$path" | sed 's/\.yml//')
			if [ -d "$cloud_build_path/$name" ]; then
				target_path="$cloud_compile_path/$name.yml"
				if [ $cloud_context = local ]; then
					cat <<-YML > "$target_path"
						apiVersion: v1
						kind: Pod
						metadata:
						  name: {{ name }}-build
						  labels:
						    name: {{ name }}-build
						    type: build
						spec:
						  restartPolicy: Never
						  containers:
						  - image: gcr.io/kaniko-project/executor:latest
						    name: kaniko
						    args:
						    - --cache=$cache
						    - --cache-ttl=1h
						    - --destination={{ image }}
						    - --insecure
						    - --context=/mnt
						    - --dockerfile=/cloud/build/{{ name }}/Dockerfile
						    - --build-arg=RAILS_ENV={{ cloud_env }}
						    volumeMounts:
						    - name: mnt
						      mountPath: /mnt
						    - name: cache
						      mountPath: /cache
						      subPath: kaniko
						  volumes:
						  - name: mnt
						    hostPath:
						      path: {{ app_path }}
						  - name: cache
						    persistentVolumeClaim:
						      claimName: data
					YML
				else
					case $cloud_provider in
					rancher)
						cat <<-YML > "$target_path"
							apiVersion: v1
							kind: Pod
							metadata:
							  name: {{ name }}-build
							  labels:
							    name: {{ name }}-build
							    type: build
							spec:
							  restartPolicy: Never
							  containers:
							  - image: gcr.io/kaniko-project/executor:latest
							    name: kaniko
							    args:
							    - --destination={{ image }}
							    - --insecure
							    - --context=/mnt
							    - --dockerfile=/cloud/build/{{ name }}/Dockerfile
							    - --build-arg=RAILS_ENV={{ cloud_env }}
							    volumeMounts:
							    - name: mnt
							      mountPath: /mnt
							  volumes:
							  - name: mnt
							    hostPath:
							      path: {{ app_path }}
						YML
					;;
					aws)
						cat <<-YML > "$target_path"
							apiVersion: v1
							kind: Pod
							metadata:
							  name: {{ name }}-build
							  labels:
							    name: {{ name }}-build
							    type: build
							spec:
							  restartPolicy: Never
							  containers:
							  - image: gcr.io/kaniko-project/executor:latest
							    name: kaniko
							    args:
							    - --destination={{ image }}
							    - --context=/mnt
							    - --dockerfile=/cloud/build/{{ name }}/Dockerfile
							    - --build-arg=RAILS_ENV={{ cloud_env }}
							    volumeMounts:
							    - name: mnt
							      mountPath: /mnt
							    - name: docker
							      mountPath: /kaniko/.docker/
							    env:
							    - name: AWS_ACCESS_KEY_ID
							      value: {{ aws_access_key_id }}
							    - name: AWS_SECRET_ACCESS_KEY
							      value: {{ aws_secret_access_key }}
							    - name: AWS_REGION
							      value: {{ aws_region }}
							  volumes:
							  - name: mnt
							    hostPath:
							      path: {{ app_path }}
							  - name: docker
							    configMap:
							      name: docker
						YML
					;;
					esac
				fi
			fi
		done <<< "$paths"
	;;
	deploy)
		while read path; do
			name=$(basename "$path")
			cp "$path" "$cloud_compile_path/$name"
		done <<< "$paths"
	;;
	esac
	compile_tpls
	compile_statics
}

# CLOUD 

cloud_kubectl() {
	cmd=$@
	if [ ! -z $cloud_id ]; then
		cmd="--namespace $cloud_id $cmd"
	fi
	vm_kubectl $cmd
}

cloud_find_pod() {
	name=${1:-$rails_pod}
	echo $(cloud_kubectl get pod -l name=$name -o jsonpath={.items[0].metadata.name})
}

cloud_pod_exec() {
	name=$1
	shift
	cloud_kubectl exec -it $name -- $@
}

cloud_dir_exists() {
	test -d "$cloud_path"
}

cloud_load() {
	agent_ensure
	cloud_set_paths
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
}

cloud_boot() {
	. "$cloud_context_path"
	. "$cloud_base_path"
	. "$cloud_env_path"
	cloud_id=$cloud_name-$cloud_env
	cloud_pull=Always
	if [ ! -z $cloud_provider ]; then
		cloud_access_mode=${cloud_access_mode:-ReadWriteMany}
		case $cloud_provider in
		rancher)
			cloud_storage_class=local-path
			cloud_kubeconfig=$(cat <<-YML
				apiVersion: v1
				kind: Config
				clusters:
				- name: kubernetes
				  cluster:
				    server: $rancher_endpoint
				users:
				- name: rancher
				  user:
				    token: $rancher_token
				contexts:
				- name: kubernetes
				  context:
				    user: rancher
				    cluster: kubernetes
				current-context: kubernetes
			YML
			)
		;;
		aws)
			cloud_storage_class=efs-sc
			cloud_kubeconfig=$(cat <<-YML
				apiVersion: v1
				clusters:
				- cluster:
				    server: $aws_endpoint
				    certificate-authority-data: $aws_certificate
				  name: kubernetes
				contexts:
				- context:
				    cluster: kubernetes
				    user: aws
				  name: aws
				current-context: aws
				kind: Config
				preferences: {}
				users:
				- name: aws
				  user:
				    exec:
				      apiVersion: client.authentication.k8s.io/v1alpha1
				      command: aws
				      env:
				      - name: AWS_ACCESS_KEY_ID
				        value: $aws_access_key_id
				      - name: AWS_SECRET_ACCESS_KEY
				        value: $aws_secret_access_key
				      args:
				      - --region
				      - $aws_region
				      - eks
				      - get-token
				      - --cluster-name
				      - $aws_cluster_name
			YML
			)
		;;
		esac
	else
		cloud_access_mode=ReadWriteOnce
		cloud_storage_class=local-path
	fi
}

cloud_ensure_dir() {
	if ! cloud_dir_exists; then
		error No cloud directory found
	fi
}

cloud_context_exists() {
	test -f "$cloud_context_path"
}

cloud_ensure_context() {
	if ! cloud_context_exists; then
		error Context not found
	fi
}

cloud_env_exists() {
	test -f "$cloud_env_path"
}

cloud_ensure_env() {
	if ! cloud_env_exists; then
		error Environment not found
	fi
}

cloud_choose_name() {
	if [ -z $cloud_name ]; then
		echo "Enter name: \c"
		read	cloud_name
		add_conf "$cloud_base_path" cloud_name
	fi
}

cloud_choose_port() {
	if [ -z $rails_cluster_port ]; then
		echo "Enter port: \c"
		read	rails_cluster_port
		add_conf "$cloud_env_path" rails_cluster_port
	fi
}

cloud_set_paths() {
	while getopts 'c:e:' o; do
		case "$o" in
		c)
			cloud_context=$OPTARG
		;;
		e)
			cloud_env=$OPTARG
		;;
		esac
	done
	if [ -z $cloud_context ]; then
		cloud_context=${CLOUD_CONTEXT:-local}
	fi
	if [ -z $cloud_env ]; then
		if [ -z $RAILS_ENV ]; then
			if [ $cloud_context != local ]; then
				cloud_env=production
			else
				cloud_env=development
			fi
		else
			cloud_env=$RAILS_ENV
		fi
	fi
	shift $((OPTIND-1))
	if [ ! -z "$1" ]; then
		if [ ${1:0:1} = / ]; then
			app_path=$1
		else
			app_path=$PWD/$1
		fi
	else
		app_path=$PWD
	fi
	cloud_path=$app_path/cloud
	cloud_kube_path=$cloud_path/kube
	cloud_contexts_path=$cloud_path/contexts
	cloud_local_path=$cloud_contexts_path/local
	cloud_context_path=$cloud_contexts_path/$cloud_context
	cloud_envs_path=$cloud_path/envs
	cloud_base_path=$cloud_envs_path/base
	cloud_dev_path=$cloud_envs_path/development
	cloud_prod_path=$cloud_envs_path/production
	cloud_env_path=$cloud_envs_path/$cloud_env
	cloud_tmp_path=$app_path/tmp/cloud
	cloud_kubeconfig_path=$cloud_tmp_path/kubeconfig
	cloud_compile_path=$cloud_tmp_path/compile
	cloud_apply_path=$cloud_tmp_path/apply
	cloud_docker_path=$cloud_apply_path/docker.yml
	cloud_volume_path=$cloud_apply_path/volume.yml
	cloud_claim_path=$cloud_apply_path/claim.yml
	cloud_aws_path=$cloud_apply_path/aws.yml
	cloud_namespace_path=$cloud_apply_path/namespace.yml
	cloud_kustomization_path=$cloud_apply_path/kustomization.yml
	cloud_build_path=$cloud_path/build
	cloud_deploy_path=$cloud_path/deploy
	cloud_snippets_path=$cloud_deploy_path/snippets
	cloud_samples_path=$cloud_tmp_path/samples
	cloud_sample_paths=(
		config/puma.rb
		config/database.yml
		config/cable.yml
		test/test_helper.rb
		test/application_system_test_case.rb
	)
}

cloud_clone() {
	begin Cloning Repository
	if [ ! -d $repo_path ]; then
		mkdir -p $tmp_path
		git clone git@github.com:chi-rb/chi-cloud.git $tmp_repo_path
		sudo mv $tmp_repo_path $repo_path
	else
		echo Already cloned
	fi
}

cloud_authorize_terminal() {
	begin Authorizing Terminal
	if ! bin_authorized $terminal_path $terminal_client; then
		authorize_bin $terminal_path $terminal_client
		echo Restart terminal and run the script again
		exit
	else
		echo Already authorized
	fi
}

cloud_authorize_nfsd() {
	begin Authorizing NFSD
	if ! bin_authorized $nfsd_path; then
		authorize_bin $nfsd_path
		update_nfsd
	else
		echo Already authorized
	fi
}

cloud_authorize_xhyve() {
	begin Authorizing XHYVE
	if ! bin_authorized $repo_xhyve_path; then
		authorize_bin $repo_xhyve_path
	else
		echo Already authorized
	fi
}

cloud_update_rc() {
	begin Prepending PATH
	ruby=$(which ruby)
	if [ $ruby != $repo_ruby_path ]; then
		cat <<-DOC
			Add this into your shell rc file:
			PATH=/usr/local/cloud/bin:$PATH

			And then:
			. /shell-rc-path
		DOC
	else
		echo Already updated	
	fi
}

cloud_install() {
	cloud_clone
	cloud_authorize_terminal
	cloud_authorize_nfsd
	cloud_authorize_xhyve
	vm_install nested
	cloud_config
	cloud_update_rc
	complete
}

cloud_delete_settings() {
	begin Deleting Settings
	if [ -d $user_cloud_path ]; then
		rm -rf $user_cloud_path
	else
		echo Not found
	fi
}

cloud_delete_repo() {
	begin Deleting Cloud
	if [ -d $repo_path ]; then
		sudo rm -rf $repo_path
	else
		echo Not found
	fi
}

cloud_uninstall() {
	vm_uninstall nested
	cloud_delete_settings
	cloud_delete_repo
	complete
}

cloud_update() {
	begin Updating Script
	current_path=$PWD
	cd $repo_path
	git pull
	current_branch=$(git branch | cut -d ' ' -f2)
	new_branch=${2:-master}
	if [ $current_branch != $new_branch ]; then
		git checkout $new_branch
	fi
	cd "$current_path"
	complete
}

cloud_resolve_db() {
	cloud_db=postgres
	while getopts 'd:' o; do
		case "$o" in
		d)
			if [ $OPTARG != postgres ] && [ $OPTARG != mysql ]; then
				error Unknown database $OPTARG
			else
				cloud_db=$OPTARG
			fi
		;;
		esac
	done
	add_conf "$cloud_base_path" cloud_db
}

cloud_generate_tmp() {
	mkdir -p $tmp_path
	rm -rf $tmp_base_path
	cp -r $repo_base_path $tmp_base_path
	patch_name=$cloud_db.patch
	patch_path=$tmp_path/$patch_name
	cp $repo_app_path/$patch_name $tmp_path
	patch -s -p0 -d $tmp_path < $patch_path
	rm $patch_path
}

cloud_generate_app() {
	mkdir -p "$(dirname "$app_path")"
	mv $tmp_base_path "$app_path"
	git init "$app_path"
}

cloud_generate_dir() {
	mv $tmp_cloud_path "$cloud_path"
	mkdir -p "$cloud_samples_path"
	for sample_path in "${cloud_sample_paths[@]}"; do
		destination_path=$cloud_samples_path/$sample_path
		mkdir -p "$(dirname "$destination_path")"
		cp $tmp_base_path/$sample_path "$destination_path"
	done
	rm -rf $tmp_base_path
	echo You might need to tweak a few files, try using tmp/cloud/samples as a guideline
}

cloud_choose_settings() {
	begin Choosing Settings
	if [ -z $cloud_name ] || [ -z $rails_cluster_port ] || [ -z $cloud_provider ]; then
		cloud_choose_name
		cloud_choose_port
	else
		echo Already setted
	fi
}

cloud_generate() {
	begin Generating Directory
	if ! cloud_dir_exists; then
		cloud_resolve_db
		shift $((OPTIND-1))
		cloud_set_paths "$@"
		cloud_generate_tmp
		if [ ! -d "$app_path" ]; then
			cloud_generate_app
		else
			cloud_generate_dir
		fi
	else
		echo Already generated
	fi
}

cloud_init() {
	cloud_set_paths "$@"
	cloud_generate
	cloud_choose_settings
	complete
}

cloud_open() {
	cloud_load
	if [ $cloud_context = local ]; then
		url=$vm_name:$rails_cluster_port
	else
		url=$cloud_host
	fi
	open http://$url
}

cloud_bin() {
	cloud_set_paths
	abs_path=$1
	target=$(basename $abs_path)
	if cloud_dir_exists; then
		shift
		rel_path=bin/$target
		if [ -f $rel_path ]; then
			cmd=$rel_path
		else
			cmd=$target
		fi
		cloud_exec -- $cmd $@
	else
		alt=$(which -a $target | grep -A 1 $abs_path | tail -n 1)
		if [ -z "$alt" ]; then
			error "No alternative found for \`$target\`"
		else
			$alt $@
		fi
	fi
}

cloud_copy() {
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_kubectl cp $2 $name:$3
}

cloud_delete_namespace() {
	begin Deleting Namespace
	vm_kubectl delete namespace $cloud_id
}

cloud_delete_dir() {
	begin Deleting Cloud Directory
	if [ ! -d "$cloud_path" ]; then
		rm -rf "$cloud_path"
	else
		echo Not found
	fi
}

cloud_destroy() {
	cloud_load
	cloud_delete_namespace
	cloud_delete_dir
	complete
}

cloud_apply() {
	begin Applying YAMLs
	vm_kubectl apply -k \"$cloud_apply_path\"
}

cloud_clear_builds() {
	begin Clearing Builds
	cloud_kubectl delete pods -l type=build
}

cloud_log_builds() {
	begin Logging Builds
	cloud_kubectl wait pod \
	-l type=build \
	--for condition=Ready \
	--timeout=24h
	cloud_kubectl logs -f -l type=build
}

cloud_build() {
	cloud_load
	if [ $cloud_context != local ]; then
		unset cloud_kubeconfig
	fi
	cloud_clear_builds
	compile $@ build
	cloud_apply
	cloud_log_builds
	complete
}

cloud_deploy() {
	cloud_load
	compile deploy
	cloud_apply
	complete
}

cloud_restart() {
	cloud_load
	if [ -z "$cloud_kubeconfig" ]; then
		cmd='delete pod '
		if [ -z $1 ]; then
			cmd+='-l type!=build'
		else
			cmd+=$(cloud_find_pod $1)
		fi
	else
		cmd="rollout restart deployment $1"
	fi
	cloud_kubectl $cmd
}

cloud_shell() {
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_pod_exec $name /bin/bash
}

cloud_attach() {
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_kubectl attach -it $name
}

cloud_tunnel() {
	cloud_load
	port=$(cloud_kubectl get service $1 --no-headers=true | awk '{ print $5 }' | sed 's/\/.*//')
	name=$(cloud_find_pod $1)
	cloud_kubectl port-forward $name --address 0.0.0.0 $port:$port
}

cloud_exec() {
	cloud_load
	if [ $# -gt 2 ] && [ "$2" = -- ]; then
		name=$1
		shift 2
	elif [ $# -gt 1 ] && [ "$1" = -- ]; then
		shift
	else
		error Wrong format
	fi
	name=$(cloud_find_pod $name)
	cloud_pod_exec $name $@
}

cloud_status() {
	cloud_load
	if [ -z "$1" ]; then
		cloud_kubectl get pods
	else
		name=$(cloud_find_pod $1)
		cloud_kubectl describe pod $name
	fi
}

cloud_log() {
	cloud_load
	name=$(cloud_find_pod $1)
	cloud_kubectl logs -f $name
}

cloud_config() {
	if [ $cloud_context = local ]; then
		vm_kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml
	fi
	cat <<-YML | vm_kubectl apply -f -
		apiVersion: v1
		kind: PersistentVolumeClaim
		metadata:
		  name: registry
		  labels:
		    name: registry
		spec:
		  storageClassName: $cloud_storage_class
		  accessModes:
		  - ReadWriteOnce
		  resources:
		    requests:
		      storage: 1Gi
		---
		apiVersion: v1
		kind: Service
		metadata:
		  name: registry
		  labels:
		    name: registry
		spec:
		  type: NodePort
		  selector:
		    name: registry
		  ports:
		  - name: registry
		    port: 5000
		    nodePort: 32000
		---
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  name:  registry
		  labels:
		    name: registry
		spec:
		  selector:
		    matchLabels:
		      name: registry
		  template:
		    metadata:
		      labels:
		        name: registry
		    spec:
		      containers:
		      - image: registry:2
		        name: redis
		        volumeMounts:
		        - mountPath: /var/lib/registry
		          name: registry
		      volumes:
		      - name: registry
		        persistentVolumeClaim:
		          claimName: registry
	YML
}

cloud_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud <command> [options]
		Orchestrates Rails+Kubernetes Clouds.

		Available commands:
			install       Installs cloud
			uninstall     Uninstalls cloud
			update [tag]  Syncs latest or specific version
			init [path]   Generates directory and initializes
			destroy       Deletes directory and purges
			build         Builds docker images
			deploy        Deploys application
			undeploy      Undeploys application
			status [pod]  Prints status of pods (all by default)
			restart [pod] Restart pod (rails by default)
			shell [pod]   Opens a shell in pod (rails by default)
			attach pod    Attachs into first process of pod (rails by default)
			tunnel pod    Creates temporary tunnel into pod
			exec [pod]    Executes shell command in pod (rails by default)
			open          Opens browser pointing to app
			log [pod]     Tails pod log (rails by default)
			envs          Manages environments
			vm            Manages virtual machine
			help          Prints documentation
	DOC
}

# CONTEXTS

contexts_list() {
	cloud_set_paths
	cloud_ensure_dir
	list=$(ls -1 "$cloud_contexts_path")
	if [ -z "$list" ]; then
		error No contexts found
	else
		echo "$list"
	fi
}

contexts_choose_provider() {
	printf 'Choose provider: AWS (A)? '
	read input
	case $input in
	A|a|'')
		cloud_provider=aws
	;;
	*)
		echo Invalid option, try again
		contexts_choose_provider
	esac
	add_conf "$cloud_context_path" cloud_provider
}

contexts_add() {
	agent_ensure
	cloud_set_paths -c $1
	cloud_ensure_dir
	if ! cloud_context_exists; then
		cloud_ensure_env
		begin Adding Context $1
		ensure_file "$cloud_context_path"
		contexts_choose_provider
		cloud_boot
		case $cloud_provider in
		rancher)
			rancher_create_cloud
		;;
		aws)
			aws_create_cloud
		;;
		esac
		cloud_config
	else
		error Contexts already added
	fi
	complete
}

contexts_edit() {
	agent_ensure
	cloud_set_paths -c $1
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
	begin Editing Context $1
	edit "$cloud_context_path"
	case $cloud_provider in
	aws)
		aws_create_cloud
	;;
	esac
	complete
}

contexts_delete() {
	agent_ensure
	cloud_set_paths -c $1
	cloud_ensure_dir
	cloud_ensure_context
	cloud_ensure_env
	cloud_boot
	begin Deleting Context $1
	case $cloud_provider in
	aws)
		aws_delete_cloud
	;;
	esac
	rm -f "$cloud_context_path"
	complete
}

# ENVS

envs_list() {
	cloud_set_paths
	cloud_ensure_dir
	list=$(ls -1 "$cloud_envs_path")
	if [ -z "$list" ]; then
		error No environments found
	else
		echo "$list"
	fi
}

envs_add() {
	cloud_set_paths -e $1
	cloud_ensure_dir
	if ! cloud_env_exists; then
		begin Adding Environment $1
		ensure_file "$cloud_env_path"
		edit "$cloud_env_path"
	else
		error Environment already added
	fi
	complete
}

envs_edit() {
	cloud_set_paths -e $1
	cloud_ensure_dir
	cloud_ensure_env
	begin Editing Environment $1
	edit "$cloud_env_path"
	complete
}

envs_delete() {
	cloud_set_paths -e $1
	cloud_ensure_dir
	cloud_ensure_env
	begin Deleting Environment $1
	rm -f "$cloud_env_path"
	complete
}

envs_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud envs <command> [options]

		Available commands:
			list          Lists all
			add           Adds new
			edit          Edits existing
			delete        Delete existing 
			help          Prints documentation
	DOC
}

# VM

vm_shell() {
	agent_ensure
	vm_ssh
}

vm_net_exists() {
	if [ -f $user_conf_path ]; then
		for name in ${net_setting_names[@]}; do
			if cat $user_conf_path | grep $name >/dev/null 2>&1; then
				return 0
			fi
		done
		return 1
	else
		return 1
	fi
}

vm_ssh() {
	if [ $# -gt 0 ]; then
		cmd="sh -c '$@'"
	elif [ ! -t 0 ]; then
		cmd=sh
	fi
	ssh -tq \
	-o 'ConnectTimeout=10' \
	-o 'ControlMaster=auto' \
	-o 'ControlPersist=600' \
	-o 'ControlPath=/tmp/%r@%h' \
	-o 'UserKnownHostsFile=/dev/null' \
	-o 'StrictHostKeyChecking=no' \
	$vm_user@$vm_name $cmd
}

vm_wait_ssh() {
	begin Waiting SSH
	while :; do
		vm_ssh exit
		if [ $? = 0 ]; then
			echo
			break
		else
			printf .
			sleep $wait_count
		fi
	done
}

vm_kubectl() {
	if [ ! -z "$cloud_kubeconfig" ]; then
		echo "$cloud_kubeconfig" > $cloud_kubeconfig_path
		cmd="--kubeconfig \"$cloud_kubeconfig_path\" $@"
	else
		cmd=$@
	fi
	vm_ssh kubectl $cmd
}

vm_download() {
	begin Dowloading Images
	if [ ! -d $repo_vm_path ]; then
		mkdir $repo_vm_path
		curl -o $repo_initrd_path $s3_initrd_url
		curl -o $repo_vmlinuz_path $s3_vmlinuz_url
		curl -o $repo_disk_path $s3_disk_url
	else
		echo Already downloaded
	fi
}

vm_create_disk() {
	begin Creating Disk
	if [ ! -f $user_disk_path ]; then
		tar xJvf $repo_disk_path -C $user_cloud_path
	else
		echo Already created
	fi
}

vm_first_boot() {
	begin First Boot
	if ! vm_net_exists; then
		echo Waiting to receive ip
		while :; do
			printf .
			agent_start
			mkdir -p $tmp_path
			nc -l 1234 > $tmp_conf_path & sleep $wait_count
			kill $! 2>/dev/null
			wait $! 2>/dev/null
			if [ -z "$(cat $tmp_conf_path)" ]; then
				agent_stop
			else
				break
			fi
		done
		. $tmp_conf_path
		cat $tmp_conf_path | add_conf $user_conf_path -
		rm $tmp_conf_path
	else
		echo Already booted
	fi
	echo
}

vm_add_host() {
	begin Adding Hostname
	if ! host_exists; then
		echo $vm_ip $vm_name | sudo tee -a $hosts_path
	else
		echo Already added
	fi
}

vm_share_home() {
	begin Sharing Home Directory
	if ! export_exists; then
		echo $exports_home_path -mapall=$(id -u) | sudo tee -a $exports_path
		update_nfsd
		vm_ssh <<-SSH
			echo "$mac_ip:$exports_home_path\t$HOME\tnfs local_lock=all\t0 0" >> /etc/fstab
			mkdir -p $HOME
			mount $HOME
		SSH
	else
		echo Already shared
	fi
}

vm_init() {
	begin Initializing Virtual Machine
	if [ -z $vm_id ]; then
		vm_id=$(gen_id)
		ensure_file $user_conf_path
		add_conf $user_conf_path vm_id
		vm_config nested
	else
		echo Already initialized
	fi
}

vm_install() {
	vm_download
	vm_init
	vm_create_disk
	vm_first_boot
	vm_add_host
	vm_share_home
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_delete_agent() {
	begin Deleting Agent
	if [ -f $user_agent_path ]; then
		sudo rm $user_agent_path
	else
		echo Not found
	fi
}

vm_id_exists() {
	cat $user_conf_path | grep vm_id >/dev/null 2>&1
}

vm_delete_settings() {
	begin Deleting Settings
	if [ -f $user_conf_path ]; then
		if vm_id_exists; then
			delete_conf $user_conf_path vm_id
			found=true
		fi
		if vm_net_exists; then
			for name in ${net_setting_names[@]}; do
				delete_conf $user_conf_path $name
			done
			found=true
		fi
		if [ "$found" != true ]; then
			echo Not found
		fi
	else
		echo Not found
	fi
}

vm_delete_files() {
	begin Deleting Files
	if [ -d $repo_vm_path ]; then
		rm -rf $repo_vm_path
		rm -rf $user_disk_path
	else
		echo Not found
	fi
}

vm_delete_hostname() {
	begin Deleting Hostname
	if host_exists; then
		delete_conf $hosts_path $vm_name
	else
		echo Not found
	fi
}

vm_unshare_home() {
	begin Unsharing Home Directory
	if export_exists; then
		escaped_exports_home_path=$(echo $exports_home_path | sed 's/\//\\\//g')
		delete_conf $exports_path $escaped_exports_home_path
		update_nfsd
	else
		echo Not shared
	fi
}

vm_uninstall() {
	vm_stop nested
	vm_delete_agent
	if [ "$1" != nested ]; then
		vm_delete_settings
		vm_delete_files
	fi
	vm_delete_hostname
	vm_unshare_home
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_choose_settings() {
	if [ "$1" != nested ]; then
		begin Choosing Settings
	fi
	indexes=${!user_setting_names[@]}
	for i in $indexes; do
		desc=${user_setting_descs[$i]}
		value=${!user_setting_names[$i]}
		echo $desc: $value
	done
	if ! correct; then
		echo
		for i in $indexes; do
			desc=${user_setting_descs[$i]}
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			echo $desc: $value
			if ! correct; then
				echo "Enter new value: \c"
				read $name
			fi
			echo
		done
		touch $user_conf_path
		for i in $indexes; do
			name=${user_setting_names[$i]}
			value=${!user_setting_names[$i]}
			delete_conf $user_conf_path $name
			add_conf $user_conf_path $name $value
		done
		vm_choose_settings nested
	fi
}

vm_install_agent() {
	begin Installing Agent
	mkdir -p $(dirname $user_agent_path)
	cat <<-XML | sudo tee $user_agent_path >/dev/null
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
			<dict>
				<key>Label</key>
				<string>com.cloud</string>
				<key>ProgramArguments</key>
				<array>
					<string>$repo_xhyve_path</string>
					<string>-A</string>
					<string>-U</string>
					<string>$vm_id</string>
					<string>-c</string>
					<string>$vm_cpus</string>
					<string>-m</string>
					<string>$vm_mem</string>
					<string>-s</string>
					<string>0,hostbridge</string>
					<string>-s</string>
					<string>2,virtio-net</string>
					<string>-s</string>
					<string>4,virtio-blk,$user_disk_path</string>
					<string>-f</string>
					<string>kexec,$repo_vmlinuz_path,$repo_initrd_path,root=/dev/vda1 ro</string>
				</array>
				<key>RunAtLoad</key>
				<true/>
			</dict>
		</plist>
	XML
}

vm_config() {
	vm_choose_settings
	vm_install_agent
	if [ "$1" != nested ]; then
		vm_restart
		complete
	fi
}

vm_start() {
	begin Starting Virtual Machine
	if ! agent_running; then
		agent_start
		vm_wait_ssh
	else
		echo Already running
	fi
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_stop() {
	begin Stopping Virtual Machine
	if agent_running; then
		agent_stop
	else
		echo Not running
	fi
	if [ "$1" != nested ]; then
		complete
	fi
}

vm_restart() {
	begin Restarting Virtual Machine
	vm_stop nested
	vm_start nested
	complete
}

vm_exec() {
	agent_ensure
	if [ $# -gt 1 ] && [ "$1" = -- ]; then
		shift
	else
		error Wrong format
	fi
	vm_ssh <<-SSH
		cd $PWD
		$@
	SSH
}

vm_update_packages() {
	begin Updating Packages
	vm_ssh <<-SSH
		apt update
		DEBIAN_FRONTEND=noninteractive apt upgrade -y && apt autoremove -y
	SSH
}

vm_update_k3s() {
	begin Updating K3S
	regex='v[0-9]+\.[0-9]+\.[0-9]+\+k3s.?[0-9]+'
	current_version=$(vm_ssh k3s -v | grep -oE $regex)
	latest_version=$(curl -s $k3s_latest_url | grep -oE $regex | head -n1)
	if [ -z $current_version ] || [ $current_version != $latest_version ]; then
		url="https://github.com/rancher/k3s/releases/download/$latest_version/k3s"
		vm_ssh <<-SSH
			systemctl stop k3s
			curl -Lo $k3s_path $url
			chmod +x $k3s_path
			systemctl start k3s
		SSH
	else
		echo Already updated
	fi
}

vm_update() {
	agent_ensure
	vm_update_packages
	vm_update_k3s
	complete
}

vm_help() {
	unknown $1
	cat <<-DOC
		Usage: cloud vm <command> [options]

		Available commands:
			install       Installs virtual machine
			uninstall     Uninstalls virtual machine
			start         Starts agent
			stop          Stops agent
			restart       Stops and starts agent
			shell         Opens a shell
			exec          Executes command
			update        Updates operating system
			help          Prints documentation
	DOC
}

# AWS

aws() {
	vm_ssh \
	AWS_ACCESS_KEY_ID=$aws_access_key_id \
	AWS_SECRET_ACCESS_KEY=$aws_secret_access_key \
	AWS_DEFAULT_REGION=$aws_region \
	AWS_PAGER= \
	aws $@ ||
	exit
}

aws_config() {
	begin Configure AWS
	if [ -z $aws_access_key_id ] || [ -z $aws_secret_access_key ] || [ -z $aws_region ]; then
		if [ -z $aws_access_key_id ]; then
			printf 'Enter access key id: '
			read aws_access_key_id
			add_conf "$cloud_context_path" aws_access_key_id
		fi
		if [ -z $aws_secret_access_key ]; then
			printf 'Enter secret access key: '
			read -s aws_secret_access_key
			add_conf "$cloud_context_path" aws_secret_access_key
		fi
		if [ -z $aws_region ]; then
			printf 'Enter region:'
			read aws_region
			add_conf "$cloud_context_path" aws_region
		fi
	else
		echo Already configured
	fi
}

aws_create_role() {
	begin Creating Role
	if [ -z $aws_role_arn ]; then
		aws_role_policy=$(cat <<-JSON
			{
				"Version": "2012-10-17",
				"Statement": [
					{
						"Effect": "Allow",
						"Principal": {
							"Service": "eks.amazonaws.com"
						},
						"Action": "sts:AssumeRole"
					},
					{
						"Effect": "Allow",
						"Principal": {
							"Service": "ec2.amazonaws.com"
						},
						"Action": "sts:AssumeRole"
					}
				]
			}
		JSON
		)
		aws_role_arn=$(
			aws iam create-role \
			--role-name $cloud_name \
			--assume-role-policy-document \'$aws_role_policy\' |
			read_json Arn
		)
		add_conf "$cloud_context_path" aws_role_arn
		for name in \
		AmazonEKSClusterPolicy \
		AmazonEKSServicePolicy \
		AmazonEKSWorkerNodePolicy \
		AmazonEKS_CNI_Policy \
		AmazonEC2ContainerRegistryReadOnly \
		AmazonRoute53FullAccess; do
			aws iam attach-role-policy \
			--role-name $cloud_name \
			--policy-arn arn:aws:iam::aws:policy/$name \
			>/dev/null
		done
	else
		echo Already created
	fi
}

aws_create_vpc() {
	begin Creating VPC
	if [ -z $aws_vpc_id ]; then
		aws_vpc_id=$(
			aws ec2 create-vpc --cidr-block 10.0.0.0/16 |
			read_json VpcId 
		)
    echo Waiting to be available
    wait_for aws_vpc_status available
		add_conf "$cloud_context_path" aws_vpc_id
		for name in support hostnames; do
			aws ec2 modify-vpc-attribute \
			--enable-dns-$name \
			--vpc-id $aws_vpc_id \
			>/dev/null
		done
		aws_route_table_id=$(
			aws ec2 describe-route-tables \
			--filters "Name=vpc-id,Values=$aws_vpc_id" |
			read_json RouteTableId
		)
		add_conf "$cloud_context_path" aws_route_table_id
	else
		echo Already created
	fi
}

aws_vpc_status() {
  aws ec2 describe-vpcs \
  --vpc-ids $aws_vpc_id |
  read_json State
}

aws_create_gateway() {
	begin Creating Gateway
	if [ -z $aws_gateway_id ]; then
		aws_gateway_id=$(
			aws ec2 create-internet-gateway |
			read_json InternetGatewayId
		)
		aws ec2 attach-internet-gateway \
		--vpc-id $aws_vpc_id \
		--internet-gateway-id $aws_gateway_id \
		>/dev/null
		aws ec2 create-route \
		--route-table-id $aws_route_table_id \
		--gateway-id $aws_gateway_id \
		--destination-cidr-block 0.0.0.0/0 \
		>/dev/null
		add_conf "$cloud_context_path" aws_gateway_id
	else
		echo Already created
	fi
}

aws_create_subnet() {
	begin Creating Subnet$1
	name=aws_subnet$1_id
	block=10.0.$1.0
	if [ -z ${!name} ]; then
		id=$(
			aws ec2 create-subnet \
			--vpc-id $aws_vpc_id \
			--cidr-block $block/24 \
			--availability-zone $2 |
			read_json SubnetId
		)
		echo Waiting to be available
		wait_for aws_subnet_status available
		export "$name=$id"
		add_conf "$cloud_context_path" $name
	else
		echo Already created
	fi
}

aws_subnet_status() {
	aws ec2 describe-subnets \
	--subnet-ids $id |
	read_json State
}

aws_create_efs_security_group() {
	begin Creating EFS Security Group
	if [ -z $aws_efs_security_group_id ]; then
		name=$cloud_id-efs
		aws_efs_security_group_id=$(
			aws ec2 create-security-group \
			 --vpc-id $aws_vpc_id \
			--group-name $name \
			--description $name |
			read_json GroupId
		)
		aws ec2 authorize-security-group-ingress \
		--group-id $aws_efs_security_group_id \
		--protocol tcp \
		--port 2049 \
		--cidr 10.0.0.0/16
		add_conf "$cloud_context_path" aws_efs_security_group_id
	else
		echo Already created	
	fi
}

aws_create_file_system() {
	begin Creating File System
	if [ -z $aws_file_system_id ]; then
		aws_file_system_id=$(
			aws efs create-file-system |
			read_json FileSystemId
		)
		echo Waiting to be available
		wait_for aws_file_system_status available
		add_conf "$cloud_context_path" aws_file_system_id
	else
		echo Already created
	fi
}

aws_file_system_status() {
	aws efs describe-file-systems \
	--file-system-id $aws_file_system_id |
	read_json LifeCycleState
}

aws_create_mount_target() {
	begin Creating Mount Target$1
	name=aws_mount_target$1_id
	if [ -z ${!name} ]; then
		subnet_name=aws_subnet$1_id
		id=$(
			aws efs create-mount-target \
			--file-system-id $aws_file_system_id \
			--subnet-id ${!subnet_name} \
			--security-groups $aws_efs_security_group_id |
			read_json MountTargetId
		)
		echo Waiting to be available
		wait_for aws_mount_target_status available
		export "$name=$id"
		add_conf "$cloud_context_path" $name
	else
		echo Already created
	fi
}

aws_mount_target_status() {
	aws efs describe-mount-targets \
	--mount-target-id $id |
	read_json LifeCycleState
}

aws_create_cluster() {
	begin Creating Cluster
	if [ -z $aws_cluster_name ]; then
		aws_cluster_name=$cloud_id
		aws eks create-cluster \
		--name $aws_cluster_name \
		--role-arn $aws_role_arn \
		--resources-vpc-config \
		subnetIds=$aws_subnet1_id,$aws_subnet2_id,endpointPrivateAccess=true,endpointPublicAccess=true \
		>/dev/null
		echo Waiting to be active
		wait_for aws_cluster_status ACTIVE
		add_conf "$cloud_context_path" aws_cluster_name
		json=$(aws eks describe-cluster --name $aws_cluster_name)
		aws_endpoint=$(echo "$json" | read_json endpoint)
		add_conf "$cloud_context_path" aws_endpoint
		aws_certificate=$(echo "$json" | read_json data)
		add_conf "$cloud_context_path" aws_certificate
	else
		echo Already created
	fi
}

aws_cluster_status() {
	aws eks describe-cluster \
	--name $aws_cluster_name |
	read_json status
}

aws_create_nodegroup() {
	begin Creating Nodegroup
	if [ -z $aws_nodegroup_name ]; then
		aws_nodegroup_name=default
		aws eks create-nodegroup \
		--cluster-name $aws_cluster_name \
		--node-role $aws_role_arn \
		--nodegroup-name $aws_nodegroup_name \
		--subnets $aws_subnet1_id $aws_subnet2_id \
		--scaling-config minSize=1,maxSize=1,desiredSize=1 \
		>/dev/null
		add_conf "$cloud_context_path" aws_nodegroup_name
		echo Waiting to be active
		wait_for aws_nodegroup_status ACTIVE
	else
		echo Already created
	fi
}

aws_nodegroup_status() {
	aws eks describe-nodegroup \
	--cluster-name $aws_cluster_name \
	--nodegroup-name $aws_nodegroup_name |
	read_json status
}

aws_install_efs_csi() {
	begin Installing EFS CSI
	if [ -z $aws_efs_csi ]; then
		vm_kubectl apply -k "github.com/kubernetes-sigs/aws-efs-csi-driver/deploy/kubernetes/overlays/stable/?ref=master"
		cat <<-YML | vm_kubectl apply -f -
			kind: StorageClass
			apiVersion: storage.k8s.io/v1
			metadata:
			  name: efs-sc
			provisioner: efs.csi.aws.com
		YML
		add_conf "$cloud_context_path" aws_efs_csi true
	else
		echo Already installed
	fi
}

aws_create_cloud() {
	aws_config
	aws_create_role
	aws_create_vpc
	aws_create_gateway
	aws_create_subnet 1 ${aws_region}a
	aws_create_subnet 2 ${aws_region}b
	aws_create_efs_security_group
	aws_create_file_system
	aws_create_mount_target 1
	aws_create_mount_target 2
	aws_create_cluster
	aws_create_nodegroup
	aws_install_efs_csi
}

if [ -f $user_conf_path ]; then
	. $user_conf_path
fi

case $1 in
install)
	cloud_install
;;
uninstall)
	cloud_uninstall
;;
update)
	cloud_update
;;
init)
	shift
	cloud_init "$@"
;;
open)
	cloud_open
;;
destroy)
	cloud_destroy
;;
bin)
	shift 
	cloud_bin $@
;;
copy)
	cloud_copy $2 $3 $4
;;
build)
	shift
	cloud_build $@
;;
deploy)
	cloud_deploy
;;
restart)
	cloud_restart $2
;;
shell)
	cloud_shell $2
;;
attach)
	cloud_attach $2
;;
tunnel)
	cloud_tunnel $2
;;
exec)
	shift
	cloud_exec $@
;;
status)
	cloud_status $2
;;
log)
	cloud_log $2
;;
envs)
	case $2 in
	''|list)
		envs_list
	;;
	add)
		envs_add $3
	;;
	edit)
		envs_edit $3
	;;
	delete)
		envs_delete $3
	;;
	help)
		envs_help
	;;
	*)
		envs_help $1
	;;
	esac
;;
contexts)
	case $2 in
	''|list)
		contexts_list
	;;
	add)
		contexts_add $3
	;;
	edit)
		contexts_edit $3
	;;
	delete)
		contexts_delete $3
	;;
	help)
		contexts_help
	;;
	*)
		contexts_help $1
	;;
	esac
;;
vm)
	case $2 in
	install)
		vm_install
	;;
	uninstall)
		vm_uninstall
	;;
	config)
		vm_config
	;;
	start)
		vm_start
	;;
	stop)
		vm_stop
	;;
	restart)
		vm_restart
	;;
	shell)
		vm_shell
	;;
	exec)
		shift 2
		vm_exec $@
	;;
	update)
		vm_update
	;;
	help)
		vm_help
	;;
	*)
		vm_help $2
	;;
	esac
;;
help)
	cloud_help
;;
*)
	cloud_help $1
;;
esac
